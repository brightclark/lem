(******************************************************************************)
(* Boolean                                                                    *)
(******************************************************************************)

(* rename module to clash with existing list modules of targets *)

(* declare rename module = lem_bool *)

(* The type bool is hard-coded, so are true and false *)

(* ----------------------- *)
(* not                     *)
(* ----------------------- *)

val not : bool -> bool
let not b = match b with
  | true -> false
  | false -> true
end

declare hol      target_rep function not = `~`
declare ocaml    target_rep function not = `not`
declare isabelle target_rep function not = `~`
declare coq      target_rep function not = `not`
declare html     target_rep function not = `&not;`


(* ----------------------- *)
(* and                     *)
(* ----------------------- *)

val (&&) : bool -> bool -> bool
let (&&) b1 b2 = match (b1, b2) with
  | (true, true) -> true
  | _ -> false
end


declare ascii_rep function (&&) = `and`

declare hol      target_rep function (&&) = infix `/\`
declare ocaml    target_rep function (&&) = infix `&&`
declare isabelle target_rep function (&&) = infix `\<and>`
declare coq      target_rep function (&&) = `and`
declare html     target_rep function (&&) = infix `&and;`



(* ----------------------- *)
(* or                      *)
(* ----------------------- *)

val (||) : bool -> bool -> bool
let (||) b1 b2 = match (b1, b2) with
  | (false, false) -> false
  | _ -> true
end
declare ascii_rep function (||) = `or`

declare hol      target_rep function (||) = infix `\/`
declare ocaml    target_rep function (||) = infix `||`
declare isabelle target_rep function (||) = infix `\<or>`
declare coq      target_rep function (||) = infix `or`
declare html     target_rep function (||) = infix `&or;`


(* ----------------------- *)
(* implication             *)
(* ----------------------- *)

val (-->) : bool -> bool -> bool
let (-->) b1 b2 = match (b1, b2) with
  | (true, false) -> false
  | _ -> true
end
declare ascii_rep function (-->) = `imp`

declare hol      target_rep function (-->) = infix `==>`
declare isabelle target_rep function (-->) = infix `\<implies>`
declare coq      target_rep function (-->) = `implies`
declare html     target_rep function (-->) = infix `&rarr;`

let inline {ocaml} imp x y = ((not x) || y)


(* ----------------------- *)
(* equivalence             *)
(* ----------------------- *)

val (<->) : bool -> bool -> bool
let (<->) b1 b2 = match (b1, b2) with
  | (true, true) -> true
  | (false, false) -> true
  | _ -> false
end
declare ascii_rep function (<->) = `equiv`

declare hol      target_rep function (<->) = infix `<=>`
declare isabelle target_rep function (<->) = infix `\<equiv>`
declare coq      target_rep function (<->) = infix `eqb`
declare ocaml    target_rep function (<->) = infix `=`
declare html     target_rep function (<->) = infix `&harr;`


