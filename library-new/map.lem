(******************************************************************************)
(* A library for finite maps                                                  *)
(******************************************************************************)

(* ========================================================================== *)
(* Header                                                                     *)
(* ========================================================================== *)

declare rename module = Lem_maps

open import Bool Basic_classes Function Maybe List Num

type map 'k 'v

(* -------------------------------------------------------------------------- *)
(* Map equality.                                                              *)
(* -------------------------------------------------------------------------- *)

val mapEqual : forall 'k 'v. map 'k 'v -> map 'k 'v -> bool
let inline mapEqual = unsafe_structural_equality

instance forall 'k 'v. Eq 'k, Eq 'v => (Eq (map 'k 'v))
  let (=) = mapEqual
end

(* -------------------------------------------------------------------------- *)
(* Basic maps and tests.                                                      *)
(* -------------------------------------------------------------------------- *)

val empty : forall 'k 'v. Ord 'k => map 'k 'v
val null  : forall 'k 'v. Ord 'k => map 'k 'v -> bool
lemma null_empty: (forall m. null m = (m = empty))

val size  : forall 'k 'v. Ord 'k => map 'k 'v -> nat

assert empty_null: (null (empty : map nat bool))
assert empty_size: (size (empty : map nat bool) = 0)


(* -------------------------------------------------------------------------- *)
(* Insertion.                                                                 *)
(* -------------------------------------------------------------------------- *)

val insert    : forall 'k 'v. Ord 'k => 'k -> 'v -> map 'k 'v -> map 'k 'v

val singleton : forall 'k 'v. Ord 'k => 'k -> 'v -> map 'k 'v
let singleton k v = insert k v empty

(* -------------------------------------------------------------------------- *)
(* Membership and lookup.                                                     *)
(* -------------------------------------------------------------------------- *)

val lookup          : forall 'k 'v. Ord 'k => map 'k 'v -> 'k -> 'v
val member          : forall 'k 'v. Ord 'k => 'k -> map 'k 'v -> bool
val notMember       : forall 'k 'v. Ord 'k => 'k -> map 'k 'v -> bool
let inline notMember k m = not (member k m)

val find            : forall 'k 'v. Ord 'k => 'k -> map 'k 'v -> maybe 'v
val findWithDefault : forall 'k 'v. Ord 'k => 'k -> 'v -> map 'k 'v -> 'v
let inline findWithDefault k v m = fromMaybe v (find k m)

lemma find_empty : (forall k. find k empty = Nothing)
lemma find_insert: (forall k k' v m. find k (insert k' v m) = (if (k = k') then Just v else find k m))

let member k m = isJust (find k m)
lemma member_empty : (forall k. not (member k empty))
lemma member_insert: (forall k k' v m. member k (insert k' v m) = ((k = k') || member k m))

 
 

(* -------------------------------------------------------------------------- *)
(* Set-like operations.                                                       *)
(* -------------------------------------------------------------------------- *)

val delete           : forall 'k 'v. Ord 'k => 'k -> map 'k 'v -> map 'k 'v

val difference       : forall 'k 'v 'w. Ord 'k => map 'k 'v -> map 'k 'w -> map 'k 'v

val intersection     : forall 'k 'v. Ord 'k => map 'k 'v -> map 'k 'v -> map 'k 'v

val union            : forall 'k 'v. Ord 'k => map 'k 'v -> map 'k 'v -> map 'k 'v
val unions           : forall 'k 'v. Ord 'k => list (map 'k 'v) -> map 'k 'v

val isSubmapOf       : forall 'k 'v. Ord 'k, Eq 'v => map 'k 'v -> map 'k 'v -> bool
val isProperSubmapOf : forall 'k 'v. Ord 'k, Eq 'v => map 'k 'v -> map 'k 'v -> bool

(* -------------------------------------------------------------------------- *)
(* Maps (in the functor sense).                                               *)
(* -------------------------------------------------------------------------- *)

val map             : forall 'k 'v 'w. Ord 'k => ('v -> 'w) -> map 'k 'v -> map 'k 'w

val mapMaybe        : forall 'k 'v. Ord 'k => ('v -> maybe 'v) -> map 'k 'v -> map 'k 'v
val mapMaybeWithKey : forall 'k 'v. Ord 'k => ('k -> 'v -> maybe 'v) -> map 'k 'v -> map 'k 'v
let mapMaybe f m = mapMaybeWithKey (fun k v -> f v) m

val adjust          : forall 'k 'v. Ord 'k => ('v -> 'v) -> 'k -> map 'k 'v -> map 'k 'v
val adjustWithKey   : forall 'k 'v. Ord 'k => ('k -> 'v -> 'v) -> 'k -> map 'k 'v -> map 'k 'v
let adjust f m = adjustWithKey (fun k v -> f v) m

val update          : forall 'k 'v. Ord 'k => ('v -> maybe 'v) -> 'k -> map 'k 'v -> map 'k 'v
val updateWithKey   : forall 'k 'v. Ord 'k => ('k -> 'v -> maybe 'v) -> 'k -> map 'k 'v -> map 'k 'v
let update f m = updateWithKey (fun k v -> f v) m

let ajust f k m = update (fun v -> Just (f v)) k m
let delete k m = update (fun v -> Nothing) k m


(* -------------------------------------------------------------------------- *)
(* Splitting, filtering and partitioning.                                     *)
(* -------------------------------------------------------------------------- *)

val filter           : forall 'k 'v. Ord 'k => ('v -> bool) -> map 'k 'v -> map 'k 'v
val filterWithKey    : forall 'k 'v. Ord 'k => ('k -> 'v -> bool) -> map 'k 'v -> map 'k 'v

let filterWithKey p m = mapMaybeWithKey (fun k v -> if (p k v) then Just v else Nothing) m
let filter p m = filterWithKey (fun k v -> p v) m

val partition        : forall 'k 'v. Ord 'k => ('v -> bool) -> map 'k 'v -> maybe (map 'k 'v * map 'k 'v)
val partitionWithKey : forall 'k 'v. Ord 'k => ('k -> 'v -> bool) -> map 'k 'v -> maybe (map 'k 'v * map 'k 'v)

val split            : forall 'k 'v. Ord 'k => 'k -> map 'k 'v -> maybe (map 'k 'v * map 'k 'v)

(* -------------------------------------------------------------------------- *)
(* Folds.                                                                     *)
(* -------------------------------------------------------------------------- *)

val fold         : forall 'k 'v 'w. Ord 'k => ('v -> 'w -> 'w) -> 'w -> map 'k 'v -> 'w
val foldWithKey  : forall 'k 'v 'w. Ord 'k => ('k -> 'v -> 'w -> 'w) -> 'w -> map 'k 'v -> 'w
val foldrWithKey : forall 'k 'v 'w. Ord 'k => ('k -> 'v -> 'w -> 'w) -> 'w -> map 'k 'v -> 'w
val foldlWithKey : forall 'k 'v 'w. Ord 'k => ('w -> 'k -> 'v -> 'w) -> 'w -> map 'k 'v -> 'w

(* -------------------------------------------------------------------------- *)
(* To and from lists.                                                         *)
(* -------------------------------------------------------------------------- *)

val keysAsc   : forall 'k 'v. Ord 'k => map 'k 'v -> list 'k
val elemsAsc  : forall 'k 'v. Ord 'k => map 'k 'v -> list 'v
val toAscList : forall 'k 'v. Ord 'k => map 'k 'v -> list ('k * 'v)

val fromList  : forall 'k 'v. Ord 'k => list ('k * 'v) -> map 'k 'v

(* -------------------------------------------------------------------------- *)
(* Minimum and maximum.                                                       *)
(* -------------------------------------------------------------------------- *)

val findMin   : forall 'k 'v. Ord 'k => map 'k 'v -> maybe ('k * 'v)
val findMax   : forall 'k 'v. Ord 'k => map 'k 'v -> maybe ('k * 'v)
val deleteMin : forall 'k 'v. Ord 'k => map 'k 'v -> map 'k 'v
val deleteMax : forall 'k 'v. Ord 'k => map 'k 'v -> map 'k 'v