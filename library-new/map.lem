(******************************************************************************)
(* A library for finite maps                                                  *)
(******************************************************************************)

(* ========================================================================== *)
(* Header                                                                     *)
(* ========================================================================== *)

declare ~{coq} rename module = Lem_maps

open import Bool Basic_classes Function Maybe List Num

type map 'k 'v

(* -------------------------------------------------------------------------- *)
(* Map equality.                                                              *)
(* -------------------------------------------------------------------------- *)

val mapEqual : forall 'k 'v. map 'k 'v -> map 'k 'v -> bool
let inline mapEqual = unsafe_structural_equality

instance forall 'k 'v. Eq 'k, Eq 'v => (Eq (map 'k 'v))
  let (=) = mapEqual
end

(* -------------------------------------------------------------------------- *)
(* Basic maps and tests.                                                      *)
(* -------------------------------------------------------------------------- *)

val empty : forall 'k 'v. Ord 'k => map 'k 'v

declare coq target_rep function empty = `map_empty`

val null  : forall 'k 'v. Ord 'k => map 'k 'v -> bool

declare coq target_rep function null = `map_is_empty`

lemma null_empty: (forall m. null m = (m = empty))

val size  : forall 'k 'v. Ord 'k => map 'k 'v -> nat

declare coq target_rep function size = `map_size`

assert empty_null: (null (empty : map nat bool))
assert empty_size: (size (empty : map nat bool) = 0)

assert equal_1: (mapEqual (empty : map nat bool) empty)

(* -------------------------------------------------------------------------- *)
(* Insertion.                                                                 *)
(* -------------------------------------------------------------------------- *)

val insert    : forall 'k 'v. Ord 'k => 'k -> 'v -> map 'k 'v -> map 'k 'v

declare coq target_rep function insert = `map_add`

val singleton : forall 'k 'v. Ord 'k => 'k -> 'v -> map 'k 'v
let singleton k v = insert k v empty

assert insert_equal_singleton: (mapEqual (insert (42 : nat) false empty) 
                                         (singleton 42 false))
assert commutative_insert_1: (mapEqual 
                              (insert (8 : nat) true  (insert 5 false empty))
                              (insert  5        false (insert 8 true empty)))
assert commutative_insert_2: (not (mapEqual
                              (insert (8 : nat) true  (insert 8 false empty))
                              (insert  8        false (insert 8 true empty))))

(* -------------------------------------------------------------------------- *)
(* Membership and lookup.                                                     *)
(* -------------------------------------------------------------------------- *)

val lookup          : forall 'k 'v. Ord 'k => map 'k 'v -> 'k -> maybe 'v

declare coq target_rep function lookup = `map_lookup`

assert lookup_insert_1: (lookup (insert (16 : nat) true empty) 16 = Just true)
assert lookup_insert_3: (lookup (insert 36 false (insert (16 : nat) true empty)) 16 = Just false )

val member          : forall 'k 'v. Ord 'k => 'k -> map 'k 'v -> bool

val notMember       : forall 'k 'v. Ord 'k => 'k -> map 'k 'v -> bool
let inline notMember k m = not (member k m)

val find            : forall 'k 'v. Ord 'k => 'k -> map 'k 'v -> maybe 'v

declare coq target_rep function find = `map_find`

val findWithDefault : forall 'k 'v. Ord 'k => 'k -> 'v -> map 'k 'v -> 'v
let inline findWithDefault k v m = fromMaybe v (find k m)

assert find_empty_0: (find 25 (empty : map nat bool)  = Nothing)
assert find_insert_0:(find 16 (insert (16 : nat) true empty) = Just true)


lemma find_empty : (forall k. find k empty = Nothing)
lemma find_insert: (forall k k' v m. find k (insert k' v m) = (if (k = k') then Just v else find k m))

let member k m = isJust (find k m)
lemma member_empty : (forall k. not (member k empty))
lemma member_insert: (forall k k' v m. member k (insert k' v m) = ((k = k') || member k m))

declare coq target_rep function member = `map_member`
assert member_insert_1: (member 16 (insert (16 : nat) true empty))
assert member_insert_2: (not (member 25 (insert (16 : nat) true empty)))
assert member_insert_3: (member 16 (insert 36 false (insert (16 : nat) true empty)))
 
 

(* -------------------------------------------------------------------------- *)
(* Set-like operations.                                                       *)
(* -------------------------------------------------------------------------- *)

val delete           : forall 'k 'v. Ord 'k => 'k -> map 'k 'v -> map 'k 'v

val difference       : forall 'k 'v 'w. Ord 'k => map 'k 'v -> map 'k 'w -> map 'k 'v

declare coq target_rep function difference = `map_difference`

val intersection     : forall 'k 'v. Ord 'k => map 'k 'v -> map 'k 'v -> map 'k 'v

declare coq target_rep function intersection = `map_intersection`

val (union)          : forall 'k 'v. Ord 'k => map 'k 'v -> map 'k 'v -> map 'k 'v

declare coq target_rep function (union) = `map_union`

val unions           : forall 'k 'v. Ord 'k => list (map 'k 'v) -> map 'k 'v
let inline unions = foldr (union) empty

val isSubmapOf       : forall 'k 'v. Ord 'k, Eq 'v => map 'k 'v -> map 'k 'v -> bool

declare coq target_rep function isSubmapOf = `map_submap`

val isProperSubmapOf : forall 'k 'v. Ord 'k, Eq 'v => map 'k 'v -> map 'k 'v -> bool

declare coq target_rep function isProperSubmapOf = `map_proper_submap`

(* -------------------------------------------------------------------------- *)
(* Maps (in the functor sense).                                               *)
(* -------------------------------------------------------------------------- *)

val map             : forall 'k 'v 'w. Ord 'k => ('v -> 'w) -> map 'k 'v -> map 'k 'w

declare coq target_rep function map = `map_map`

val mapMaybe        : forall 'k 'v. Ord 'k => ('v -> maybe 'v) -> map 'k 'v -> map 'k 'v
val mapMaybeWithKey : forall 'k 'v. Ord 'k => ('k -> 'v -> maybe 'v) -> map 'k 'v -> map 'k 'v
let mapMaybe f m = mapMaybeWithKey (fun k v -> f v) m

val adjust          : forall 'k 'v. Ord 'k => ('v -> 'v) -> 'k -> map 'k 'v -> map 'k 'v
val adjustWithKey   : forall 'k 'v. Ord 'k => ('k -> 'v -> 'v) -> 'k -> map 'k 'v -> map 'k 'v
let adjust f m = adjustWithKey (fun k v -> f v) m

val update          : forall 'k 'v. Ord 'k => ('v -> maybe 'v) -> 'k -> map 'k 'v -> map 'k 'v
val updateWithKey   : forall 'k 'v. Ord 'k => ('k -> 'v -> maybe 'v) -> 'k -> map 'k 'v -> map 'k 'v
let update f m = updateWithKey (fun k v -> f v) m

let delete k m = update (fun v -> Nothing) k m

declare coq target_rep function delete = `map_delete`

assert delete_insert_1: (not (member (5 : nat) (delete 5 (insert 5 true empty))))
assert delete_insert_2:      (member (7 : nat) (delete 5 (insert 5 true empty)))
assert delete_delete: (null (delete (5 : nat) (delete (5 : nat) (insert 5 true empty))))


(* -------------------------------------------------------------------------- *)
(* Splitting, filtering and partitioning.                                     *)
(* -------------------------------------------------------------------------- *)

val filter           : forall 'k 'v. Ord 'k => ('v -> bool) -> map 'k 'v -> map 'k 'v
val filterWithKey    : forall 'k 'v. Ord 'k => ('k -> 'v -> bool) -> map 'k 'v -> map 'k 'v

let filterWithKey p m = mapMaybeWithKey (fun k v -> if (p k v) then Just v else Nothing) m
let filter p m = filterWithKey (fun k v -> p v) m

val partition        : forall 'k 'v. Ord 'k => ('v -> bool) -> map 'k 'v -> maybe (map 'k 'v * map 'k 'v)
val partitionWithKey : forall 'k 'v. Ord 'k => ('k -> 'v -> bool) -> map 'k 'v -> maybe (map 'k 'v * map 'k 'v)

val split            : forall 'k 'v. Ord 'k => 'k -> map 'k 'v -> maybe (map 'k 'v * map 'k 'v)

(* -------------------------------------------------------------------------- *)
(* Folds.                                                                     *)
(* -------------------------------------------------------------------------- *)

val fold         : forall 'k 'v 'w. Ord 'k => ('v -> 'w -> 'w) -> 'w -> map 'k 'v -> 'w
val foldWithKey  : forall 'k 'v 'w. Ord 'k => ('k -> 'v -> 'w -> 'w) -> 'w -> map 'k 'v -> 'w
val foldrWithKey : forall 'k 'v 'w. Ord 'k => ('k -> 'v -> 'w -> 'w) -> 'w -> map 'k 'v -> 'w
val foldlWithKey : forall 'k 'v 'w. Ord 'k => ('w -> 'k -> 'v -> 'w) -> 'w -> map 'k 'v -> 'w

(* -------------------------------------------------------------------------- *)
(* To and from lists.                                                         *)
(* -------------------------------------------------------------------------- *)

val keysAsc   : forall 'k 'v. Ord 'k => map 'k 'v -> list 'k
val elemsAsc  : forall 'k 'v. Ord 'k => map 'k 'v -> list 'v
val toAscList : forall 'k 'v. Ord 'k => map 'k 'v -> list ('k * 'v)

val fromList  : forall 'k 'v. Ord 'k => list ('k * 'v) -> map 'k 'v

(* -------------------------------------------------------------------------- *)
(* Minimum and maximum.                                                       *)
(* -------------------------------------------------------------------------- *)

val findMin   : forall 'k 'v. Ord 'k => map 'k 'v -> maybe ('k * 'v)
val findMax   : forall 'k 'v. Ord 'k => map 'k 'v -> maybe ('k * 'v)
val deleteMin : forall 'k 'v. Ord 'k => map 'k 'v -> map 'k 'v
val deleteMax : forall 'k 'v. Ord 'k => map 'k 'v -> map 'k 'v

assert to_and_from_assoc_list_1: (mapEqual (fromList (toAscList (insert (5:nat) true (insert 42 false empty))))
                                           (fromList [(42 , false); (5, true)]))

assert to_and_from_assoc_list_2: (mapEqual (fromList (toAscList (insert (5:nat) true (insert 42 false empty))))
                                           (fromList [(5, true); (42 , false)]))

assert mapMaybeWithKey_0: (mapEqual (mapMaybeWithKey (fun (k:nat) b -> if (k mod 2 = 1) then Just (not b) else Nothing)
                                                     (fromList [(1,true); (2,false); (3,true)]))
                                    (fromList [(1, false); (3,true)]))
assert mapMaybeWithKey_1: (mapEqual (mapMaybeWithKey (fun (k:nat) b -> Just b)
                                                     (fromList [(1,true); (2,false); (3,true)]))
                                    (fromList [(1,true); (2,false); (3,true)]))
assert mapMaybeWithKey_2: (null (mapMaybeWithKey (fun (k:nat) b -> Nothing)
                                   (fromList [(1,true); (2,false); (3,true)])))


