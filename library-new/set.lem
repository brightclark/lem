(******************************************************************************)
(* A library for sets                                                         *)
(*                                                                            *)
(* It mainly follows the Haskell Set-library                                  *)
(******************************************************************************)

(* Sets in Lem are a bit tricky. On the one hand, we want efficiently executable sets.
   OCaml and Haskell both represent sets by some kind of balancing trees. This means
   that sets are finite and an order on the elemet type is required. 
   Such sets are constructed by simple, executable operations like inserting or
   deleting elements, union, intersection, filtering etc.

   On the other hand, we want to use sets for specifications. This leads often
   infinite sets, which are specificied in complicated, perhaps even undecidable
   ways.

   The set library in this file, chooses the first approach. It describes 
   *finite* sets with an underlying order. Infinite sets should in the medium
   run be represented by a separate type. Since this would require some significant
   changes to Lem, for the moment also infinite sets are represented using this
   class. However, a run-time exception might occour when using these sets. 
   This problem needs adressing in the future. *)
   

(* ========================================================================== *)
(* Header                                                                     *)
(* ========================================================================== *)

open import Bool Basic_classes Maybe Function Num Set_helpers

declare {isabelle;hol;ocaml} rename module = lem_set

(* Type of sets and set comprehensions are hard-coded *)

(* ----------------------- *)
(* Equality check          *)
(* ----------------------- *)

val setEqual : forall 'a. Ord 'a => set 'a -> set 'a -> bool
let inline {coq; hol; isabelle} setEqual = unsafe_structural_equality 
declare ocaml    target_rep function setEqual = `Pset.equal`

instance forall 'a. Ord 'a => (Eq (set 'a))
  let (=) = setEqual
end


(* ----------------------- *)
(* Empty set               *)
(* ----------------------- *)

val empty : forall 'a. Ord 'a => set 'a 
val emptyBy : forall 'a. ('a -> 'a -> ordering) -> set 'a 

declare ocaml    target_rep function emptyBy = `Pset.empty`
let inline {ocaml} empty = emptyBy compare

declare coq      target_rep function empty = `set_empty`
declare hol      target_rep function empty = `EMPTY`
declare isabelle target_rep function empty = `{}`
declare html     target_rep function empty = `&empty;`

assert empty_0: (empty : set bool) = {}
assert empty_1: (empty : set nat) = {}
assert empty_2: (empty : set (list nat)) = {}
assert empty_3: (empty : set (set nat)) = {}

(* ----------------------- *)
(* any / all               *)
(* ----------------------- *)

val any : forall 'a. ('a -> bool) -> set 'a -> bool 
let inline any P s = (exists (e IN s). P e)

declare coq      target_rep function any = `set_exists`
declare hol      target_rep function any P s = `EXISTS` P (`SET_TO_LIST` s)
declare isabelle target_rep function any P s = `Set.Bex` s P
declare ocaml    target_rep function any = `Pset.exists`

val all : forall 'a. ('a -> bool) -> set 'a -> bool 
let inline all P s = (forall (e IN s). P e)

declare coq      target_rep function all = `set_for_all`
declare hol      target_rep function all P s = `EVERY` P (`SET_TO_LIST` s)
declare isabelle target_rep function all P s = `Set.Ball` s P
declare ocaml    target_rep function all = `Pset.for_all`


(* ----------------------- *)
(* (IN)                    *)
(* ----------------------- *)

val (IN) [`member`] : forall 'a. Ord 'a, Eq 'a => 'a -> set 'a -> bool 
val memberBy : forall 'a. ('a -> 'a -> bool) -> 'a -> set 'a -> bool 
let memberBy eq e s = any (eq e) s

declare coq      target_rep function memberBy eq e = `set_exists` (eq e)
declare ocaml    target_rep function member = `Pset.mem`
declare isabelle target_rep function member = infix `\<in>`
declare hol      target_rep function member = infix `IN`
declare html     target_rep function member = infix `&isin;`

let inline {coq} member = memberBy (=)

assert in_1: ((1:nat) IN {(2:nat);3;1})
assert in_2: (not ((1:nat) IN {2;3;4}))
assert in_3: (not ((1:nat) IN {}))
assert in_4: ((1:nat) IN {1;2;1;3;1;4})

(* ----------------------- *)
(* not (IN)                *)
(* ----------------------- *)

val (NIN) [`notMember`] : forall 'a. Ord 'a, Eq 'a => 'a -> set 'a -> bool 
let inline notMember e s = not (member e s)
declare html     target_rep function notMember = infix `&notin;`
declare isabelle target_rep function notMember = infix `\<notin>`

assert nin_1: not ((1:nat) NIN {2;3;1})
assert nin_2: ((1:nat) NIN {2;3;4})
assert nin_3: ((1:nat) NIN {})
assert nin_4: not ((1:nat) NIN {1;2;1;3;1;4})


(* ----------------------- *)
(* insert                  *)
(* ----------------------- *)

val insert : forall 'a. Ord 'a => 'a -> set 'a -> set 'a (* before add *)

declare ocaml    target_rep function insert = `Pset.add`
declare coq      target_rep function insert = `set_insert`
declare hol      target_rep function insert = `INSERT`
declare isabelle target_rep function insert = `Set.insert`

assert insert_1: ((insert (2:nat) {3;4}) = {2;3;4})
assert insert_2: ((insert (3:nat) {3;4}) = {3;4})
assert insert_3: ((insert (3:nat) {}) = {3})


(* ----------------------- *)
(* Emptyness check         *)
(* ----------------------- *)

val null : forall 'a. Ord 'a => set 'a -> bool (* before is_empty *)
let inline null s = (s = {})

declare ocaml    target_rep function null = `Pset.is_empty`
declare coq      target_rep function null = `set_is_empty`

assert null_1: (null ({}: set nat))
assert null_2: (not (null {(1:nat)}))


(* ------------------------ *)
(* singleton                *)
(* ------------------------ *)

val singleton : forall 'a. Ord 'a => 'a -> set 'a
let inline singleton x = {x}

declare coq target_rep function singleton = `set_singleton`

assert singleton_1 : singleton (2:nat) = {2}
assert singleton_2 : not (null (singleton (2:nat)))
assert singleton_3 : 2 IN (singleton (2:nat))
assert singleton_4 : 3 NIN (singleton (2:nat))


(* ----------------------- *)
(* size                    *)
(* ----------------------- *)

val size : forall 'a. Ord 'a => set 'a -> nat 

declare ocaml    target_rep function size = `Pset.cardinal`
declare coq      target_rep function size = `set_cardinal`
declare hol      target_rep function size = `CARD`
declare isabelle target_rep function size = `card`

assert size_1: (size ({}:set nat) = 0)
assert size_2: (size {(2:nat)} = 1)
assert size_3: (size {(1:nat);1} = 1)
assert size_4: (size {(2:nat);1;3} = 3)
assert size_5: (size {(2:nat);1;3;9} = 4)

lemma null_size: (forall s. (null s) --> (size s = 0))
lemma null_singleton: (forall x. (size (singleton x) = 1))


(* ----------------------------*)
(* setting up pattern matching *)
(* --------------------------- *)

val set_case : forall 'a 'b. Ord 'a => set 'a -> 'b -> ('a -> 'b) -> 'b -> 'b

(* please provide target bindings, since choose is defined only in extra 
   and not the right thing to use here anyhow. 

let set_case s c_empty c_sing c_else =
  if (null s) then c_empty else
  if (size s = 1) then c_sing (choose s)
  else c_else
*)


declare hol      target_rep function set_case = `TODO_set_case`
declare isabelle target_rep function set_case = `set_case`
declare coq      target_rep function set_case = `TODO_set_case`
declare ocaml    target_rep function set_case = `Pset.set_case`

declare pattern_match inexhaustive set 'a = [ empty; singleton ] set_case

assert set_patterns_0: (
  match ({} : set nat) with
    | empty -> true
    | _ -> false
  end
)

assert set_patterns_1: not (
  match {(2:nat)} with
    | empty -> true
    | _ -> false
  end
)

assert set_patterns_2: not (
  match {(3 : nat); 4} with
    | empty -> true
    | _ -> false
  end
)

assert set_patterns_3: (
  match ({2} : set nat) with
    | empty -> 0
    | singleton x -> x
    | _ -> 1
  end
) = 2

assert set_patterns_4: (
  match ({} : set nat) with
    | empty -> 0
    | singleton x -> x
    | _ -> 1
  end
) = 0

assert set_patterns_5: (
  match ({3;4;5} : set nat) with
    | empty -> 0
    | singleton x -> x
    | _ -> 1
  end
) = 1

assert set_patterns_6: (
  match ({3;3;3} : set nat) with
    | empty -> 0
    | singleton x -> x
    | _ -> 1
  end
) = 3

assert set_patterns_7: (
  match ({3;4;5} : set nat) with
    | empty -> 0
    | singleton _ -> 1
    | s -> size s
  end
) = 3

assert set_patterns_8: (
  match (({3;4;5} : set nat), false) with
    | (empty, true) -> 0
    | (singleton _, _) -> 1
    | (s, true) -> size s
    | _ -> 5
  end
) = 5

assert set_patterns_9: (
  match ({5} : set nat) with
    | empty -> 0
    | singleton 2 -> 0
    | singleton (x + 3) -> x
    | _ -> 1
  end
) = 2

assert set_patterns_10: (
  match ({2} : set nat) with
    | empty -> 0
    | singleton 2 -> 0
    | singleton (x + 3) -> x
    | _ -> 1
  end
) = 0


(* ----------------------- *)
(* filter                  *)
(* ----------------------- *)

val filter : forall 'a. ('a -> bool) -> set 'a -> set 'a 
let filter P s = {e | forall (e IN s) | P e}

declare ocaml    target_rep function filter = `Pset.filter`
declare isabelle target_rep function filter = `set_filter`

assert filter_1: (filter (fun n -> (n > 2)) {(1:nat);2;3;4} = {3;4})
assert filter_2: (filter (fun n -> n > (2:nat)) {} = {})
lemma filter_emp: (forall P. (filter P {}) = {})
lemma filter_insert: (forall e s P. (filter P (insert e s)) =
  (if (P e) then insert e (filter P s) else (filter P s)))


(* ----------------------- *)
(* partition               *)
(* ----------------------- *)

val partition : forall 'a. ('a -> bool) -> set 'a -> set 'a * set 'a
let partition P s = (filter P s, filter (fun e -> not (P e)) s)


(* ----------------------- *)
(* split                   *)
(* ----------------------- *)

val split : forall 'a. Ord 'a => 'a -> set 'a -> set 'a * set 'a
let split p s = (filter ((<) p) s, filter ((>) p) s)

val splitMember : forall 'a. Ord 'a, Eq 'a => 'a -> set 'a -> set 'a * bool * set 'a
let splitMember p s = (filter ((<) p) s, p IN s, filter ((>) p) s)


(* ------------------------ *)
(* subset and proper subset *)
(* ------------------------ *)

val isSubsetOfBy : forall 'a. ('a -> 'a -> bool) -> set 'a -> set 'a -> bool
let isSubsetOfBy eq s1 s2 = (all (fun e1 -> any (eq e1) s2) s1)

val isProperSubsetOfBy : forall 'a. ('a -> 'a -> bool) -> set 'a -> set 'a -> bool
let isProperSubsetOfBy eq s1 s2 = (isSubsetOfBy eq s1 s2 && not (isSubsetOfBy eq s2 s1))

val isSubsetOf : forall 'a. Ord 'a, Eq 'a => set 'a -> set 'a -> bool
let inline {coq} isSubsetOf s1 s2 = isSubsetOfBy (=) s1 s2

val isProperSubsetOf : forall 'a. Ord 'a, Eq 'a => set 'a -> set 'a -> bool
let inline isProperSubsetOf s1 s2 = isProperSubsetOfBy (=) s1 s2

declare ocaml    target_rep function isSubsetOf = `Pset.subset`
declare hol      target_rep function isSubsetOf = infix `SUBSET`
declare isabelle target_rep function isSubsetOf = infix `\<subseteq>`
declare html     target_rep function isSubsetOf = infix `&sube;`
declare coq      target_rep function isSubsetOfBy eq s1 s2 = `set_subset` eq s1 s2

declare ocaml    target_rep function isProperSubsetOf = `Pset.subset_proper`
declare hol      target_rep function isProperSubsetOf = infix `PSUBSET`
declare isabelle target_rep function isProperSubsetOf = infix `\<subset>`
declare html     target_rep function isProperSubsetOf = infix `&sub;`

let inline (subset) = isSubsetOf

assert isSubsetOf_1: (isSubsetOf ({}:set nat) {})
assert isSubsetOf_2: (isSubsetOf {(1:nat);2;3} {1;2;3})
assert isSubsetOf_3: (isSubsetOf {(1:nat);2} {3;2;1})
lemma isSubsetOf_refl: (forall s. isSubsetOf s s)
lemma isSubsetOf_def: (forall s1 s2. isSubsetOf s1 s2 = (forall e. e IN s1 --> e IN s2))
lemma isSubsetOf_eq: (forall s1 s2. (s1 = s2) <-> ((isSubsetOf s1 s2) && (isSubsetOf s2 s1)))

assert isProperSubsetOf_1: (not (isProperSubsetOf ({}:set nat) {}))
assert isProperSubsetOf_2: (not (isProperSubsetOf {(1:nat);2;3} {1;2;3}))
assert isProperSubsetOf_3: (isProperSubsetOf {(1:nat);2} {3;2;1})
lemma isProperSubsetOf_irrefl: (forall s. not (isProperSubsetOf s s))
lemma isProperSubsetOf_def: (forall s1 s2. isProperSubsetOf s1 s2 <-> ((isSubsetOf s1 s2) && not (isSubsetOf s2 s1)))


(* ------------------------ *)
(* delete                   *)
(* ------------------------ *)

val delete : forall 'a. Ord 'a, Eq 'a => 'a -> set 'a -> set 'a
val deleteBy : forall 'a. ('a -> 'a -> bool) -> 'a -> set 'a -> set 'a

let deleteBy eq e s = filter (fun e2 -> not (eq e e2)) s
let inline delete e s = deleteBy (=) e s


(* ------------------------ *)
(* union                    *)
(* ------------------------ *)

val (union) : forall 'a. Ord 'a => set 'a -> set 'a -> set 'a
declare ocaml    target_rep function (union) = `Pset.(union)`
declare hol      target_rep function (union) = `UNION`
declare isabelle target_rep function (union) = infix `\<union>`
declare coq      target_rep function (union) = `set_union` 


assert union_1: ({(1:nat);2;3} union {3;2;4} = {1;2;3;4})
lemma union_in: (forall e s1 s2. e IN (s1 union s2) <-> (e IN s1 || e IN s2))


(* ------------------------ *)
(* difference               *)
(* ------------------------ *)

val difference : forall 'a. Ord 'a => set 'a -> set 'a -> set 'a
declare ocaml    target_rep function difference = `Pset.diff`
declare hol      target_rep function difference = `DIFF`
declare isabelle target_rep function difference = infix `-`
declare coq      target_rep function difference = `set_diff` 

let inline (\) = difference

assert difference_1: (difference {(1:nat);2;3} {3;2;4} = {1})
lemma difference_in: (forall e s1 s2. e IN (difference s1 s2) <-> (e IN s1 && not (e IN s2)))

(* ------------------------ *)
(* intersection             *)
(* ------------------------ *)

val intersection : forall 'a. Ord 'a, Eq 'a => set 'a -> set 'a -> set 'a
val intersectionBy : forall 'a. ('a -> 'a -> bool) -> set 'a -> set 'a -> set 'a

declare ocaml    target_rep function intersection = `Pset.inter`
declare hol      target_rep function intersection = `INTER`
declare isabelle target_rep function intersection = infix `\<inter>`
declare coq      target_rep function intersectionBy = `set_inter` 

let inline {coq} intersection = intersectionBy (=)

let inline (inter) = intersection

assert intersection_1: (intersection {1;2;3} {(3:nat);2;4} = {2;3})
lemma intersection_in: (forall e s1 s2. e IN (intersection s1 s2) <-> (e IN s1 && e IN s2))


(* ------------------------ *)
(* map                      *)
(* ------------------------ *)

val map : forall 'a 'b. Ord 'a, Ord 'b => ('a -> 'b) -> set 'a -> set 'b (* before image *)
let map f s = { f e | forall (e IN s) | true }

val mapBy : forall 'a 'b. ('b -> 'b -> ordering) -> ('a -> 'b) -> set 'a -> set 'b 

declare ocaml    target_rep function mapBy = `Pset.map` 

let inline {ocaml} map = mapBy compare
declare hol      target_rep function map = `IMAGE`
declare isabelle target_rep function map = `Set.image`

assert map_1: (map succ {(2:nat);3;4} = {5;4;3}) 
assert map_2: (map (fun n -> n * 3) {(2:nat);3;4} = {6;9;12}) 


(* ------------------------ *)
(* min and max              *)
(* ------------------------ *)

val findMin : forall 'a.  Ord 'a, Eq 'a => set 'a -> maybe 'a 
val findMax : forall 'a.  Ord 'a, Eq 'a => set 'a -> maybe 'a 

(* Informal, since THE is not supported by all backends
val findMinBy : forall 'a.  ('a -> 'a -> bool) -> ('a -> 'a -> bool) -> set 'a -> maybe 'a 
let findMinBy le eq s = THE (fun e -> ((memberBy eq e s) && (forall (e2 IN s). le e e2)))

let inline findMin = findMinBy (<=) (=)
let inline findMax = findMinBy (>=) (=)
*)

declare ocaml target_rep function findMin = `Pset.min_elt_opt` 
declare ocaml target_rep function findMax = `Pset.max_elt_opt` 



(* ------------------------ *)
(* fromList                 *)
(* ------------------------ *)

val fromList : forall 'a.  Ord 'a => list 'a -> set 'a (* before from_list *)
val fromListBy : forall 'a.  ('a -> 'a -> ordering) ->  list 'a -> set 'a 

declare ocaml    target_rep function fromListBy = `Pset.from_list` 
let inline {ocaml} fromList = fromListBy compare
declare hol      target_rep function fromList = `LIST_TO_SET`
declare isabelle target_rep function fromList = `List.set`
declare coq      target_rep function fromList = `set_from_list`


assert fromList_1: (fromList [(2:nat);4;3] = {2;3;4}) 
assert fromList_2: (fromList [(2:nat);2;3;2;4] = {2;3;4}) 
assert fromList_3: (fromList ([] : list nat) = {}) 


(* ------------------------ *)
(* Sigma                    *)
(* ------------------------ *)

val sigma : forall 'a 'b. Ord 'a, Ord 'b, Eq 'a, Eq 'b => set 'a -> ('a -> set 'b) -> set ('a * 'b)
val sigmaBy : forall 'a 'b. (('a * 'b) -> ('a * 'b) -> ordering) -> set 'a -> ('a -> set 'b) -> set ('a * 'b)

declare ocaml    target_rep function sigmaBy = `Pset.sigma`

let sigma sa sb = { (a, b) | a IN sa && b IN sb a }
let inline {ocaml} sigma = sigmaBy compare
declare isabelle target_rep function sigma = `Sigma`

assert Sigma_1: (sigma {(2:nat);3} (fun n -> {n*2; n * 3}) = {(2,4); (2,6); (3,6); (3,9)})
lemma Sigma_2: (forall sa sb a b. ((a, b) IN sigma sa sb) <-> ((a IN sa) && (b IN sb a)))


(* ------------------------ *)
(* cross product            *)
(* ------------------------ *)

val cross : forall 'a 'b. Ord 'a, Ord 'b => set 'a -> set 'b -> set ('a * 'b)
val crossBy : forall 'a 'b. (('a * 'b) -> ('a * 'b) -> ordering) -> set 'a -> set 'b -> set ('a * 'b)

declare ocaml    target_rep function crossBy = `Pset.cross`

let cross s1 s2 = { (e1, e2) | forall (e1 IN s1) (e2 IN s2) | true }

declare isabelle target_rep function cross = infix `\<times>`
declare hol      target_rep function cross = `CROSS`
let inline {ocaml} cross = crossBy compare

assert cross_1 : (cross {(2:nat);3} {true; false} = {(2,true);(3,true); (2,false); (3,false)})


(* ------------------------ *)
(* finite                   *)
(* ------------------------ *)

val finite : forall 'a. Ord 'a => set 'a -> bool

let inline {ocaml;coq} finite _s = true
declare hol      target_rep function finite = `FINITE`
declare isabelle target_rep function finite = `finite`


(* ------------------------ *)
(* finite                   *)
(* ------------------------ *)


(* NOT DONE AFTER THIS POINT, PLEASE IGNORE 

val to_list : forall 'a. set 'a -> list 'a
let inline {ocaml} to_list = Ocaml.Pset.elements
let inline {hol} to_list = Hol.SET_TO_LIST
let inline {coq} to_list = Coq.set_to_list
let inline {isabelle} to_list = Isabelle.list_of_set

val compare: forall 'a. set 'a -> set 'a -> nat
let inline {coq} compare = Coq.set_compare

(* least fix point. The operation 
   lfp s f applies to f and gets a set s`.
   If s` contains new elements they are added to s and
   the process repeats. Otherwise s is returned.
*)
val monotone : forall 'a. (set 'a -> set 'a) -> bool
let inline {coq} monotone f = (forall s1 s2. s1 subset s2 --> f s1 subset f s2)
let inline {isabelle} monotone = Isabelle.mono
let inline {hol} monotone = Hol.monotone

val lfp : forall 'a. set 'a -> (set 'a -> set 'a) -> set 'a
let inline {ocaml} lfp = Ocaml.Pset.lfp
let inline {isabelle} lfp = Isabelle.set_lfp
let inline {hol} lfp s f = Hol.lfp (fun s` -> f s` union s)





skipped

lookupLT :: Ord a => a -> Set a -> Maybe aSource
lookupGT :: Ord a => a -> Set a -> Maybe aSource
lookupLE :: Ord a => a -> Set a -> Maybe aSource
lookupGE :: Ord a => a -> Set a -> Maybe aSource

lookupIndex :: Ord a => a -> Set a -> Maybe IntSource
findIndex :: Ord a => a -> Set a -> IntSource
elemAt :: Int -> Set a -> aSource
deleteAt :: Int -> Set a -> Set a
mapMonotonic :: (a -> b) -> Set a -> Set b


*)
