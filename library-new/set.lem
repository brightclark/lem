(******************************************************************************)
(* A library for sets                                                         *)
(*                                                                            *)
(* It mainly follows the Haskell Set-library                                  *)
(******************************************************************************)

(* Sets in Lem are a bit tricky. On the one hand, we want efficiently executable sets.
   OCaml and Haskell both represent sets by some kind of balancing trees. This means
   that sets are finite and an order on the elemet type is required. 
   Such sets are constructed by simple, executable operations like inserting or
   deleting elements, union, intersection, filtering etc.

   On the other hand, we want to use sets for specifications. This leads often
   infinite sets, which are specificied in complicated, perhaps even undecidable
   ways.

   The set library in this file, chooses the first approach. It describes 
   *finite* sets with an underlying order. Infinite sets should in the medium
   run be represented by a separate type. Since this would require some significant
   changes to Lem, for the moment also infinite sets are represented using this
   class. However, a run-time exception might occour when using these sets. 
   This problem needs adressing in the future. *)
   

(* ========================================================================== *)
(* Header                                                                     *)
(* ========================================================================== *)

declare rename module = lem_set

(* Type of sets and set comprehensions are hard-coded *)

(* ----------------------- *)
(* Equality check          *)
(* ----------------------- *)

val setEqual : forall 'a. Ord 'a => set 'a -> set 'a -> bool
let inline {hol, isabelle} setEqual = unsafe_structural_equality
declare targetrep ocaml    setEqual = 'Pset.equal'

instance forall 'a. Ord 'a => (Eq (set 'a))
  let (=) = setEqual
end


(* ----------------------- *)
(* Empty set               *)
(* ----------------------- *)

val empty : forall 'a. Ord 'a => set 'a 
val emptyBy : : forall 'a. ('a -> 'a -> ordering) -> set 'a 

let inline {ocaml} empty = emptyBy compare
declare targetrep coq      empty   = 'set_empty'
declare targetrep hol      empty   = 'EMPTY'
declare targetrep isabelle empty   = 'empty'

declare targetrep ocaml    emptyBy = 'Pset.empty' (compare : 'a -> 'a -> ordering)


(* ----------------------- *)
(* any / all               *)
(* ----------------------- *)

val any : forall 'a. Ord 'a => ('a -> bool) -> set 'a -> bool 
let any P s = (exists (e IN s). P s)

val all : forall 'a. Ord 'a => ('a -> bool) -> set 'a -> bool 
let all P s = (forall (e IN s). P s)


(* ----------------------- *)
(* (IN)                    *)
(* ----------------------- *)

val (IN) : forall 'a. Ord 'a => 'a -> set 'a -> bool 
declare ascii_rep function (IN) = member (* Haskell notation *)

let memberBy : forall 'a. ('a -> 'a -> bool) -> 'a -> set 'a -> bool 
let inline {coq} member = memberBy (=)
let memberBy eq e s = any (eq e) s

declare targetrep coq      memberBy eq e = 'set_exists' (eq e)
declare targetrep ocaml    member = 'Pset.mem'
declare targetrep isabelle member = 'Set.member_struct'
declare targetrep hol      member = infix 'IN'

assert in_1: (1 IN {2;3;1})
assert in_2: (not (1 IN {2;3;4}))
assert in_3: (not (1 IN {}))
assert in_4: (1 IN {1;2;1;3;1;4})


(* ----------------------- *)
(* not (IN)                *)
(* ----------------------- *)

val notMember : forall 'a. Ord 'a => 'a -> set 'a -> bool 
val inline notMember e s = not (member e s)


(* ----------------------- *)
(* insert                  *)
(* ----------------------- *)

val insert : forall 'a. Ord 'a => 'a -> set 'a -> set 'a (* before add *)

declare targetrep ocaml    insert = 'Pset.add'
declare targetrep coq      insert = 'set_insert'
declare targetrep hol      insert = 'INSERT'
declare targetrep isabelle insert = 'Set.insert'

assert insert_1: ((insert 2 {3;4}) = {2;3;4})
assert insert_2: ((insert 3 {3;4}) = {3;4})
assert insert_3: ((insert 3 {}) = {3})


(* ----------------------- *)
(* Emptyness check         *)
(* ----------------------- *)

val null : forall 'a. Ord 'a => set 'a -> bool (* before is_empty *)
let null s = (s = {})

declare targetrep ocaml    null = 'Pset.is_empty'
declare targetrep coq      null = 'set_is_empty'

assert is_empty_1: (Set.is_empty {})
assert is_empty_2: (not (Set.is_empty {1}))
lemma is_empty_lem: (forall s. (Set.is_empty s) --> (Set.cardinal s = 0))



(* ----------------------- *)
(* size                    *)
(* ----------------------- *)

val size : forall 'a. Ord 'a => set 'a -> num (* before cardinal *)

declare targetrep ocaml    size = 'Pset.cardinal'
declare targetrep coq      size = 'set_cardinal'
declare targetrep hol      size = 'CARD'
declare targetrep isabelle size = 'card'

assert size_1: (size ({}:set num) = 0)
assert size_2: (size {2} = 1)
assert size_3: (size {1;1} = 1)
assert size_4: (size {2;1;3} = 3)
assert size_5: (size {2;1;3;9} = 4)


(* ----------------------- *)
(* filter                  *)
(* ----------------------- *)

val filter : forall 'a. Ord 'a => ('a -> bool) -> set 'a -> set 'a 
let filter P s = {e | forall (e IN s) | P e}

declare targetrep ocaml    filter = 'Pset.filter'
declare targetrep isabelle filter = 'set_filter'

assert filter_1: (filter (fun n -> n > 2) {1;2;3;4}) = {3;4})
assert filter_2: (filter (fun n -> n > 2) {} = {})
lemma filter_emp: (forall P. (filter P {}) = {})
lemma filter_insert: (forall e s P. (filter P (insert e s)) =
  (if (P e) then insert e (filter P s) else (filter P s)))


(* ----------------------- *)
(* partition               *)
(* ----------------------- *)

val partition : forall 'a. Ord 'a => ('a -> bool) -> set 'a -> set 'a * set 'a
let partition P s = (filter P s, filter (fun e -> not (P e)) s)


(* ----------------------- *)
(* split                   *)
(* ----------------------- *)

val split : forall 'a. Ord 'a => 'a -> set 'a -> set 'a * set 'a
let split p s = (filter ((<) p) s, filter ((>) p) s)

val splitMember : forall 'a. Ord 'a => 'a -> set 'a -> set 'a * bool * set 'a
let splitMember p s = (filter ((<) p) s, p IN s, filter ((>) p) s)


(* ------------------------ *)
(* subset and proper subset *)
(* ------------------------ *)

val isSubsetOfBy : forall 'a. ('a -> 'a -> bool) -> set 'a -> set 'a -> bool
let isSubsetOfBy eq s1 s2 = (all (fun e1 -> any (eq e1) s2) s1)

val isProperSubsetOfBy : forall 'a. ('a -> 'a -> bool) -> set 'a -> set 'a -> bool
let isProperSubsetOfBy eq s1 s2 = (isSubsetOfBy eq s1 s2 && not (isSubsetOfBy eq s2 s1))

val isSubsetOf : forall 'a. Ord 'a => set 'a -> set 'a -> bool
let inline {coq} isSubsetOf s1 s2 = isSubsetOfBy (=) s1 s2

val isProperSubsetOf : forall 'a. Ord 'a => set 'a -> set 'a -> bool
let inline {coq} isProperSubsetOf s1 s2 = isProperSubsetOfBy (=) s1 s2

declare targetrep ocaml    isSubsetOf = infix 'subset'
declare targetrep hol      isSubsetOf = infix 'SUBSET'
declare targetrep isabelle isSubsetOf = 'Set.subset_eq'
declare targetrep coq      isSubsetOfBy eq s1 s2 = 'set_subset' eq s1 s2

declare targetrep hol      isProperSubsetOf = infix 'PSUBSET'
declare targetrep isabelle isProperSubsetOf = 'Set.subset'


assert isSubsetOf_1: (isSubsetOf ({}:set num) {})
assert isSubsetOf_2: (isSubsetOf {1;2;3} {1;2;3})
assert isSubsetOf_3: (isSubsetOf {1;2} {3;2;1})
lemma isSubsetOf_refl: (forall s. isSubsetOf s s)
lemma isSubsetOf_card: (forall s1 s2. isSubsetOf s1 s2 --> (size s1 <= size s2))
lemma isSubsetOf_def: (forall s1 s2. isSubsetOf s1 s2 = (forall e. e IN s1 --> e IN s2))
lemma isSubsetOf_eq: (forall s1 s2. (s1 = s2) <-> ((isSubsetOf s1 s2) && (isSubsetOf s2 s1)))

assert isProperSubsetOf_1: (not (isProperSubsetOf ({}:set num) {}))
assert isProperSubsetOf_2: (not (isProperSubsetOf {1;2;3} {1;2;3}))
assert isProperSubsetOf_3: (isProperSubsetOf {1;2} {3;2;1})
lemma isProperSubsetOf_irrefl: (forall s. not (isProperSubsetOf s s))
lemma isProperSubsetOf_card: (forall s1 s2. isProperSubsetOf s1 s2 --> (size s1 < size s2))
lemma isProperSubsetOf_def: (forall s1 s2. (isSubsetOf s1 s2) && not (isSubsetOf s2 s1))


(* ------------------------ *)
(* singleton                *)
(* ------------------------ *)

val singleton : forall 'a. Ord 'a => 'a -> set 'a
let inline singleton x = {x}

declare targetrep coq singleton = 'set_singleton'

(* ------------------------ *)
(* delete                   *)
(* ------------------------ *)

val delete : forall 'a. Ord 'a => 'a -> set 'a -> set 'a

let inline delete e s = deleteBy (=) e s
let deleteBy eq e s = filter (fun e2 -> not (eq e e2)) s


(* ------------------------ *)
(* union                    *)
(* ------------------------ *)

val union : forall 'a. Ord 'a => set 'a -> set 'a -> set 'a
declare targetrep ocaml    union = 'Pset.(union)'
declare targetrep hol      union = 'UNION'
declare targetrep isabelle union = 'Set.union'
declare targetrep coq      union = 'set_union' 


assert union_1: (union {1;2;3} {3;2;4} = {1;2;3;4})
lemma union_in: (forall e s1 s2. e IN (union s1 s2) <-> (e IN s1 || e IN s2))


(* ------------------------ *)
(* difference               *)
(* ------------------------ *)

val difference : forall 'a. Ord 'a => set 'a -> set 'a -> set 'a
declare targetrep ocaml    difference = 'Pset.diff'
declare targetrep hol      difference = 'DIFF'
declare targetrep isabelle difference = 'set_diff'
declare targetrep coq      difference = 'set_diff' 

assert difference_1: (difference {1;2;3} {3;2;4} = {1})
lemma difference_in: (forall e s1 s2. e IN (difference s1 s2) <-> (e IN s1 && not (e IN s2)))

(* ------------------------ *)
(* intersection             *)
(* ------------------------ *)

val intersection : forall 'a. Ord 'a => set 'a -> set 'a -> set 'a
val intersectionBy : forall 'a. ('a -> 'a -> bool) -> set 'a -> set 'a -> set 'a

let {coq} inline intersection = intersectionBy (=)

declare targetrep ocaml    intersection = 'Pset.inter'
declare targetrep hol      intersection = 'INTER'
declare targetrep isabelle intersection = 'inter'
declare targetrep coq      intersectionBy = 'set_inter' 

assert intersection_1: (difference {1;2;3} {3;2;4} = {2;3})
lemma intersection_in: (forall e s1 s2. e IN (intersection s1 s2) <-> (e IN s1 && e IN s2))


(* ------------------------ *)
(* map                      *)
(* ------------------------ *)

val map : forall 'a 'b. Ord 'a => Ord 'b => ('a -> 'b) -> set 'a -> set 'b (* before image *)
let map f s = { f e | forall (e IN s) | true }

val mapBy : forall 'a 'b. ('b -> 'b -> ordering) -> ('a -> 'b) -> set 'a -> set 'b 

let inline {ocaml} map = mapBy compare
declare targetrep ocaml    mapBy = 'Pset.map' 
declare targetrep hol      map = 'IMAGE'
declare targetrep isabelle map = 'Set.image'


(* ------------------------ *)
(* min and max              *)
(* ------------------------ *)

val findMin : forall 'a.  Ord 'a => set 'a -> maybe 'a 
val findMax : forall 'a.  Ord 'a => set 'a -> maybe 'a 
val findMinBy : forall 'a.  ('a -> 'a -> bool) -> set 'a -> maybe 'a 

let inline findMin = findMinBy (<=)
let inline findMax = findMinBy (>=)

let findMinBy le s = THE (fun e -> ((e IN s) && (forall (e2 IN s). le e e2)))


(* ------------------------ *)
(* fromList                 *)
(* ------------------------ *)

val fromList : forall 'a.  Ord 'a => list 'a -> set 'a (* before from_list *)
val fromListBy : forall 'a.  ('a -> 'a -> ordering) ->  list 'a -> set 'a 

let inline {ocaml} fromList = fromListBy compare
declare targetrep ocaml    fromListBy = 'Pset.from_list' 
declare targetrep hol      from_list = 'LIST_TO_SET'
declare targetrep isabelle from_list = 'List.set'
declare targetrep coq from_list = 'set_from_list'


(* ------------------------ *)
(* Sigma                    *)
(* ------------------------ *)

val sigma : forall 'a 'b. Ord 'a => Ord 'b -> set 'a -> ('a -> set 'b) -> set ('a * 'b)
let sigma sa sb = { (a, b) | a IN A && b IN B a }
declare targetrep isabelle Sigma = 'Sigma'

assert Sigma_1: (Sigma {2;3} (fun n -> {n*2; n * 3}) = {(2,4); (2,6); (3,6); (3,9)})
lemma Sigma_2: (forall sa sb a b. ((a, b) IN Sigma sa sb) <-> ((a IN sa) && (b IN sb a)))


(* ------------------------ *)
(* cross product            *)
(* ------------------------ *)

let cross : forall 'a. Ord 'a => Ord 'b => set 'a -> set 'b -> set ('a * 'b)
let cross s1 s2 = { (e1, e2) | forall (e1 IN s1) (e2 IN s2) | true }

declare targetrep isabelle cross = 'set_cross'
declare targetrep hol      cross = 'CROSS'


(* ------------------------ *)
(* finite                   *)
(* ------------------------ *)

val finite : forall 'a. Ord 'a => set 'a -> bool

let inline {ocaml;coq} finite s = true
declare targetrep hol      from_list = 'FINITE'
declare targetrep isabelle from_list = 'finite'


(* NOT DONE AFTER THIS POINT, PLEASE IGNORE 

val to_list : forall 'a. set 'a -> list 'a
let inline {ocaml} to_list = Ocaml.Pset.elements
let inline {hol} to_list = Hol.SET_TO_LIST
let inline {coq} to_list = Coq.set_to_list
let inline {isabelle} to_list = Isabelle.list_of_set

(* DPM: remember to change this so that the default value is returned for the other backends *)
val choose : forall 'a. set 'a -> 'a -> 'a
let inline {ocaml} choose s d = Ocaml.Pset.choose s
let inline {hol} choose s d = Hol.CHOICE s
let inline {isabelle} choose s d = Isabelle.set_choose s
let inline {coq} choose = Coq.set_choose

val fold : forall 'a 'b. ('a -> 'b -> 'b) -> set 'a -> 'b -> 'b
let inline {coq} fold = Coq.set_fold
let inline {ocaml} fold = Ocaml.Pset.fold
let inline {hol} fold = Hol.ITSET
let inline {isabelle} fold f A q = Isabelle.Finite_Set.fold f q A



val compare: forall 'a. set 'a -> set 'a -> num
let inline {coq} compare = Coq.set_compare

(* least fix point. The operation 
   lfp s f applies to f and gets a set s'.
   If s' contains new elements they are added to s and
   the process repeats. Otherwise s is returned.
*)
val monotone : forall 'a. (set 'a -> set 'a) -> bool
let inline {coq} monotone f = (forall s1 s2. s1 subset s2 --> f s1 subset f s2)
let inline {isabelle} monotone = Isabelle.mono
let inline {hol} monotone = Hol.monotone

val lfp : forall 'a. set 'a -> (set 'a -> set 'a) -> set 'a
let inline {ocaml} lfp = Ocaml.Pset.lfp
let inline {isabelle} lfp = Isabelle.set_lfp
let inline {hol} lfp s f = Hol.lfp (fun s' -> f s' union s)





skipped

lookupLT :: Ord a => a -> Set a -> Maybe aSource
lookupGT :: Ord a => a -> Set a -> Maybe aSource
lookupLE :: Ord a => a -> Set a -> Maybe aSource
lookupGE :: Ord a => a -> Set a -> Maybe aSource

lookupIndex :: Ord a => a -> Set a -> Maybe IntSource
findIndex :: Ord a => a -> Set a -> IntSource
elemAt :: Int -> Set a -> aSource
deleteAt :: Int -> Set a -> Set a
mapMonotonic :: (a -> b) -> Set a -> Set b


*)