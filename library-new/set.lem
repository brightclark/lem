(******************************************************************************)
(* A library for sets                                                         *)
(*                                                                            *)
(* It mainly follows the Haskell Set-library                                  *)
(******************************************************************************)

(* Sets in Lem are a bit tricky. On the one hand, we want efficiently executable sets.
   OCaml and Haskell both represent sets by some kind of balancing trees. This means
   that sets are finite and an order on the elemet type is required. 
   Such sets are constructed by simple, executable operations like inserting or
   deleting elements, union, intersection, filtering etc.

   On the other hand, we want to use sets for specifications. This leads often
   infinite sets, which are specificied in complicated, perhaps even undecidable
   ways.

   The set library in this file, chooses the first approach. It describes 
   *finite* sets with an underlying order. Infinite sets should in the medium
   run be represented by a separate type. Since this would require some significant
   changes to Lem, for the moment also infinite sets are represented using this
   class. However, a run-time exception might occour when using these sets. 
   This problem needs adressing in the future. *)
   

(* ========================================================================== *)
(* Header                                                                     *)
(* ========================================================================== *)

open import Bool Basic_classes Maybe Function Num

declare ~{html;tex} rename module = lem_set

(* Type of sets and set comprehensions are hard-coded *)

(* ----------------------- *)
(* Equality check          *)
(* ----------------------- *)

val setEqual : forall 'a. Ord 'a => set 'a -> set 'a -> bool
let inline {coq; hol; isabelle} setEqual = unsafe_structural_equality 
declare ocaml    target_rep function setEqual = `Pset.equal`

instance forall 'a. Ord 'a => (Eq (set 'a))
  let (=) = setEqual
end


(* ----------------------- *)
(* Empty set               *)
(* ----------------------- *)

val empty : forall 'a. Ord 'a => set 'a 
val emptyBy : forall 'a. ('a -> 'a -> ordering) -> set 'a 


declare ocaml    target_rep function emptyBy = `Pset.empty`
let inline {ocaml} empty = emptyBy compare

declare coq      target_rep function empty = `set_empty`
declare hol      target_rep function empty = `EMPTY`
declare isabelle target_rep function empty = `empty`
declare html     target_rep function empty = `&empty;`

(* ----------------------- *)
(* any / all               *)
(* ----------------------- *)

val any : forall 'a. ('a -> bool) -> set 'a -> bool 
let any P s = (exists (e IN s). P e)

val all : forall 'a. ('a -> bool) -> set 'a -> bool 
let all P s = (forall (e IN s). P e)


(* ----------------------- *)
(* (IN)                    *)
(* ----------------------- *)

val (IN) : forall 'a. Ord 'a, Eq 'a => 'a -> set 'a -> bool 
declare ascii_rep function (IN) = `member` (* Haskell notation *)

val memberBy : forall 'a. ('a -> 'a -> bool) -> 'a -> set 'a -> bool 
let memberBy eq e s = any (eq e) s

declare coq      target_rep function memberBy eq e = `set_exists` (eq e)
declare ocaml    target_rep function member = `Pset.mem`
declare isabelle target_rep function member = `Set.member`
declare hol      target_rep function member = infix `IN`
declare html     target_rep function member = infix `&isin;`

let inline {coq} member = memberBy (=)

assert in_1: ((1:nat) IN {2;3;1})
assert in_2: (not ((1:nat) IN {2;3;4}))
assert in_3: (not ((1:nat) IN {}))
assert in_4: ((1:nat) IN {1;2;1;3;1;4})


(* ----------------------- *)
(* not (IN)                *)
(* ----------------------- *)

val notMember : forall 'a. Ord 'a, Eq 'a => 'a -> set 'a -> bool 
let inline notMember e s = not (member e s)
declare html     target_rep function notMember = infix `&notin;`


(* ----------------------- *)
(* insert                  *)
(* ----------------------- *)

val insert : forall 'a. Ord 'a => 'a -> set 'a -> set 'a (* before add *)

declare ocaml    target_rep function insert = `Pset.add`
declare coq      target_rep function insert = `set_insert`
declare hol      target_rep function insert = `INSERT`
declare isabelle target_rep function insert = `Set.insert`

assert insert_1: ((insert (2:nat) {3;4}) = {2;3;4})
assert insert_2: ((insert (3:nat) {3;4}) = {3;4})
assert insert_3: ((insert (3:nat) {}) = {3})


(* ----------------------- *)
(* Emptyness check         *)
(* ----------------------- *)

val null : forall 'a. Ord 'a => set 'a -> bool (* before is_empty *)
let null s = (s = {})

declare ocaml    target_rep function null = `Pset.is_empty`
declare coq      target_rep function null = `set_is_empty`

assert null_1: (null ({}: set nat))
assert null_2: (not (null {(1:nat)}))


(* ------------------------ *)
(* fold                     *)
(* ------------------------ *)

(* fold is suspicious, because if given a function, for which
   the order, in which the arguments are given, matters, it's
   results are undefined. On the other hand, it is very handy to
   define other - non suspicious functions. 

   Moreover, fold is central for OCaml, size it is used to
   compile set comprehensions *)

val fold : forall 'a 'b. ('a -> 'b -> 'b) -> set 'a -> 'b -> 'b
declare compile_message fold = "fold is non-deterministic because the order of the iteration is unclear. It's result may differ between different backends. It may even not be a logical function, because the result may depend on the low-level representation of sets and be different for two representations of the same set."

declare hol      target_rep function fold = `ITSET`
declare isabelle target_rep function fold f A q = `Finite_Set.fold` f q A
declare ocaml    target_rep function fold = `Pset.fold`
declare coq      target_rep function fold = `set_fold`



(* ----------------------- *)
(* size                    *)
(* ----------------------- *)

val size : forall 'a. Ord 'a => set 'a -> nat (* before cardinal *)

declare ocaml    target_rep function size = `Pset.cardinal`
declare coq      target_rep function size = `set_cardinal`
declare hol      target_rep function size = `CARD`
declare isabelle target_rep function size = `card`

assert size_1: (size ({}:set nat) = 0)
assert size_2: (size {(2:nat)} = 1)
assert size_3: (size {(1:nat);1} = 1)
assert size_4: (size {(2:nat);1;3} = 3)
assert size_5: (size {(2:nat);1;3;9} = 4)

lemma null_size: (forall s. (null s) --> (size s = 0))


(* ----------------------- *)
(* filter                  *)
(* ----------------------- *)

val filter : forall 'a. ('a -> bool) -> set 'a -> set 'a 
let filter P s = {e | forall (e IN s) | P e}

declare ocaml    target_rep function filter = `Pset.filter`
declare isabelle target_rep function filter = `set_filter`

assert filter_1: (filter (fun n -> (n > 2)) {(1:nat);2;3;4} = {3;4})
assert filter_2: (filter (fun n -> n > (2:nat)) {} = {})
lemma filter_emp: (forall P. (filter P {}) = {})
lemma filter_insert: (forall e s P. (filter P (insert e s)) =
  (if (P e) then insert e (filter P s) else (filter P s)))


(* ----------------------- *)
(* partition               *)
(* ----------------------- *)

val partition : forall 'a. ('a -> bool) -> set 'a -> set 'a * set 'a
let partition P s = (filter P s, filter (fun e -> not (P e)) s)


(* ----------------------- *)
(* split                   *)
(* ----------------------- *)

val split : forall 'a. Ord 'a => 'a -> set 'a -> set 'a * set 'a
let split p s = (filter ((<) p) s, filter ((>) p) s)

val splitMember : forall 'a. Ord 'a, Eq 'a => 'a -> set 'a -> set 'a * bool * set 'a
let splitMember p s = (filter ((<) p) s, p IN s, filter ((>) p) s)


(* ------------------------ *)
(* subset and proper subset *)
(* ------------------------ *)

val isSubsetOfBy : forall 'a. ('a -> 'a -> bool) -> set 'a -> set 'a -> bool
let isSubsetOfBy eq s1 s2 = (all (fun e1 -> any (eq e1) s2) s1)

val isProperSubsetOfBy : forall 'a. ('a -> 'a -> bool) -> set 'a -> set 'a -> bool
let isProperSubsetOfBy eq s1 s2 = (isSubsetOfBy eq s1 s2 && not (isSubsetOfBy eq s2 s1))

val isSubsetOf : forall 'a. Ord 'a, Eq 'a => set 'a -> set 'a -> bool
let inline {coq} isSubsetOf s1 s2 = isSubsetOfBy (=) s1 s2

val isProperSubsetOf : forall 'a. Ord 'a, Eq 'a => set 'a -> set 'a -> bool
let inline isProperSubsetOf s1 s2 = isProperSubsetOfBy (=) s1 s2

declare ocaml    target_rep function isSubsetOf = infix `subset`
declare hol      target_rep function isSubsetOf = infix `SUBSET`
declare isabelle target_rep function isSubsetOf = `Set.subset_eq`
declare html     target_rep function isSubsetOf = infix `&sube;`
declare coq      target_rep function isSubsetOfBy eq s1 s2 = `set_subset` eq s1 s2

declare hol      target_rep function isProperSubsetOf = infix `PSUBSET`
declare isabelle target_rep function isProperSubsetOf = `Set.subset`
declare html     target_rep function isProperSubsetOf = infix `&sub;`


assert isSubsetOf_1: (isSubsetOf ({}:set nat) {})
assert isSubsetOf_2: (isSubsetOf {(1:nat);2;3} {1;2;3})
assert isSubsetOf_3: (isSubsetOf {(1:nat);2} {3;2;1})
lemma isSubsetOf_refl: (forall s. isSubsetOf s s)
lemma isSubsetOf_card: (forall s1 s2. isSubsetOf s1 s2 --> (size s1 <= size s2))
lemma isSubsetOf_def: (forall s1 s2. isSubsetOf s1 s2 = (forall e. e IN s1 --> e IN s2))
lemma isSubsetOf_eq: (forall s1 s2. (s1 = s2) <-> ((isSubsetOf s1 s2) && (isSubsetOf s2 s1)))

assert isProperSubsetOf_1: (not (isProperSubsetOf ({}:set nat) {}))
assert isProperSubsetOf_2: (not (isProperSubsetOf {(1:nat);2;3} {1;2;3}))
assert isProperSubsetOf_3: (isProperSubsetOf {(1:nat);2} {3;2;1})
lemma isProperSubsetOf_irrefl: (forall s. not (isProperSubsetOf s s))
lemma isProperSubsetOf_card: (forall s1 s2. isProperSubsetOf s1 s2 --> (size s1 < size s2))
lemma isProperSubsetOf_def: (forall s1 s2. (isSubsetOf s1 s2) && not (isSubsetOf s2 s1))


(* ------------------------ *)
(* singleton                *)
(* ------------------------ *)

val singleton : forall 'a. Ord 'a => 'a -> set 'a
let inline singleton x = {x}

declare coq target_rep function singleton = `set_singleton`

(* ------------------------ *)
(* delete                   *)
(* ------------------------ *)

val delete : forall 'a. Ord 'a, Eq 'a => 'a -> set 'a -> set 'a
val deleteBy : forall 'a. ('a -> 'a -> bool) -> 'a -> set 'a -> set 'a

let deleteBy eq e s = filter (fun e2 -> not (eq e e2)) s
let inline delete e s = deleteBy (=) e s


(* ------------------------ *)
(* union                    *)
(* ------------------------ *)

val union : forall 'a. Ord 'a => set 'a -> set 'a -> set 'a
declare ocaml    target_rep function union = `Pset.(union)`
declare hol      target_rep function union = `UNION`
declare isabelle target_rep function union = `Set.union`
declare coq      target_rep function union = `set_union` 


assert union_1: (union {(1:nat);2;3} {3;2;4} = {1;2;3;4})
lemma union_in: (forall e s1 s2. e IN (union s1 s2) <-> (e IN s1 || e IN s2))


(* ------------------------ *)
(* difference               *)
(* ------------------------ *)

val difference : forall 'a. Ord 'a => set 'a -> set 'a -> set 'a
declare ocaml    target_rep function difference = `Pset.diff`
declare hol      target_rep function difference = `DIFF`
declare isabelle target_rep function difference = `set_diff`
declare coq      target_rep function difference = `set_diff` 

assert difference_1: (difference {(1:nat);2;3} {3;2;4} = {1})
lemma difference_in: (forall e s1 s2. e IN (difference s1 s2) <-> (e IN s1 && not (e IN s2)))

(* ------------------------ *)
(* intersection             *)
(* ------------------------ *)

val intersection : forall 'a. Ord 'a, Eq 'a => set 'a -> set 'a -> set 'a
val intersectionBy : forall 'a. ('a -> 'a -> bool) -> set 'a -> set 'a -> set 'a

declare ocaml    target_rep function intersection = `Pset.inter`
declare hol      target_rep function intersection = `INTER`
declare isabelle target_rep function intersection = `inter`
declare coq      target_rep function intersectionBy = `set_inter` 

let inline {coq} intersection = intersectionBy (=)

assert intersection_1: (difference {1;2;3} {(3:nat);2;4} = {2;3})
lemma intersection_in: (forall e s1 s2. e IN (intersection s1 s2) <-> (e IN s1 && e IN s2))


(* ------------------------ *)
(* map                      *)
(* ------------------------ *)

val map : forall 'a 'b. Ord 'a, Ord 'b => ('a -> 'b) -> set 'a -> set 'b (* before image *)
let map f s = { f e | forall (e IN s) | true }

val mapBy : forall 'a 'b. ('b -> 'b -> ordering) -> ('a -> 'b) -> set 'a -> set 'b 

declare ocaml    target_rep function mapBy = `Pset.map` 

let inline {ocaml} map = mapBy compare
declare hol      target_rep function map = `IMAGE`
declare isabelle target_rep function map = `Set.image`


(* ------------------------ *)
(* min and max              *)
(* ------------------------ *)

val findMin : forall 'a.  Ord 'a, Eq 'a => set 'a -> maybe 'a 
val findMax : forall 'a.  Ord 'a, Eq 'a => set 'a -> maybe 'a 
val findMinBy : forall 'a.  ('a -> 'a -> bool) -> ('a -> 'a -> bool) -> set 'a -> maybe 'a 

let findMinBy le eq s = THE (fun e -> ((memberBy eq e s) && (forall (e2 IN s). le e e2)))

let inline findMin = findMinBy (<=) (=)
let inline findMax = findMinBy (>=) (=)


(* ------------------------ *)
(* fromList                 *)
(* ------------------------ *)

val fromList : forall 'a.  Ord 'a => list 'a -> set 'a (* before from_list *)
val fromListBy : forall 'a.  ('a -> 'a -> ordering) ->  list 'a -> set 'a 

declare ocaml    target_rep function fromListBy = `Pset.from_list` 
let inline {ocaml} fromList = fromListBy compare
declare hol      target_rep function fromList = `LIST_TO_SET`
declare isabelle target_rep function fromList = `List.set`
declare coq      target_rep function fromList = `set_from_list`


(* ------------------------ *)
(* Sigma                    *)
(* ------------------------ *)

val sigma : forall 'a 'b. Ord 'a, Ord 'b, Eq 'a, Eq 'b => set 'a -> ('a -> set 'b) -> set ('a * 'b)
let ~{ocaml} sigma sa sb = { (a, b) | a IN sa && b IN sb a }

declare ocaml    target_rep function sigma = `Pset.sigma`
declare isabelle target_rep function sigma = `Sigma`

assert Sigma_1: (sigma {(2:nat);3} (fun n -> {n*2; n * 3}) = {(2,4); (2,6); (3,6); (3,9)})
lemma Sigma_2: (forall sa sb a b. ((a, b) IN sigma sa sb) <-> ((a IN sa) && (b IN sb a)))


(* ------------------------ *)
(* cross product            *)
(* ------------------------ *)

val cross : forall 'a 'b. Ord 'a, Ord 'b => set 'a -> set 'b -> set ('a * 'b)
let cross s1 s2 = { (e1, e2) | forall (e1 IN s1) (e2 IN s2) | true }

declare isabelle target_rep function cross = `set_cross`
declare hol      target_rep function cross = `CROSS`


(* ------------------------ *)
(* finite                   *)
(* ------------------------ *)

val finite : forall 'a. Ord 'a => set 'a -> bool

let inline {ocaml;coq} finite s = true
declare hol      target_rep function finite = `FINITE`
declare isabelle target_rep function finite = `finite`


(* NOT DONE AFTER THIS POINT, PLEASE IGNORE 

val to_list : forall 'a. set 'a -> list 'a
let inline {ocaml} to_list = Ocaml.Pset.elements
let inline {hol} to_list = Hol.SET_TO_LIST
let inline {coq} to_list = Coq.set_to_list
let inline {isabelle} to_list = Isabelle.list_of_set

(* DPM: remember to change this so that the default value is returned for the other backends *)
val choose : forall 'a. set 'a -> 'a -> 'a
let inline {ocaml} choose s d = Ocaml.Pset.choose s
let inline {hol} choose s d = Hol.CHOICE s
let inline {isabelle} choose s d = Isabelle.set_choose s
let inline {coq} choose = Coq.set_choose

val fold : forall 'a 'b. ('a -> 'b -> 'b) -> set 'a -> 'b -> 'b
let inline {coq} fold = Coq.set_fold
let inline {ocaml} fold = Ocaml.Pset.fold
let inline {hol} fold = Hol.ITSET
let inline {isabelle} fold f A q = Isabelle.Finite_Set.fold f q A

val compare: forall 'a. set 'a -> set 'a -> nat
let inline {coq} compare = Coq.set_compare

(* least fix point. The operation 
   lfp s f applies to f and gets a set s`.
   If s` contains new elements they are added to s and
   the process repeats. Otherwise s is returned.
*)
val monotone : forall 'a. (set 'a -> set 'a) -> bool
let inline {coq} monotone f = (forall s1 s2. s1 subset s2 --> f s1 subset f s2)
let inline {isabelle} monotone = Isabelle.mono
let inline {hol} monotone = Hol.monotone

val lfp : forall 'a. set 'a -> (set 'a -> set 'a) -> set 'a
let inline {ocaml} lfp = Ocaml.Pset.lfp
let inline {isabelle} lfp = Isabelle.set_lfp
let inline {hol} lfp s f = Hol.lfp (fun s` -> f s` union s)





skipped

lookupLT :: Ord a => a -> Set a -> Maybe aSource
lookupGT :: Ord a => a -> Set a -> Maybe aSource
lookupLE :: Ord a => a -> Set a -> Maybe aSource
lookupGE :: Ord a => a -> Set a -> Maybe aSource

lookupIndex :: Ord a => a -> Set a -> Maybe IntSource
findIndex :: Ord a => a -> Set a -> IntSource
elemAt :: Int -> Set a -> aSource
deleteAt :: Int -> Set a -> Set a
mapMonotonic :: (a -> b) -> Set a -> Set b


*)