(******************************************************************************)
(* Basic Type Classes                                                         *)
(******************************************************************************)

open Bool

(* ========================================================================== *)
(* Equality                                                                   *)
(* ========================================================================== *)

(* Lem`s default equality (=) is defined by the following type-class Eq.
   This typeclass should define equality on an abstract datatype 'a. It should
   always coincide with the default equality of Coq, HOL and Isabelle.
   For OCaml, it might be different, since abstract datatypes like sets
   might have fancy equalities. *)

class ( Eq 'a ) 
  val (=) : 'a -> 'a -> bool
end
declare ascii_rep function (=) = isEqual

val (/=) : forall 'a. Eq 'a => 'a -> 'a -> bool
let (/=) x y = not (x = y)
declare ascii_rep function (/=) = isUnequal

val (<>) : forall 'a. Eq 'a => 'a -> 'a -> bool
let (<>) = isUnequal


(* (=) should for all instances be an equivalence relation 
   The isEquivalence predicate of relations could be used here.
   However, this would lead to a cyclic dependency. *)
lemma eq_equiv: ((forall x. (x = x)) &&
                 (forall x y. (x = y) <-> (y = x)) &&
                 (forall x y z. ((x = y) && (y = z)) --> (x = z)))


(* Structural equality *)

(* Sometimes, it is also handy to be able to use structural equality.
   This equality is mapped to the build-in equality of backends. This equality
   differs significantly for each backend. For example, OCaml can`t check equality
   of function types, whereas HOL can.  When using structural equality, one should 
   know what one is doing. The only guarentee is that is behaves like 
   the native backend equality.

   A lengthy name for structural equality is used to discourage its direct use.
   It also ensures that users realise it is unsafe (e.g. OCaml can`t check two functions
   for equality *)
val unsafe_structural_equality : forall 'a. 'a -> 'a -> bool

declare hol      target_rep function unsafe_structural_equality = infix `=`
declare ocaml    target_rep function unsafe_structural_equality = infix `=`
declare isabelle target_rep function unsafe_structural_equality = infix `=`
declare coq      target_rep function unsafe_structural_equality = infix `=`

(* ========================================================================== *)
(* Orderings                                                                  *)
(* ========================================================================== *)

(* The type-class Ord represents total orders (also called linear orders) *)
type ordering = LT | EQ | GT

instance (Eq ordering)
  let (=) = unsafe_structural_equality
end

class ( Ord 'a ) 
  val compare : 'a -> 'a -> ordering
end

val (<) : forall 'a. Ord 'a => 'a -> 'a -> bool
let (<) x y = (compare x y = LT)
declare ascii_rep function (<) = isLess

val (<=) : forall 'a. Ord 'a => 'a -> 'a -> bool
let (<=) x y = let r = compare x y in (r = LT || r = EQ)
declare ascii_rep function (<=) = isLessEqual

val (>) : forall 'a. Ord 'a => 'a -> 'a -> bool
let (>) x y = (compare x y = GT)
declare ascii_rep function (>) = isGreater

val (>=) : forall 'a. Ord 'a => 'a -> 'a -> bool
let (>=) x y = let r = compare x y in (r = GT || r = EQ)
declare ascii_rep function (>=) = isGreaterEqual

(* compare should really be a total order *)
lemma ord_OK_1: (
  (forall x y. (compare x y = EQ) <-> (compare y x = EQ)) &&
  (forall x y. (compare x y = LT) <-> (compare y x = GT)))

lemma ord_OK_2: (
  (forall x y z. (x <= y) && (y <= z) --> (x <= z)) &&
  (forall x y. (x <= y) || (y <= x))
)

val max : forall 'a. Ord 'a => 'a -> 'a -> 'a
let max x y = match compare x y with
  | LT -> y
  | EQ -> x
  | GT -> x
end

val min : forall 'a. Ord 'a => 'a -> 'a -> 'a
let min x y = match compare x y with
  | LT -> x
  | EQ -> x
  | GT -> y
end

(* DUMMY, TODO: remove and move proper versions into num *)
instance (Eq num)
  let (=) = unsafe_structural_equality
end

instance (Ord num)
  let compare = (fun x y -> EQ)
end



(* ========================================================================== *)
(* Instantiations                                                             *)
(* ========================================================================== *)

instance (Eq bool)
  let (=) = equiv_b
end

let boolCompare b1 b2 = match (b1, b2) with
  | (true, true) -> EQ
  | (true, false) -> GT
  | (false, true) -> LT
  | (false, false) -> EQ
end

instance (Ord bool)
  let compare = boolCompare
end


let pairEq (a1, b1) (a2, b2) =
  (a1 = a2) && (b1 = b2)

instance forall 'a 'b. Eq 'a, Eq 'b => (Eq ('a * 'b))
  let (=) = pairEq
end


let pairCompare (a1, b1) (a2, b2) =
  match compare a1 a2 with
    | LT -> LT
    | GT -> GT
    | EQ -> compare b1 b2
  end

instance forall 'a 'b. Ord 'a, Ord 'b => (Ord ('a * 'b))
  let compare = pairCompare
end



