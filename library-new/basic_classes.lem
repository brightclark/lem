(******************************************************************************)
(* Basic Type Classes                                                         *)
(******************************************************************************)

(* ========================================================================== *)
(* Equality                                                                   *)
(* ========================================================================== *)

(* Lem's default equality (=) is defined by the following type-class Eq.
   This typeclass should define equality on an abstract datatype 'a. It should
   always coincide with the default equality of Coq, HOL and Isabelle.
   For OCaml, it might be different, since abstract datatypes like sets
   might have fancy equalities. *)

class ( Eq 'a ) 
  val (=) : 'a -> 'a -> bool
end
declare ascii_rep function (=) = is_equal

val (/=) : forall 'a. Eq 'a => 'a -> 'a -> bool
let (/=) x y = not (x = y)
declare ascii_rep function (/=) = is_unequal

val (<>) : forall 'a. Eq 'a => 'a -> 'a -> bool
let inline (<>) = (/=)


(* (=) should for all instances be an equivalence relation *)
lemma eq_equiv: (isEquivalence (relFromPred (=)))


(* Structural equality *)

(* Sometimes, it is also handy to be able to use structural equality.
   This equality is mapped to the build-in equality of backends. This equality
   differs significantly for each backend. For example, OCaml can't check equality
   of function types, whereas HOL can.  When using structural equality, one should 
   know what one is doing. The only guarentee is that is behaves like 
   the native backend equality.

   A lengthy name for structural equality is used to discourage its direct use.
   It also ensures that users realise it is unsafe (e.g. OCaml can't check two functions
   for equality *)
val unsafe_structural_equality : forall 'a. 'a -> 'a -> bool

declare targetrep hol      append = infix '='
declare targetrep ocaml    append = infix '='
declare targetrep isabelle append = infix '='
declare targetrep coq      append = infix '='


(* ========================================================================== *)
(* Orderings                                                                  *)
(* ========================================================================== *)

(* The type-class Ord represents total orders (also called linear orders) *)
type ordering = LT | EQ | GT

instance (Eq ordering)
  let (=) = unsafe_structural_equality
end

class ( Ord 'a ) 
  val compare : 'a -> 'a -> ordering
end

val (<) : forall 'a. Ord 'a => 'a -> 'a -> bool
let (<) x y = (compare x y = LT)
declare ascii_rep function (<) = isLess

val (<=) : forall 'a. Ord 'a => 'a -> 'a -> bool
let (<=) x y = let r = compare x y in (r = LT || r = EQ)
declare ascii_rep function (<=) = isLessEqual

val (>) : forall 'a. Ord 'a => 'a -> 'a -> bool
let (>) x y = (compare x y = GT)
declare ascii_rep function (>) = isGreater

val (>=) : forall 'a. Ord 'a => 'a -> 'a -> bool
let (>=) x y = let r = compare x y in (r = GT || r = EQ)
declare ascii_rep function (>=) = isGreaterEqual

(* if we can compare, we can check for equality *)
instance forall 'a. Ord 'a => (Eq 'a)
  let (=) x y = (compare x y = EQ)
end

(* compare should really be a total order *)
lemma ord_OK_1: (
  (forall x y. (compare x y = EQ) <-> (compare y x = EQ)) &&
  (forall x y. (compare x y = LT) <-> (compare y x = GT)))

lemma ord_OK_2: (
  (forall x y z. (x <= y) && (y <= z) --> (x <= z)) &&
  (forall x y. (x <= y) || (y <= x))
)

val max : forall 'a. Ord 'a => 'a -> 'a -> 'a
let max x y = match compare x y with
  | LT -> y
  | EQ -> x
  | GT -> x
end

val min : forall 'a. Ord 'a => 'a -> 'a -> 'a
let min x y = match compare x y with
  | LT -> x
  | EQ -> x
  | GT -> y
end
