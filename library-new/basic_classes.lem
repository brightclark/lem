(******************************************************************************)
(* Basic Type Classes                                                         *)
(******************************************************************************)

open import Bool
declare {hol;isabelle} rename module = lem_basic_classes []

(* for Ocaml, keep the old name 
declare {ocaml;coq} rename module = basic_classes 
*)

(* ========================================================================== *)
(* Equality                                                                   *)
(* ========================================================================== *)

(* Lem`s default equality (=) is defined by the following type-class Eq.
   This typeclass should define equality on an abstract datatype 'a. It should
   always coincide with the default equality of Coq, HOL and Isabelle.
   For OCaml, it might be different, since abstract datatypes like sets
   might have fancy equalities. *)

class ( Eq 'a ) 
  val (=) [`isEqual`] : 'a -> 'a -> bool
end

declare coq target_rep function isEqual = infix `=`

class ( Ineq 'a ) 
  val (/=) [`isInequal`] : 'a -> 'a -> bool
end

declare coq target_rep function isInequal = infix `/=`


(* (=) should for all instances be an equivalence relation 
   The isEquivalence predicate of relations could be used here.
   However, this would lead to a cyclic dependency. *)
lemma eq_equiv: ((forall x. (x = x)) &&
                 (forall x y. (x = y) <-> (y = x)) &&
                 (forall x y z. ((x = y) && (y = z)) --> (x = z)))


(* Structural equality *)

(* Sometimes, it is also handy to be able to use structural equality.
   This equality is mapped to the build-in equality of backends. This equality
   differs significantly for each backend. For example, OCaml can`t check equality
   of function types, whereas HOL can.  When using structural equality, one should 
   know what one is doing. The only guarentee is that is behaves like 
   the native backend equality.

   A lengthy name for structural equality is used to discourage its direct use.
   It also ensures that users realise it is unsafe (e.g. OCaml can`t check two functions
   for equality *)
val unsafe_structural_equality : forall 'a. 'a -> 'a -> bool

declare hol      target_rep function unsafe_structural_equality = infix `=`
declare ocaml    target_rep function unsafe_structural_equality = infix `=`
declare isabelle target_rep function unsafe_structural_equality = infix `=`
declare coq      target_rep function unsafe_structural_equality = `classical_boolean_equivalence`

(* The default for equality is the unsafe structural one. It can 
   (and should) be overriden for concrete types later. *)
default_instance forall 'a. (Eq 'a) 
  let (=) = unsafe_structural_equality
end

default_instance forall 'a. Eq 'a => (Ineq 'a) 
  let (/=) x y = not (x = y)
end

(* ========================================================================== *)
(* Orderings                                                                  *)
(* ========================================================================== *)

(* The type-class Ord represents total orders (also called linear orders) *)
type ordering = LT | EQ | GT

declare ocaml target_rep type ordering = `int`
declare ocaml target_rep function LT = `~1`
declare ocaml target_rep function EQ = `0`
declare ocaml target_rep function GT = `1`

instance (Eq ordering)
  let (=) = unsafe_structural_equality
end

val defaultCompare : forall 'a. 'a -> 'a -> ordering
let defaultCompare x y = EQ
declare ocaml target_rep function defaultCompare = `compare`

class ( Ord 'a ) 
  val compare                 : 'a -> 'a -> ordering
  val (<)  [`isLess`]         : 'a -> 'a -> bool
  val (<=) [`isLessEqual`]    : 'a -> 'a -> bool
  val (>)  [`isGreater`]      : 'a -> 'a -> bool
  val (>=) [`isGreaterEqual`] : 'a -> 'a -> bool 
end

declare coq target_rep function isLess = infix `<`
declare coq target_rep function isLessEqual = infix `<=`
declare coq target_rep function isGreater = infix `>`
declare coq target_rep function isGreaterEqual = infix `>=`

lemma isLess_alt_def        : (forall x y. (x < y) = (let r = compare x y in (r = LT || r = EQ)))
lemma isLessEqual_alt_def   : (forall x y. (x <= y) = (compare x y = LT))
lemma isGreater_alt_def     : (forall x y. (x > y) = (y < x))
lemma isGreaterEqual_alt_def: (forall x y. (x >= y) = (y <= x))

(* compare should really be a total order *)
lemma ord_OK_1: (
  (forall x y. (compare x y = EQ) <-> (compare y x = EQ)) &&
  (forall x y. (compare x y = LT) <-> (compare y x = GT)))

lemma ord_OK_2: (
  (forall x y z. (x <= y) && (y <= z) --> (x <= z)) &&
  (forall x y. (x <= y) || (y <= x))
)

(* let's derive a compare function from the Ord type-class *)
val ordCompare : forall 'a. Eq 'a, Ord 'a => 'a -> 'a -> ordering
let ordCompare x y =
  if (x < y) then LT else
  if (x = y) then EQ else GT

class ( OrdMaxMin 'a ) 
  val max : 'a -> 'a -> 'a
  val min : 'a -> 'a -> 'a
end

val defaultMin : forall 'a. Ord 'a => 'a -> 'a -> 'a
let defaultMin x y = if (x <= y) then x else y
declare isabelle target_rep function defaultMin = `min`
declare ocaml    target_rep function defaultMin = `min`

val defaultMax : forall 'a. Ord 'a => 'a -> 'a -> 'a
let defaultMax x y = if (y <= x) then x else y
declare isabelle target_rep function defaultMax = `max`
declare ocaml    target_rep function defaultMax = `max`


default_instance forall 'a. Ord 'a => ( OrdMaxMin 'a) 
  let max = defaultMax
  let min = defaultMin
end


(* ========================================================================== *)
(* Instantiations                                                             *)
(* ========================================================================== *)

instance (Eq bool)
  let (=) = equiv
end

let boolCompare b1 b2 = match (b1, b2) with
  | (true, true) -> EQ
  | (true, false) -> GT
  | (false, true) -> LT
  | (false, false) -> EQ
end

instance (Ord bool)
  let compare = boolCompare
  let (<) x y = (not x && y)
  let (<=) x y = (x --> y)
  let (>) x y = (not y && x)
  let (>=) x y = (y --> x)
end

let pairEqual (a1, b1) (a2, b2) = (a1 = a2) && (b1 = b2)
let inline {hol;isabelle;coq} pairEqual = unsafe_structural_equality

instance forall 'a 'b. Eq 'a, Eq 'b => (Eq ('a * 'b))
  let (=) = pairEqual
end

let pairCompare (a1, b1) (a2, b2) =
  match compare a1 a2 with
    | LT -> LT
    | GT -> GT
    | EQ -> compare b1 b2
  end

let pairLess (x1, x2) (y1, y2) = (x1 < y1) || ((x1 <= y1) && (x2 < y2))
let pairLessEq (x1, x2) (y1, y2) = (x1 < y1) || ((x1 <= y1) && (x2 < y2))

let pairGreater x12 y12 = pairLess y12 x12
let pairGreaterEq x12 y12 = pairLessEq y12 x12

instance forall 'a 'b. Ord 'a, Ord 'b => (Ord ('a * 'b))
  let compare = pairCompare
  let (<)  = pairLess
  let (<=) = pairLessEq
  let (>)  = pairGreater
  let (>=) = pairGreaterEq
end
