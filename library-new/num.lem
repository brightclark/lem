(******************************************************************************)
(* A library for numbers                                                      *)
(*                                                                            *)
(* It mainly follows the Haskell Maybe-library                                *)
(******************************************************************************)

(* rename module to clash with existing list modules of targets
   problem: renaming from inside the module itself! *)
(*
declare rename module = lem_maybe
*)

open import Bool Basic_classes 


(* ========================================================================== *)
(* Numerals                                                                   *)
(* ========================================================================== *)

(* Numerals like 0, 1, 2, 42, 4543 are build-in. That's the only use
   of numerals. The following type-class is used to convert numerals into
   verious number types. The type of numerals differs form backend to backend.
   Essentially they are just printed as "0", "1", ... and the backend decides
   then. For Ocaml, they are integers. For HOL of type "num". Isabelle thinks
   they are polymorphic. ...
*)

declare hol      target_rep type numeral = `num` 
declare ocaml    target_rep type numeral = `int` 

class ( Numeral 'a ) 
  val fromNumeral : numeral -> 'a 
end


(* ========================================================================== *)
(* Syntactic type-classes for common operations                               *)
(* ========================================================================== *)

(* Typeclasses can be used as a mean to overload constants like "+", "-", etc *)

class ( NumNegate 'a ) 
  val ~ : 'a -> 'a 
end
declare ascii_rep function ~ = `numNegate`

class ( NumAdd 'a ) 
  val (+) : 'a -> 'a -> 'a
end
declare ascii_rep function (+) = `numAdd`

class ( NumMinus 'a ) 
  val (-) : 'a -> 'a -> 'a
end
declare ascii_rep function (-) = `numMinus`

class ( NumMult 'a ) 
  val ( * ) : 'a -> 'a -> 'a
end
declare ascii_rep function ( * ) = `numMult`

class ( NumPow 'a ) 
  val ( ** ) : 'a -> 'a -> 'a
end
declare ascii_rep function ( ** ) = `numPow`

class ( NumDivision 'a ) 
  val (/) : 'a -> 'a -> 'a
end
declare ascii_rep function (/) = `numDivision`

class ( NumIntegerDivision 'a ) 
  val (div) : 'a -> 'a -> 'a
end
declare ascii_rep function (div) = `numIntegerDivision`

class ( NumRemainder 'a ) 
  val (mod) : 'a -> 'a -> 'a
end
declare ascii_rep function (mod) = `numRemainder`

class ( NumSucc 'a ) 
  val succ : 'a -> 'a
end

instance forall 'a. Numeral 'a, NumAdd 'a => (NumSucc 'a) 
  let succ n = n + 1
end

class ( NumPred 'a ) 
  val pred : 'a -> 'a
end

instance forall 'a. Numeral 'a, NumMinus 'a => (NumPred 'a) 
  let pred n = n - 1
end

(* ========================================================================== *)
(* Basic number types                                                         *)
(* ========================================================================== *)

(* ----------------------- *)
(* nat                     *)
(* ----------------------- *)

(* bounded size natural numbers, i.e. positive integers *)

(* "nat" is the old type "num". It represents natural numbers. 
   These numbers might be bounded, however no checks of the boundedness are
   provided. The theorem prover backends map nat to unbounded size 
   natural numbers. However, OCaml uses the type "int", which is bounded.
   Using "int" allows using many functions like "List.length" without wrappers.
   This leeds to nice readable code, but a slightly fuzzy concept what
   "nat" represents. If you want to use unbounded natural numbers, use "natural"
   instead. *)

declare hol      target_rep type nat = `num` 
declare isabelle target_rep type nat = `nat` 
declare coq      target_rep type nat = `num` 
declare ocaml    target_rep type nat = `int` 


(* ----------------------- *)
(* natural                 *)
(* ----------------------- *)

(* unbounded size natural numbers *)
type natural
declare hol      target_rep type natural = `num` 
declare isabelle target_rep type natural = `nat` 
declare coq      target_rep type natural = `num` 
declare ocaml    target_rep type natural = `Big_int.big_int` 


(* ----------------------- *)
(* integer                 *)
(* ----------------------- *)

(* unbounded size integers *)

type integer
declare ocaml    target_rep type integer = `Big_int.big_int` 


(* ----------------------- *)
(* bint                    *)
(* ----------------------- *)

(* 32 bit integers *)
type int32 
declare ocaml    target_rep type int32 = `int32` 

(* 64 bit integers *)
type int64
declare ocaml    target_rep type int64 = `int64` 


(* ----------------------- *)
(* rational                *)
(* ----------------------- *)

(* unbounded size and precision rational numbers *)

type rational
declare ocaml    target_rep type rational = `Num.num` 


(* ----------------------- *)
(* double                  *)
(* ----------------------- *)

(* double precision floating point (64 bits) *)

type float64
declare ocaml    target_rep type float64 = `double` 

type float32
declare ocaml    target_rep type float32 = `float` 


(* ========================================================================== *)
(* Translation between number types                                           *)
(* ========================================================================== *)

val naturalFromNat : nat -> natural
declare hol      target_rep function naturalFromNat = `` (* remove natFromNumeral, as it is the identify function *)
declare ocaml    target_rep function naturalFromNat = `Big_int.big_int_of_int`
declare isabelle target_rep function naturalFromNat = ``
declare coq      target_rep function naturalFromNat = `TODO`

val natFromNatural : natural -> nat
declare hol      target_rep function natFromNatural = `` (* remove natFromNumeral, as it is the identify function *)
declare ocaml    target_rep function natFromNatural = `Big_int.int_of_big_int`
declare isabelle target_rep function natFromNatural = ``
declare coq      target_rep function natFromNatural = `TODO`



(* ========================================================================== *)
(* Binding the standard operations for the number types                       *)
(* ========================================================================== *)


(* ----------------------- *)
(* nat                     *)
(* ----------------------- *)

val natFromNumeral : numeral -> nat
declare hol      target_rep function natFromNumeral = `` (* remove natFromNumeral, as it is the identify function *)
declare ocaml    target_rep function natFromNumeral = ``
declare isabelle target_rep function natFromNumeral = ``
declare coq      target_rep function natFromNumeral = `TODO`

instance (Numeral nat)
  let fromNumeral = natFromNumeral
end

val natCompare : nat -> nat -> ordering
let inline natCompare = defaultCompare
instance (OrdCompare nat)
  let compare = natCompare
end

val natEq : nat -> nat -> bool
let inline natEq = unsafe_structural_equality
declare isabelle target_rep function natEq = infix `=`
declare ocaml    target_rep function natEq = infix `=`
declare hol      target_rep function natEq = infix `=`
instance (Eq nat)
  let (=) = natEq
end

val natLess : nat -> nat -> bool
val natLessEqual : nat -> nat -> bool
val natGreater : nat -> nat -> bool
val natGreaterEqual : nat -> nat -> bool

declare hol      target_rep function natLess = infix `<` 
declare ocaml    target_rep function natLess = infix `<`
declare isabelle target_rep function natLess = infix `<`
declare coq      target_rep function natLess = infix `<`

declare hol      target_rep function natLessEqual = infix `<=` 
declare ocaml    target_rep function natLessEqual = infix `<=`
declare isabelle target_rep function natLessEqual = infix `<=`
declare coq      target_rep function natLessEqual = infix `<=`

declare hol      target_rep function natGreater = infix `>` 
declare ocaml    target_rep function natGreater = infix `>`
declare isabelle target_rep function natGreater = infix `>`
declare coq      target_rep function natGreater = infix `>`

declare hol      target_rep function natGreaterEqual = infix `>=` 
declare ocaml    target_rep function natGreaterEqual = infix `>=`
declare isabelle target_rep function natGreaterEqual = infix `>=`
declare coq      target_rep function natGreaterEqual = infix `>=`

instance (Ord nat)
  let (<) = natLess
  let (<=) = natLessEqual
  let (>) = natGreater
  let (>=) = natGreaterEqual
end


val natAdd : nat -> nat -> nat
declare hol      target_rep function natAdd = infix `+`
declare ocaml    target_rep function natAdd = infix `+`
declare isabelle target_rep function natAdd = infix `+`
declare coq      target_rep function natAdd = infix `+`

instance (NumAdd nat)
  let (+) = natAdd
end

val natMinus : nat -> nat -> nat
declare hol      target_rep function natMinus = infix `-`
declare ocaml    target_rep function natMinus = `Nat_num.nat_monus`
declare isabelle target_rep function natMinus = infix `-`
declare coq      target_rep function natMinus = infix `-`

instance (NumMinus nat)
  let (-) = natMinus
end

val natSucc : nat -> nat
let natSucc n = n + 1
declare hol      target_rep function natSucc = `SUC`
declare isabelle target_rep function natSucc = `Suc`
declare ocaml    target_rep function natSucc = `succ`
instance (NumSucc nat)
  let succ = natSucc
end

val natPred : nat -> nat
let inline natPred n = n - 1
declare hol      target_rep function natPred = `PRE`
declare ocaml    target_rep function natPred = `Nat_num.nat_pred`
instance (NumPred nat)
  let pred = natPred
end

val natMult : nat -> nat -> nat
declare hol      target_rep function natMult = infix `*`
declare ocaml    target_rep function natMult = infix `*`
declare isabelle target_rep function natMult = infix `*`
declare coq      target_rep function natMult = infix `*`

instance (NumMult nat)
  let ( * ) = natMult
end


val natPow : nat -> nat -> nat
declare hol      target_rep function natPow = infix `**`
declare ocaml    target_rep function natPow = `Nat_num.nat_pow`
declare isabelle target_rep function natPow = `nat_exp`
declare coq      target_rep function natPow = `TODO`

instance ( NumPow nat ) 
  let ( ** ) = natPow
end

val natDiv : nat -> nat -> nat
declare hol      target_rep function natDiv = infix `DIV`
declare ocaml    target_rep function natDiv = infix `/`
declare isabelle target_rep function natDiv = infix `div`
declare coq      target_rep function natDiv = `TODO`

instance ( NumIntegerDivision nat ) 
  let (div) = natDiv
end

instance ( NumDivision nat ) 
  let (/) = natDiv
end

val natMod : nat -> nat -> nat
declare hol      target_rep function natMod = infix `MOD`
declare ocaml    target_rep function natMod = infix `mod`
declare isabelle target_rep function natMod = `nat_mod`
declare coq      target_rep function natMod = `TODO`

instance ( NumRemainder nat ) 
  let (mod) = natMod
end

val natMin : nat -> nat -> nat
let inline natMin = defaultMin
declare ocaml    target_rep function natMin = `min`
declare hol      target_rep function natMin = `MIN`

val natMax : nat -> nat -> nat
let inline natMax = defaultMax
declare ocaml    target_rep function natMax = `max`
declare hol      target_rep function natMax = `MAX`

instance ( OrdMaxMin nat ) 
  let max = natMax
  let min = natMin
end


(* ----------------------- *)
(* natural                 *)
(* ----------------------- *)

val naturalFromNumeral : numeral -> natural
declare hol      target_rep function naturalFromNumeral = `` (* remove naturalFromNumeral, as it is the identify function *)
declare ocaml    target_rep function naturalFromNumeral = `Big_int.big_int_of_int`
declare isabelle target_rep function naturalFromNumeral = ``
declare coq      target_rep function naturalFromNumeral = `TODO`

instance (Numeral natural)
  let fromNumeral = naturalFromNumeral
end

val naturalCompare : natural -> natural -> ordering
let inline naturalCompare = defaultCompare
declare ocaml    target_rep function naturalCompare = `Big_int.compare_big_int`
instance (OrdCompare natural)
  let compare = naturalCompare
end

val naturalEq : natural -> natural -> bool
let inline naturalEq = unsafe_structural_equality
declare ocaml    target_rep function naturalEq = `Big_int.eq_big_int`
declare hol      target_rep function naturalEq = infix `=`
declare isabelle target_rep function naturalEq = infix `=`
instance (Eq natural)
  let (=) = naturalEq
end

val naturalLess : natural -> natural -> bool
val naturalLessEqual : natural -> natural -> bool
val naturalGreater : natural -> natural -> bool
val naturalGreaterEqual : natural -> natural -> bool

declare hol      target_rep function naturalLess = infix `<` 
declare ocaml    target_rep function naturalLess = `Big_int.lt_big_int`
declare isabelle target_rep function naturalLess = infix `<`
declare coq      target_rep function naturalLess = infix `<`

declare hol      target_rep function naturalLessEqual = infix `<=` 
declare ocaml    target_rep function naturalLessEqual = `Big_int.le_big_int`
declare isabelle target_rep function naturalLessEqual = infix `<=`
declare coq      target_rep function naturalLessEqual = infix `<=`

declare hol      target_rep function naturalGreater = infix `>` 
declare ocaml    target_rep function naturalGreater = `Big_int.gt_big_int`
declare isabelle target_rep function naturalGreater = infix `>`
declare coq      target_rep function naturalGreater = infix `>`

declare hol      target_rep function naturalGreaterEqual = infix `>=` 
declare ocaml    target_rep function naturalGreaterEqual = `Big_int.ge_big_int`
declare isabelle target_rep function naturalGreaterEqual = infix `>=`
declare coq      target_rep function naturalGreaterEqual = infix `>=`

instance (Ord natural)
  let (<) = naturalLess
  let (<=) = naturalLessEqual
  let (>) = naturalGreater
  let (>=) = naturalGreaterEqual
end


val naturalAdd : natural -> natural -> natural
declare hol      target_rep function naturalAdd = infix `+`
declare ocaml    target_rep function naturalAdd = `Big_int.add_big_int`
declare isabelle target_rep function naturalAdd = infix `+`
declare coq      target_rep function naturalAdd = infix `+`

instance (NumAdd natural)
  let (+) = naturalAdd
end

val naturalMinus : natural -> natural -> natural
declare hol      target_rep function naturalMinus = infix `-`
declare ocaml    target_rep function naturalMinus = `Nat_num.natural_monus`
declare isabelle target_rep function naturalMinus = infix `-`
declare coq      target_rep function naturalMinus = infix `-`

instance (NumMinus natural)
  let (-) = naturalMinus
end

val naturalSucc : natural -> natural
let naturalSucc n = n + 1
declare hol      target_rep function naturalSucc = `SUC`
declare isabelle target_rep function naturalSucc = `Suc`
declare ocaml    target_rep function naturalSucc = `Big_int.succ_big_int`
instance (NumSucc natural)
  let succ = naturalSucc
end

val naturalPred : natural -> natural
let inline naturalPred n = n - 1
declare hol      target_rep function naturalPred = `PRE`
declare ocaml    target_rep function naturalPred = `Nat_num.natural_pred`
instance (NumPred natural)
  let pred = naturalPred
end

val naturalMult : natural -> natural -> natural
declare hol      target_rep function naturalMult = infix `*`
declare ocaml    target_rep function naturalMult = `Big_int.mult_big_int`
declare isabelle target_rep function naturalMult = infix `*`
declare coq      target_rep function naturalMult = infix `*`

instance (NumMult natural)
  let ( * ) = naturalMult
end


val naturalPow : natural -> natural -> natural
declare hol      target_rep function naturalPow = infix `**`
declare ocaml    target_rep function naturalPow = `Big_int.power_big_int_positive_big_int`
declare isabelle target_rep function naturalPow = `natural_exp`
declare coq      target_rep function naturalPow = `TODO`

instance ( NumPow natural ) 
  let ( ** ) = naturalPow
end

val naturalDiv : natural -> natural -> natural
declare hol      target_rep function naturalDiv = infix `DIV`
declare ocaml    target_rep function naturalDiv = `Big_int.div_big_int`
declare isabelle target_rep function naturalDiv = infix `div`
declare coq      target_rep function naturalDiv = `TODO`

instance ( NumIntegerDivision natural ) 
  let (div) = naturalDiv
end

instance ( NumDivision natural ) 
  let (/) = naturalDiv
end

val naturalMod : natural -> natural -> natural
declare hol      target_rep function naturalMod = infix `MOD`
declare ocaml    target_rep function naturalMod = `Big_int.mod_big_int`
declare isabelle target_rep function naturalMod = `natural_mod`
declare coq      target_rep function naturalMod = `TODO`

instance ( NumRemainder natural ) 
  let (mod) = naturalMod
end

val naturalMin : natural -> natural -> natural
let inline naturalMin = defaultMin
declare ocaml    target_rep function naturalMin = `Big_int.min_big_int`
declare hol      target_rep function naturalMin = `MIN`

val naturalMax : natural -> natural -> natural
let inline naturalMax = defaultMax
declare ocaml    target_rep function naturalMax = `Big_int.max_big_int`
declare hol      target_rep function naturalMax = `MAX`

instance ( OrdMaxMin natural ) 
  let max = naturalMax
  let min = naturalMin
end










