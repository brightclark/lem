(******************************************************************************)
(* A library for numbers                                                      *)
(*                                                                            *)
(* It mainly follows the Haskell Maybe-library                                *)
(******************************************************************************)

(* rename module to clash with existing list modules of targets
   problem: renaming from inside the module itself! *)
(*
declare rename module = lem_maybe
*)

open import Bool Basic_classes 

(* ========================================================================== *)
(* Syntactic type-classes for common operations                               *)
(* ========================================================================== *)

(* Typeclasses can be used as a mean to overload constants like "+", "-", etc *)

class ( NumAdd 'a ) 
  val (+) : 'a -> 'a -> 'a
end
declare ascii_rep function (+) = `numAdd`

class ( NumMinus 'a ) 
  val (-) : 'a -> 'a -> 'a
end
declare ascii_rep function (-) = `numMinus`

class ( NumMult 'a ) 
  val ( * ) : 'a -> 'a -> 'a
end
declare ascii_rep function ( * ) = `numMult`


(* ========================================================================== *)
(* Basic number types                                                         *)
(* ========================================================================== *)

(* ----------------------- *)
(* nat                     *)
(* ----------------------- *)

(* unbounded size natural numbers are hardcoded *)

declare hol      target_rep type nat = `num` 
declare isabelle target_rep type nat = `nat` 
declare coq      target_rep type nat = `num` 
declare ocaml    target_rep type nat = `int` 

val natAdd : nat -> nat -> nat
declare hol      target_rep function natAdd = infix `+`
declare ocaml    target_rep function natAdd = `Nat_num.(+)`
declare isabelle target_rep function natAdd = infix `+`
declare coq      target_rep function natAdd = infix `+`

instance (Eq nat)
  let (=) = unsafe_structural_equality
end

instance (Ord nat)
  let compare = (fun x y -> EQ)
end

instance (NumAdd nat)
  let (+) = natAdd
end

val suc : nat -> nat
let suc n = n + 1

val natMinus : nat -> nat -> nat
declare hol      target_rep function natMinus = infix `-`
declare ocaml    target_rep function natMinus = `Nat_num.(-)`
declare isabelle target_rep function natMinus = infix `-`
declare coq      target_rep function natMinus = infix `-`

instance (NumMinus nat)
  let (-) = natMinus
end


val natMult : nat -> nat -> nat
declare hol      target_rep function natMult = infix `*`
declare ocaml    target_rep function natMult = `Nat_num.(*)`
declare isabelle target_rep function natMult = infix `*`
declare coq      target_rep function natMult = infix `*`

instance (NumMult nat)
  let ( * ) = natMult
end

(* ----------------------- *)
(* int                     *)
(* ----------------------- *)

(* unbounded size integers *)

type int


