(******************************************************************************)
(* Transformation library                                                     *)
(*                                                                            *)
(* This library is used to transfrom old lem. To use it do the following:     *)
(* - add "open import Transform" at the head of your file                     *)
(* - run "lem -lem filename.lem" on your file                                 *)
(* - manually check resulting "filename-processed.lem" and ajust              *)
(******************************************************************************)


include import Pervasives_extra

(* get rid of transform at beginning *)
declare rename module = Pervasives_extra


(* ========================================================================== *)
(* Pervasives                                                                 *)
(* ========================================================================== *)

type num = nat
declare lem target_rep type num = `nat`

let inline (@) = (++) (* List append *)
let inline (<>) = (/=)

(* transitive closure now works on relations, not sets of pairs,
   best ajust the types manually or add wrappers 'relFromSet' and 
   'relToSet' as appropriate. *)
val tc : forall 'a. set ('a * 'a) -> set ('a * 'a)
declare lem target_rep function tc = `Relation.transitiveClosure`



type option 'a = maybe 'a
declare lem target_rep type option = `maybe` 

let inline None = Nothing
let inline Some = Just

declare pattern_match exhaustive maybe 'a = [ None; Some ; ]  

let inline SUC = natSucc

(* ----------------------- *)
(* fully supported         *)
(* ----------------------- *)

(*  
val not : bool -> bool
val (&&) : bool -> bool -> bool
val (||) : bool -> bool -> bool
val (-->) : bool -> bool -> bool

val fst : forall 'a 'b. 'a * 'b -> 'a
val snd : forall 'a 'b. 'a * 'b -> 'b
val (::) : forall 'a. 'a -> list 'a -> list 'a
*)


(* ----------------------- *)
(* with class constraints  *)
(* ----------------------- *)

(* 
val (=) : forall 'a. 'a -> 'a -> bool
val (<) : num -> num -> bool
val (>) : num -> num -> bool
val (<=) : num -> num -> bool
val (>=) : num -> num -> bool

val (IN) : forall 'a. 'a -> set 'a -> bool
val (union) : forall 'a. set 'a -> set 'a -> set 'a

val (+) : num -> num -> num
val (-) : num -> num -> num
val ( * ) : num -> num -> num
val ( ** ) : num -> num -> num
val (/) : num -> num -> num
val (mod) : num -> num -> num
*)

(* ----------------------- *)
(* TODO: still missing     *)
(* ----------------------- *)
(**)
val (land) : num -> num -> num
val (lor) : num -> num -> num
val (lxor) : num -> num -> num
val lnot : num -> num
val (lsl) : num -> num -> num
val (lsr) : num -> num -> num
val (asr) : num -> num -> num
(*
val bigunion = forall 'a. set (set 'a) -> set 'a
val biginter : forall 'a. set (set 'a) -> set 'a

val (^) : string -> string -> string
let inline {hol} (^) x y = Hol.STRCAT x y
let inline {ocaml} (^) = Ocaml.(^)


type sum 'a 'b = 
  | Inl of 'a
  | Inr of 'b

val isl : forall 'a 'b. sum 'a 'b -> bool
let inline {hol;ocaml;coq;isabelle} isl s = match s with Inl _ -> true | Inr _ -> false end

val isr : forall 'a 'b. sum 'a 'b -> bool
let inline {hol;ocaml;coq;isabelle} isr s = match s with Inl _ -> false | Inr _ -> true end

val outl : forall 'a 'b. sum 'a 'b -> 'a
let inline {hol;ocaml;coq;isabelle} outl s = match s with Inl a -> a end

val outr : forall 'a 'b. sum 'a 'b -> 'b
let inline {hol;ocaml;coq;isabelle} outr s = match s with Inr b -> b end
  
val string_of_num : num -> string
let inline {ocaml} string_of_num = Ocaml.Nat_num.string_of_num
let inline {isabelle} string_of_num = Isabelle.nat_to_string

val nat_list_to_string : list num -> string
let inline {isabelle} nat_list_to_string = Isabelle.nat_list_to_string
*)


(* ========================================================================== *)
(* Set                                                                        *)
(* ========================================================================== *)

module Set = struct
  include Set_extra   (* include the new set module *)

  let inline add = insert
  let inline for_all = all
  let inline exist = any
  let inline cardinal = size
  let inline from_list = fromList
  let inline is_empty = null
  let inline image = map
  let inline set_sigma = sigma
  let inline equal = setEqual
  let inline finite = Set.finite
  let inline fold = Set_helpers.fold


  (* ----------------------- *)
  (* with class constraints  *)
  (* ----------------------- *)
  (*
  val singleton : forall 'a. 'a -> set 'a
  val finite : forall 'a. set 'a -> bool
  val filter : forall 'a. ('a -> bool) -> set 'a -> set 'a
  val cross : forall 'a 'b. set 'a -> set 'b -> set ('a * 'b)
  val (=) : forall 'a. set 'a -> set 'a -> bool
  val map : forall 'a 'b. ('a -> 'b) -> set 'a -> set 'b
  *)
  (* This old-lem signature for choose is incompatible with List_extra.choose. *)
  val choose : forall 'a. set 'a -> 'a -> 'a
  (*
  val fold : forall 'a 'b. ('a -> 'b -> 'b) -> set 'a -> 'b -> 'b
  *)

  (* ----------------------- *)
  (* TODO: still missing     *)
  (* ----------------------- *)
  (*
  TODO: unsupported so far:
  *)
  val to_list : forall 'a. set 'a -> list 'a
  (*
  val monotone : forall 'a. (set 'a -> set 'a) -> bool
  val lfp : forall 'a. set 'a -> (set 'a -> set 'a) -> set 'a
  *)
end

module Pmap = struct
  include Map (* include the new map module *)

  let inline add = insert
  let inline mem = member

  (* 
  find is a suspicious function.
  *)
  val find : forall 'k 'v. Ord 'k => 'k -> map 'k 'v -> 'v
  let inline find k m = 
      match Map.find k m with
      | Just x -> x
      end

  (* All elements satisfy predicate p iff filtering all elements _not_
     satisfying p yields the empty map, similarly for exists. *)
  let inline for_all p m = null (filterWithKey (fun k v -> not (p k v)) m)
  let inline exist p m = not (null (filterWithKey p m))

  let inline remove = delete
  let inline bindings = toAscList

  let inline domain m = Set.fromList (List.map fst (toAscList m))
  let inline range  m = Set.fromList (List.map snd (toAscList m))
end


(* ========================================================================== *)
(* List                                                                       *)
(* ========================================================================== *)

module List = struct
  include List_extra (* include the new set module *)

  let inline hd = head
  let inline tl = tail
  let inline rev = reverse
  let inline rev_append = reverseAppend
  let inline flatten = concat
  let inline rev_map = reverseMap
  let inline fold_left = foldl
  let inline fold_right f l e = foldr f e l
  let inline for_all = List.all
  let inline exist = List.any
  let inline mem = elem
  let inline find = find_non_pure
  let inline find_all = filter
  let inline assoc = lookup
  let inline split = unzip
  let inline combine = zip

  let inline sort = Sorting.sort
  let inline stable_sort = Sorting.sort
  let inline fast_sort = Sorting.sort

  (* ----------------------- *)
  (* supported               *)
  (* ----------------------- *)

  let inline length = List.length
  let inline nth = List_extra.nth
  let inline append = List.append

  (*
  val length : forall 'a. list 'a -> num
  val nth : forall 'a. list 'a -> num -> 'a
  val append : forall 'a. list 'a -> list 'a -> list 'a
  val concat : forall 'a. list (list 'a) -> list 'a
  val map : forall 'a 'b. ('a -> 'b) -> list 'a -> list 'b
  val filter : forall 'a. ('a -> bool) -> list 'a -> list 'a
  val partition : forall 'a. ('a -> bool) -> list 'a -> list 'a * list 'a
  *)

  (* ----------------------- *)
  (* TODO: still missing     *)
  (* ----------------------- *)
  (*
  val map2 : forall 'a 'b 'c. ('a -> 'b -> 'c) -> list 'a -> list 'b -> list 'c 
  val rev_map2 : forall 'a 'b 'c. ('a -> 'b -> 'c) -> list 'a -> list 'b -> list 'c
  val fold_left2 : forall 'a 'b 'c. ('a -> 'b -> 'c -> 'a) -> 'a -> list 'b -> list 'c -> 'a
  val fold_right2 : forall 'a 'b 'c. ('a -> 'b -> 'c -> 'c) -> list 'a -> list 'b -> 'c -> 'c
  val for_all2 : forall 'a 'b. ('a -> 'b -> bool) -> list 'a -> list 'b -> bool
  val exists2 : forall 'a 'b. ('a -> 'b -> bool) -> list 'a -> list 'b -> bool
  val mem_assoc : forall 'a 'b. 'a -> list ('a * 'b) -> bool
  val remove_assoc : forall 'a 'b. 'a -> list ('a * 'b) -> list ('a * 'b)
  val merge : forall 'a. ('a -> 'a -> num) -> list 'a -> list 'a -> list 'a
  val intersect : forall 'a. list 'a -> list 'a -> list 'a
  *)

end
