(******************************************************************************)
(* A library for option                                                       *)
(*                                                                            *)
(* It mainly follows the Haskell Maybe-library                                *)
(******************************************************************************)

declare rename module = lem_maybe

open import Bool Basic_classes 

(* ========================================================================== *)
(* Basic stuff                                                                *)
(* ========================================================================== *)

type maybe 'a = 
  | Nothing
  | Just of 'a

declare hol      target_rep type maybe 'a = `option` 'a 
declare isabelle target_rep type maybe 'a = `option` 'a
declare coq      target_rep type maybe 'a = `option` 'a
declare ocaml    target_rep type maybe 'a = `option` 'a

declare hol      target_rep function Just = `SOME`
declare ocaml    target_rep function Just = `Some`
declare isabelle target_rep function Just = `Some`
declare coq      target_rep function Just = `Some`

declare hol      target_rep function Nothing = `NONE`
declare ocaml    target_rep function Nothing = `None`
declare isabelle target_rep function Nothing = `None`
declare coq      target_rep function Nothing = `None`


val maybeEq : forall 'a. Eq 'a => maybe 'a -> maybe 'a -> bool

let maybeEq x y = match (x,y) with
  | (Nothing, Nothing) -> true
  | (Nothing, Just _) -> false
  | (Just _, Nothing) -> false
  | (Just x', Just y') -> (x' = y')
end

let inline {hol;isabelle;coq} maybeEq = unsafe_structural_equality

instance forall 'a. Eq 'a => (Eq (maybe 'a))
  let (=) = maybeEq
end


(* ----------------------- *)
(* maybe                   *)
(* ----------------------- *)

val maybe : forall 'a 'b. 'b -> ('a -> 'b) -> maybe 'a -> 'b
let maybe d f mb = match mb with 
  | Just a -> f a
  | Nothing -> d
end

declare ocaml    target_rep function maybe d f mb = `Option.map_default` f d mb

(* ----------------------- *)
(* isJust / isNothing      *)
(* ----------------------- *)

val isJust : forall 'a. maybe 'a -> bool
let isJust mb = match mb with 
  | Just _ -> true
  | Nothing -> false
end

declare hol      target_rep function isJust = `IS_SOME`
declare ocaml    target_rep function isJust x = `is_some`
declare isabelle target_rep function isJust x = not (unsafe_structural_equality x Nothing)

val isNothing : forall 'a. maybe 'a -> bool
let isNothing mb = match mb with 
  | Just _ -> false
  | Nothing -> true
end

declare hol      target_rep function isNothing = `IS_NONE`
declare ocaml    target_rep function isNothing = `is_none`
declare isabelle target_rep function isNothing x = (unsafe_structural_equality x Nothing)

lemma isJustNothing: (
  (forall x. isNothing x = not (isJust x)) &&
  (forall v. isJust (Just v)) &&
  (isNothing Nothing))


(* ----------------------- *)
(* fromMaybe               *)
(* ----------------------- *)

val fromMaybe : forall 'a. 'a -> maybe 'a -> 'a
let fromMaybe d mb = match mb with
   | Just v  -> v
   | Nothing -> d
end

declare ocaml    target_rep function fromMaybe = `Option.default`

lemma fromMaybe: (
  (forall d v. fromMaybe d (Just v) = v) &&
  (forall d. fromMaybe d Nothing = d))


(* ----------------------- *)
(* map                     *)
(* ----------------------- *)

val map : forall 'a 'b. ('a -> 'b) -> maybe 'a -> maybe 'b 
let map f = maybe Nothing (fun v -> Just (f v))

declare hol      target_rep function map = `OPTION_MAP`
declare ocaml    target_rep function map = `Option.map`
declare isabelle target_rep function map = `Option.map`

lemma maybe_map: (
  (forall f. map f Nothing = Nothing) &&
  (forall f v. map f (Just v) = Just (f v)))

