(******************************************************************************)
(* A library for option                                                       *)
(*                                                                            *)
(* It mainly follows the Haskell Maybe-library                                *)
(******************************************************************************)

(* rename module to clash with existing list modules of targets
   problem: renaming from inside the module itself! *)
(*
declare rename module = lem_maybe
*)

(* ========================================================================== *)
(* Basic stuff                                                                *)
(* ========================================================================== *)

type maybe 'a = 
  | Nothing
  | Just of 'a

declare hol      target_rep type maybe 'a = `option` 'a 
declare isabelle target_rep type maybe 'a = `option` 'a
declare coq      target_rep type maybe 'a = `option` 'a
declare ocaml    target_rep type maybe 'a = `option` 'a



declare hol      target_rep function Just = `SOME`
declare ocaml    target_rep function Just = `Some`
declare isabelle target_rep function Just = `Some`
declare coq      target_rep function Just = `Some`

declare hol      target_rep function Nothing = `NONE`
declare ocaml    target_rep function Nothing = `None`
declare isabelle target_rep function Nothing = `None`
declare coq      target_rep function Nothing = `None`

(* ----------------------- *)
(* maybe                   *)
(* ----------------------- *)

val maybe : forall 'a 'b. 'b -> ('a -> 'b) -> maybe 'a -> 'b
let maybe d f mb = match mb with 
  | Just a -> f a
  | Nothing -> d
end

declare ocaml    target_rep function maybe d f mb = `Option.map_default` f d mb

(* ----------------------- *)
(* isJust / isNothing      *)
(* ----------------------- *)

val isJust : forall 'a. maybe 'a -> bool
let isJust mb = match mb with 
  | Just _ -> true
  | Nothing -> false
end

declare hol      target_rep function isJust = `IS_SOME`
declare ocaml    target_rep function isJust x = `is_some`
declare isabelle target_rep function isJust x = not (x = Nothing)


val isNothing : forall 'a. maybe 'a -> bool
let isNothing mb = match mb with 
  | Just _ -> false
  | Nothing -> true
end

declare hol      target_rep function isNothing = `IS_NONE`
declare ocaml    target_rep function isNothing = `is_none`
declare isabelle target_rep function isNothing x = (x = Nothing)

lemma isJustNothing: (
  (forall x. isNothing x = not (isJust x)) &&
  (forall v. isJust (Just v)) &&
  (isNothing Nothing))

(* ----------------------- *)
(* fromJust                *)
(* ----------------------- *)

val fromJust : forall 'a. maybe 'a -> 'a
let fromJust (Just v) = v
declare termination_argument length = automatic
declare compile_message fromJust = "fromJust is only defined on Just. Better use `fromMaybe` or use explicit maching to handle the Nothing-case."

declare hol      target_rep function fromJust = `THE`
declare ocaml    target_rep function fromJust = `Option.get`
declare isabelle target_rep function fromJust = `the`

lemma fromJust: (forall v. fromJust (Just v) = v)


(* ----------------------- *)
(* fromMaybe               *)
(* ----------------------- *)

val fromMaybe : forall 'a. 'a -> maybe 'a -> 'a
let fromMaybe d mb = match mb with
   | Just v  -> v
   | Nothing -> d
end

declare ocaml    target_rep function fromMaybe = `Option.default`

lemma fromMaybe: (
  (forall d v. fromMaybe d (Just v) = v) &&
  (forall d. fromMaybe d Nothing = d))


(* ----------------------- *)
(* map                     *)
(* ----------------------- *)

val map : forall 'a 'b. ('a -> 'b) -> maybe 'a -> maybe 'b 
let map f = maybe Nothing (fun v -> Just (f v))

declare hol      target_rep function map = `OPTION_MAP`
declare ocaml    target_rep function map = `Option.map`
declare isabelle target_rep function map = `Option.map`

lemma maybe_map: (
  (forall f. map f Nothing = Nothing) &&
  (forall f v. map f (Just v) = Just (f v)))

