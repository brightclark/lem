(******************************************************************************)
(* A library for binary relations                                             *)
(******************************************************************************)



(* ========================================================================== *)
(* Header                                                                     *)
(* ========================================================================== *)


(* rename module to clash with existing list modules of targets
   problem: renaming from inside the module itself! *)
declare rename module = lem_relation


(* ========================================================================== *)
(* The type of relations                                                      *)
(* ========================================================================== *)

type rel_pred 'a 'b = 'a -> 'b -> bool
type rel_set 'a 'b = set ('a * 'b)

(* Binary relations are usually represented as either
   sets of pairs (rel_set) or as curried functions (rel_pred). 
   
   The choice depends on taste and the backend. Lem does not take a 
   decision, but supports both representations. There is an abstract type
   pred, which can be converted to both representations. The representation
   of pred itself then depends on the backend. *)

type rel 'a 'b

val relToSet : forall 'a. Ord 'a => Ord 'b => rel 'a 'b -> rel_set 'a 'b
val relFromSet : forall 'a. Ord 'a => Ord 'b => rel_set 'a 'b -> rel 'a 'b

lemma relToSet_inv: (forall r. relFromSet (relToSet r) = r)

val relToPred : forall 'a. Ord 'a => Ord 'b => rel 'a 'b -> rel_pred 'a 'b
val relFromPred : forall 'a. Ord 'a => Ord 'b => rel_pred 'a 'b -> rel 'a 'b

lemma relToPred_inv: (forall r. relFromPred (relToPred r) = r)


(* ========================================================================== *)
(* Basic Operations                                                           *)
(* ========================================================================== *)

(* ----------------------- *)
(* Identity relation       *)
(* ----------------------- *)

val inRel : forall 'a. Ord 'a => 'a -> 'a -> rel 'a -> bool

lemma inRel_set : (forall s a b. inRel a b (relFromSet s) = (a, b) IN s)
lemma inRel_pred : (forall p a b. inRel a b (relFromPred p) = p a b)


(* ----------------------- *)
(* empty relation          *)
(* ----------------------- *)

val relEmpty : forall 'a. Ord 'a => Ord 'b => rel 'a 'b
let relEmpty = relFromSet {}

(* ----------------------- *)
(* add relation            *)
(* ----------------------- *)

val relAdd : forall 'a. Ord 'a => Ord 'b => 'a -> 'b -> rel 'a 'b -> rel 'a 'b
let relAdd a b r = relFromSet (add (a,b) (relToSet r))


(* ----------------------- *)
(* Identity relation        *)
(* ----------------------- *)

val relIdOn : forall 'a. Ord 'a => set 'a => rel 'a 'a
let relIdOn s = relFromPred (fun e1 e2. (e1 IN s) && (e2 IN s) && (e1 = e2))

val relId : forall 'a. Ord 'a => rel 'a 'a
let relId = relFromPred (=)

lemma relId_spec: (forall x y. (rel_in x y relId <-> (x = y)))


(* ----------------------- *)
(* relation union          *)
(* ----------------------- *)

val relUnion : forall 'a. Ord 'a => Ord 'b => rel 'a 'b -> rel 'a 'b -> rel 'a 'b
let relUnion r1 r2 = relFromSet (fun e1 e2 -> ((rel_in e1 e2 r1) || (rel_in e1 e2 r2)))

(* ----------------------- *)
(* relation intersection   *)
(* ----------------------- *)

val relIntersection : forall 'a. Ord 'a => Ord 'b => rel 'a 'b -> rel 'a 'b -> rel 'a 'b
let relIntersection r1 r2 = relFromSet (fun e1 e2 -> ((rel_in e1 e2 r1) && (rel_in e1 e2 r2)))


(* ----------------------- *)
(* Relation Composition    *)
(* ----------------------- *)

val relComp : forall 'a. Ord 'a => Ord 'b => Ord 'c => rel 'a 'b -> rel 'b 'c -> rel 'b 'c
let relComp r1 r2 = relFromPred (fun e1 e3 -> exists e2. inRel e1 e2 r1 && inRel e2 e3 r2)

lemma rel_comp_1 : (forall r1 r2 e1 e2 e3. (rel_in e1 e2 r1 && rel_in e2 e3 r2) --> rel_in e1 e3 (relComp r1 r2))
lemma rel_comp_2 : (forall r. (relComp r relId = r) && (relComp relId r = r))
lemma rel_comp_3 : (forall r. (relComp r relEmpty = relEmpty) && (relComp relEmpty r = relEmpty))


(* ----------------------- *)
(* restrict                *)
(* ----------------------- *)

val relRestrict : forall 'a. Ord 'a => rel 'a 'a -> set 'a -> rel 'a 'a
let relRestrict r s = relFromSet ({ (a, b) | forall (a IN s) (b IN s) | inRel a b r })

(* ----------------------- *)
(* Converse                *)
(* ----------------------- *)

val converse : forall 'a. Ord 'a => Ord 'b => rel 'a 'b -> rel 'b 'a
let converse r = relFromPred (fun e1 e2 -> inRel e2 e1 r)

(* ----------------------- *)
(* domain                  *)
(* ----------------------- *)

val domain : forall 'a. Ord 'a => Ord 'b => rel 'a 'b -> set 'a
let domain r = { e1 | exists e2. inRel e1 e2 r }

(* ----------------------- *)
(* range                   *)
(* ----------------------- *)

val range : forall 'a. Ord 'a => Ord 'b => rel 'a 'b -> set 'b
let range r = { e2 | exists e2. inRel e1 e2 r }

(* ----------------------- *)
(* field                   *)
(* ----------------------- *)

val field : forall 'a. Ord 'a => rel 'a 'a -> set 'a
let field r = union (domain r) (range r)

(* ----------------------- *)
(* apply a relation        *)
(* ----------------------- *)

(* Given a relation r and a set s, relApply r s applies s to r, i.e.
   it returns the set of all value reachable via r form a value in s.
   This operation can be seen as a generalisation of function application. *)
   
val relApply : forall 'a. Ord 'a => Ord 'b => rel 'a 'b -> set 'a -> set 'b
let relApply r s = { y | exists (x IN s). inRel x y r }



(* ========================================================================== *)
(* Properties                                                                 *)
(* ========================================================================== *)

(* ----------------------- *)
(* subrel                  *)
(* ----------------------- *)

val isSubrel : forall 'a 'b. Ord 'a =>  Ord 'b => rel 'a 'b -> rel 'a 'b -> bool
let isSubrel r1 r2 = isSubset (relToSet r1) (relToSet r2)


(* ----------------------- *)
(* reflexivity             *)
(* ----------------------- *)

val isReflexivOn : forall 'a. Ord 'a => rel 'a -> set 'a -> bool
let isReflexivOn r s = (forall (e IN s). inRel e e r)

val isReflexiv : forall 'a. Ord 'a => rel 'a -> bool
let isReflexiv r = (forall e. inRel e e r)


(* ----------------------- *)
(* irreflexivity           *)
(* ----------------------- *)

val isIrreflexivOn : forall 'a. Ord 'a => rel 'a 'a -> set 'a -> bool
let isIrreflexivOn r s = (forall (e IN s). not (inRel e e r))

val isIrreflexiv : forall 'a. Ord 'a => rel 'a 'a -> bool
let isIrreflexiv r = (forall e. not (inRel e e r))


(* ----------------------- *)
(* symmetry                *)
(* ----------------------- *)

val isSymmetricOn : forall 'a. Ord 'a => rel 'a 'a -> set 'a -> bool
let isSymmetricOn r s = (forall (e1 IN s) (e2 IN s). (inRel e1 e2 r) --> (inRel e2 e1 r))

val is_symmetric : forall 'a. Ord 'a => rel 'a 'a -> bool
let is_symmetric r = (forall e1 e2. (inRel e1 e2 r) --> (inRel e2 e1 r))

(* ----------------------- *)
(* antisymmetry            *)
(* ----------------------- *)

val isAntisymmetricOn : forall 'a. Ord 'a => rel 'a 'a -> set 'a -> bool
let isAntisymmetricOn r s = (forall (e1 IN s) (e2 IN s). (inRel e1 e2 r) --> (inRel e2 e1 r) -> (e1 = e2))

val isAntisymmetric : forall 'a. Ord 'a => rel 'a 'a -> bool
let isAntisymmetric r = (forall e1 e2. (inRel e1 e2 r) --> (inRel e2 e1 r) -> (e1 = e2))


(* ----------------------- *)
(* transitivity            *)
(* ----------------------- *)

val isTransitiveOn : forall 'a. Ord 'a => rel 'a 'a -> set 'a -> bool
let isTransitiveOn r s = (forall (e1 IN s) (e2 IN s) (e3 IN s). (inRel e1 e2 r) --> (inRel e2 e3 r) -> (inRel e1 e3 r))

val isTransitive : forall 'a. Ord 'a => rel 'a -> bool
let isTransitive r = (forall e1 e2 e3. (inRel e1 e2 r) --> (inRel e2 e3 r) -> (inRel e1 e3 r))

(* ----------------------- *)
(* total                   *)
(* ----------------------- *)

val isTotalOn : forall 'a. Ord 'a => rel 'a 'a -> set 'a -> bool
let isTotalOn r s = (forall (e1 IN s) (e2 IN s). (inRel e1 e2 r) || (inRel e2 e1 r))

val isTotal : forall 'a. Ord 'a => rel 'a 'a -> bool
let isTotal r = (forall e1 e2. (inRel e1 e2 r) || (inRel e2 e1 r))

val isTrichotomousOn : forall 'a. Ord 'a => rel 'a 'a -> set 'a -> bool
let isTrichotomousOn r s = (forall (e1 IN s) (e2 IN s). (inRel e1 e2 r) || (e1 = e2) || (inRel e2 e1 r))

val isTrichotomous : forall 'a. Ord 'a => rel 'a 'a -> bool
let isTrichotomous r = (forall e1 e2. (inRel e1 e2 r) || (e1 = e2) || (inRel e2 e1 r))


declare targetrep isabelle isTrichotomousOn = 'total_on'
declare targetrep isabelle isTrichotomous   = 'total'
declare targetrep hol      isTrichotomous   = 'trichotomous'
declare targetrep hol      isTotal          = 'total'


(* ----------------------- *)
(* is_single_valued        *)
(* ----------------------- *)

val isSingleValued : forall 'a 'b. Ord 'a => Ord 'b => rel 'a 'b -> bool
let isSingleValued r = (forall e1 e2a e2b. ((inRel e1 e2a r) && (inRel e1 e2b r)) --> (e2a = e2b))


(* ----------------------- *)
(* equivalence relation    *)
(* ----------------------- *)

val isEquivalenceOn : forall 'a. Ord 'a => rel 'a 'a -> set 'a -> bool
let isEquivalenceOn r s = isReflexiveOn r s && isSymmetricOn r s && isTransitiveOn r s

val isEquivalence : forall 'a. Ord 'a => rel 'a 'a -> bool
let isEquivalence r = isReflexive r && isSymmetric r && isTransitive r


(* ----------------------- *)
(* well founded            *)
(* ----------------------- *)

val isWellFounded : forall 'a. Ord 'a => rel 'a 'a -> bool
let isWellFounded r = (forall P. (forall x. (forall y. inRel y x R --> P x) --> P x) --> (forall x. P x))

declare targetrep isabelle isWellFounded = 'wf'
declare targetrep hol      isWellFounded = 'WF'


(* ========================================================================== *)
(* Orders                                                                     *)
(* ========================================================================== *)


(* ----------------------- *)
(* pre- or quasiorders     *)
(* ----------------------- *)

val isPreorderOn : forall 'a. Ord 'a => rel 'a 'a -> set 'a -> bool
let isPreorderOn r s = isReflexivOn r s && isTransitiveOn r s

val isPreorder : forall 'a. Ord 'a => rel 'a 'a -> bool
let isPreorder r = isReflexiv r && isTransitive r

declare targetrep isabelle isTrichotomousOn = 'total_on'
declare targetrep isabelle isTrichotomous   = 'total'
declare targetrep hol      isTrichotomous   = 'trichotomous'
declare targetrep hol      isTotal          = 'total'


(* ----------------------- *)
(* partial orders          *)
(* ----------------------- *)

val isPartialOrderOn : forall 'a. Ord 'a => rel 'a 'a -> set 'a -> bool
let isPartialOrderOn r s = isReflexivOn r s && isTransitiveOn r s && isAntisymmetricOn r s

val isPartialOrder : forall 'a. Ord 'a => rel 'a 'a -> bool
let isPartialOrder r = isReflexiv r && isTransitive r && isAntisymmetric r

val isStrictPartialOrderOn : forall 'a. Ord 'a => rel 'a 'a -> set 'a -> bool
let isStrictPartialOrderOn r s = isIrreflexivOn r s && isTransitiveOn r s && isAntisymmetricOn r s

val isStrictPartialOrder : forall 'a. Ord 'a => rel 'a 'a -> bool
let isStrictPartialOrder r = isIrreflexiv r && isTransitive r && isAntisymmetric r


(* ----------------------- *)
(* total / linear orders   *)
(* ----------------------- *)

val isTotalOrderOn : forall 'a. Ord 'a => rel 'a 'a -> set 'a -> bool
let isTotalOrderOn r s = isPartialOrderOn r s && isTotalOn r s

val isTotalOrder : forall 'a. Ord 'a => rel 'a 'a -> bool
let isTotalOrder r = isPartialOrder r && isTotal r s

val isStrictTotalOrderOn : forall 'a. Ord 'a => rel 'a 'a -> set 'a -> bool
let isStrictTotalOrderOn r s = isStrictPartialOrderOn r s && isTrichotomousOn r s

val isStrictTotalOrder : forall 'a. Ord 'a => rel 'a 'a -> bool
let isStrictTotalOrder r = isStrictPartialOrder r && isTrichotomousOn r s



(* ========================================================================== *)
(* closures                                                                   *)
(* ========================================================================== *)

(* ----------------------- *)
(* transitive closure      *)
(* ----------------------- *)

let transitive_closure : forall 'a. Ord 'a => rel 'a 'a -> rel 'a 'a
let transitive_closureByEq  : forall 'a. ('a -> 'a -> bool) -> rel 'a 'a -> rel 'a 'a
let transitive_closureByCmp : forall 'a. ('a -> 'a -> ordering) -> rel 'a 'a -> rel 'a 'a

let inline {coq} transitive_closure = transitive_closureByEq (=)
let inline {ocaml} transitive_closure = transitive_closureByCmp compare

declare targetrep ocaml    transitive_closureByCmp = 'Pset.tc'
declare targetrep hol      transitive_closure = 'tc'
declare targetrep isabelle transitive_closure = 'trancl'
declare targetrep coq      transitive_closureByEq = 'set_tc'

lemma transitive_closure_spec1: (forall r. isSubrel r (transitive_closure r))
lemma transitive_closure_spec2: (forall r. isTransitive (transitive_closure r))
lemma transitive_closure_spec3: (forall r1 r2. ((isTransitive r2) && (isSubrel r1 r2)) --> isSubrel (transitive_closure r1) r2)


(* ========================================================================== *)
(* reflexiv closures                                                          *)
(* ========================================================================== *)

let reflexiv_transitive_closureOn : forall 'a. Ord 'a => rel 'a 'a -> set 'a -> -> rel 'a 'a
let reflexiv_transitive_closureOn r s = transitive_closure (relUnion r (relIdOn s))

let reflexiv_transitive_closure : forall 'a. Ord 'a => rel 'a 'a -> rel 'a 'a
let reflexiv_transitive_closure r = transitive_closure (relUnion r relId)

