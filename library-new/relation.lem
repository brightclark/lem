(******************************************************************************)
(* A library for binary relations                                             *)
(******************************************************************************)

(* ========================================================================== *)
(* Header                                                                     *)
(* ========================================================================== *)

declare {isabelle;ocaml;hol;coq} rename module = lem_relation

open import Bool Basic_classes Tuple Set
open import {hol} `set_relationTheory`

(* ========================================================================== *)
(* The type of relations                                                      *)
(* ========================================================================== *)

type rel_pred 'a 'b = 'a -> 'b -> bool
type rel_set 'a 'b = set ('a * 'b)

(* Binary relations are usually represented as either
   sets of pairs (rel_set) or as curried functions (rel_pred). 
   
   The choice depends on taste and the backend. Lem should not take a 
   decision, but supports both representations. There is an abstract type
   pred, which can be converted to both representations. The representation
   of pred itself then depends on the backend. However, for the time beeing,
   let's implement relations as sets to get them working more quickly. *)

type rel 'a 'b = rel_set 'a 'b

val relToSet : forall 'a 'b. Ord 'a, Ord 'b => rel 'a 'b -> rel_set 'a 'b
val relFromSet : forall 'a 'b. Ord 'a, Ord 'b => rel_set 'a 'b -> rel 'a 'b

let inline relToSet s = s
let inline relFromSet r = r

val relEq : forall 'a 'b. Ord 'a, Ord 'b => rel 'a 'b -> rel 'a 'b -> bool
let relEq r1 r2 = (relToSet r1 = relToSet r2)

(*
instance forall 'a 'b. Ord 'a, Ord 'b => (Eq (rel 'a 'b))
  let (=) = relEq
end
*)

lemma relToSet_inv: (forall r. relFromSet (relToSet r) = r)

val relToPred : forall 'a 'b. Ord 'a, Ord 'b, Eq 'a, Eq 'b => rel 'a 'b -> rel_pred 'a 'b
val relFromPred : forall 'a 'b. Ord 'a, Ord 'b, Eq 'a, Eq 'b => set 'a -> set 'b -> rel_pred 'a 'b -> rel 'a 'b

let relToPred r = (fun x y -> (x, y) IN relToSet r)
let relFromPred xs ys p = { (x, y) | forall (x IN xs) (y IN ys) | p x y }



(* ========================================================================== *)
(* Basic Operations                                                           *)
(* ========================================================================== *)

(* ----------------------- *)
(* Identity relation       *)
(* ----------------------- *)

val inRel : forall 'a 'b. Ord 'a, Ord 'b, Eq 'a, Eq 'b => 'a -> 'b -> rel 'a 'b -> bool
let inRel a b rel = (a, b) IN relToSet rel

lemma inRel_set : (forall s a b. inRel a b (relFromSet s) = ((a, b) IN s))
lemma inRel_pred : (forall p a b sa sb. inRel a b (relFromPred sa sb p) = p a b && a IN sa && b IN sb)


(* ----------------------- *)
(* empty relation          *)
(* ----------------------- *)

val relEmpty : forall 'a 'b. Ord 'a, Ord 'b => rel 'a 'b
let inline relEmpty = relFromSet {}

(* ----------------------- *)
(* add relation            *)
(* ----------------------- *)

val relAdd : forall 'a 'b. Ord 'a, Ord 'b => 'a -> 'b -> rel 'a 'b -> rel 'a 'b
let inline relAdd a b r = relFromSet (insert (a,b) (relToSet r))


(* ----------------------- *)
(* Identity relation        *)
(* ----------------------- *)

val relIdOn : forall 'a. Ord 'a, Eq 'a => set 'a -> rel 'a 'a
let relIdOn s = relFromPred s s (=)

val relId : forall 'a. Ord 'a, Eq 'a => rel 'a 'a
let ~{coq;ocaml} relId = {(x, x) | forall x | true}

lemma relId_spec: (forall x y s. (inRel x y (relIdOn s) <-> (x IN s && (x = y))))


(* ----------------------- *)
(* relation union          *)
(* ----------------------- *)

val relUnion : forall 'a 'b. Ord 'a, Ord 'b => rel 'a 'b -> rel 'a 'b -> rel 'a 'b
let inline relUnion r1 r2 = relFromSet ((relToSet r1) union (relToSet r2))

(* ----------------------- *)
(* relation intersection   *)
(* ----------------------- *)

val relIntersection : forall 'a 'b. Ord 'a, Ord 'b, Eq 'a, Eq 'b => rel 'a 'b -> rel 'a 'b -> rel 'a 'b
let inline relIntersection r1 r2 = relFromSet ((relToSet r1) inter (relToSet r2))


(* ----------------------- *)
(* Relation Composition    *)
(* ----------------------- *)

val relComp : forall 'a 'b 'c. Ord 'a, Ord 'b, Ord 'c, Eq 'a, Eq 'b => rel 'a 'b -> rel 'b 'c -> rel 'a 'c
let relComp r1 r2 = relFromSet {(e1, e3) | forall ((e1,e2) IN (relToSet r1)) ((e2',e3) IN (relToSet r2)) | e2 = e2'}

declare hol target_rep function relComp = `rcomp`

lemma rel_comp_1 : (forall r1 r2 e1 e2 e3. (inRel e1 e2 r1 && inRel e2 e3 r2) --> inRel e1 e3 (relComp r1 r2))
lemma ~{coq;ocaml} rel_comp_2 : (forall r. (relComp r relId = r) && (relComp relId r = r))
lemma rel_comp_3 : (forall r. (relComp r relEmpty = relEmpty) && (relComp relEmpty r = relEmpty))


(* ----------------------- *)
(* restrict                *)
(* ----------------------- *)

val relRestrict : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> set 'a -> rel 'a 'a
let relRestrict r s = relFromSet ({ (a, b) | forall (a IN s) (b IN s) | inRel a b r })

declare hol target_rep function relRestrict = `rrestrict`

(* ----------------------- *)
(* Converse                *)
(* ----------------------- *)

val relConverse : forall 'a 'b. Ord 'a, Ord 'b => rel 'a 'b -> rel 'b 'a
let relConverse r = relFromSet (Set.map swap (relToSet r))

(* ----------------------- *)
(* domain                  *)
(* ----------------------- *)

val relDomain : forall 'a 'b. Ord 'a, Ord 'b => rel 'a 'b -> set 'a
let relDomain r = Set.map fst (relToSet r)

declare hol target_rep function relDomain = `domain`

(* ----------------------- *)
(* range                   *)
(* ----------------------- *)

val relRange : forall 'a 'b. Ord 'a, Ord 'b => rel 'a 'b -> set 'b
let relRange r = Set.map snd (relToSet r)

declare hol target_rep function relRange = `range`


(* ----------------------- *)
(* field / definedOn       *)
(*                         *)
(* avoid the keyword field *)
(* ----------------------- *)

val relDefinedOn : forall 'a. Ord 'a => rel 'a 'a -> set 'a
let inline relDefinedOn r = ((relDomain r) union (relRange r))

declare {hol} rename function relDefinedOn = rdefined_on


(* ----------------------- *)
(* apply a relation        *)
(* ----------------------- *)

(* Given a relation r and a set s, relApply r s applies s to r, i.e.
   it returns the set of all value reachable via r form a value in s.
   This operation can be seen as a generalisation of function application. *)
   
val relApply : forall 'a 'b. Ord 'a, Ord 'b, Eq 'a => rel 'a 'b -> set 'a -> set 'b
let relApply r s = { y | forall ((x, y) IN (relToSet r)) | x IN s }

declare {hol} rename function relApply = rapply


(* ========================================================================== *)
(* Properties                                                                 *)
(* ========================================================================== *)

(* ----------------------- *)
(* subrel                  *)
(* ----------------------- *)

val isSubrel : forall 'a 'b. Ord 'a, Ord 'b, Eq 'a, Eq 'b => rel 'a 'b -> rel 'a 'b -> bool
let inline isSubrel r1 r2 = isSubsetOf (relToSet r1) (relToSet r2)


(* ----------------------- *)
(* reflexivity             *)
(* ----------------------- *)

val isReflexiveOn : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> set 'a -> bool
let isReflexiveOn r s = (forall (e IN s). inRel e e r)

declare hol target_rep function isReflexiveOn = `reflexive`

val isReflexive : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> bool
let ~{ocaml;coq} isReflexive r = (forall e. inRel e e r)

(* ----------------------- *)
(* irreflexivity           *)
(* ----------------------- *)

val isIrreflexiveOn : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> set 'a -> bool
let isIrreflexiveOn r s = (forall (e IN s). not (inRel e e r))

declare hol target_rep function isIrreflexiveOn = `irreflexive`

val isIrreflexive : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> bool
let ~{ocaml;coq} isIrreflexive r = (forall e. not (inRel e e r))


(* ----------------------- *)
(* symmetry                *)
(* ----------------------- *)

val isSymmetricOn : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> set 'a -> bool
let isSymmetricOn r s = (forall (e1 IN s) (e2 IN s). (inRel e1 e2 r) --> (inRel e2 e1 r))

val isSymmetric : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> bool
let isSymmetric r = (forall ((e1, e2) IN relToSet r). inRel e2 e1 r)

(* ----------------------- *)
(* antisymmetry            *)
(* ----------------------- *)

val isAntisymmetricOn : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> set 'a -> bool
let isAntisymmetricOn r s = (forall (e1 IN s) (e2 IN s). (inRel e1 e2 r) --> (inRel e2 e1 r) --> (e1 = e2))

val isAntisymmetric : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> bool
let isAntisymmetric r = (forall ((e1, e2) IN relToSet r). (inRel e2 e1 r) --> (e1 = e2))

declare hol target_rep function isAntisymmetric = `antisymmetric`


(* ----------------------- *)
(* transitivity            *)
(* ----------------------- *)

val isTransitiveOn : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> set 'a -> bool
let isTransitiveOn r s = (forall (e1 IN s) (e2 IN s) (e3 IN s). (inRel e1 e2 r) --> (inRel e2 e3 r) --> (inRel e1 e3 r))

val isTransitive : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> bool
let isTransitive r = (forall ((e1, e2) IN relToSet r) (e3 IN relApply r {e2}). inRel e1 e3 r)

declare hol target_rep function isTransitive = `transitive`


(* ----------------------- *)
(* total                   *)
(* ----------------------- *)

val isTotalOn : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> set 'a -> bool
let isTotalOn r s = (forall (e1 IN s) (e2 IN s). (inRel e1 e2 r) || (inRel e2 e1 r))

declare hol target_rep function isTotalOn = `chain`


val isTotal : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> bool
let ~{ocaml;coq} isTotal r = (forall e1 e2. (inRel e1 e2 r) || (inRel e2 e1 r))
let inline {hol} isTotal r = isTotalOn r `UNIV`


val isTrichotomousOn : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> set 'a -> bool
let isTrichotomousOn r s = (forall (e1 IN s) (e2 IN s). (inRel e1 e2 r) || (e1 = e2) || (inRel e2 e1 r))

val isTrichotomous : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> bool
let ~{ocaml;coq} isTrichotomous r = (forall e1 e2. (inRel e1 e2 r) || (e1 = e2) || (inRel e2 e1 r))


(* ----------------------- *)
(* is_single_valued        *)
(* ----------------------- *)

val isSingleValued : forall 'a 'b. Ord 'a, Ord 'b, Eq 'a, Eq 'b => rel 'a 'b -> bool
let isSingleValued r = (forall ((e1, e2a) IN relToSet r) (e2b IN relApply r {e1}). e2a = e2b) 

declare {hol} rename function isSingleValued = is_single_valued


(* ----------------------- *)
(* equivalence relation    *)
(* ----------------------- *)

val isEquivalenceOn : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> set 'a -> bool
let isEquivalenceOn r s = isReflexiveOn r s && isSymmetricOn r s && isTransitiveOn r s

val isEquivalence : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> bool
let ~{ocaml;coq} isEquivalence r = isReflexive r && isSymmetric r && isTransitive r


(* ----------------------- *)
(* well founded            *)
(* ----------------------- *)

val isWellFounded : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> bool
let ~{ocaml;coq} isWellFounded r = (forall P. (forall x. (forall y. inRel y x r --> P x) --> P x) --> (forall x. P x))

declare hol      target_rep function isWellFounded r = `WF` (`reln_to_rel` r)


(* ========================================================================== *)
(* Orders                                                                     *)
(* ========================================================================== *)


(* ----------------------- *)
(* pre- or quasiorders     *)
(* ----------------------- *)

val isPreorderOn : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> set 'a -> bool
let isPreorderOn r s = isReflexiveOn r s && isTransitiveOn r s

val isPreorder : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> bool
let ~{ocaml;coq} isPreorder r = isReflexive r && isTransitive r

(* ----------------------- *)
(* partial orders          *)
(* ----------------------- *)

val isPartialOrderOn : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> set 'a -> bool
let isPartialOrderOn r s = isReflexiveOn r s && isTransitiveOn r s && isAntisymmetricOn r s

val isStrictPartialOrderOn : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> set 'a -> bool
let isStrictPartialOrderOn r s = isIrreflexiveOn r s && isTransitiveOn r s && isAntisymmetricOn r s

val isStrictPartialOrder : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> bool
let ~{ocaml;coq} isStrictPartialOrder r = isIrreflexive r && isTransitive r && isAntisymmetric r

val isPartialOrder : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> bool
let ~{ocaml;coq} isPartialOrder r = isReflexive r && isTransitive r && isAntisymmetric r

(* ----------------------- *)
(* total / linear orders   *)
(* ----------------------- *)

val isTotalOrderOn : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> set 'a -> bool
let isTotalOrderOn r s = isPartialOrderOn r s && isTotalOn r s

val isStrictTotalOrderOn : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> set 'a -> bool
let isStrictTotalOrderOn r s = isStrictPartialOrderOn r s && isTrichotomousOn r s

val isTotalOrder : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> bool
let ~{ocaml;coq} isTotalOrder r = isPartialOrder r && isTotal r 

val isStrictTotalOrder : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> bool
let ~{ocaml;coq} isStrictTotalOrder r = isStrictPartialOrder r && isTrichotomous r 


(* ========================================================================== *)
(* closures                                                                   *)
(* ========================================================================== *)

(* ----------------------- *)
(* transitive closure      *)
(* ----------------------- *)

val transitiveClosure : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> rel 'a 'a
val transitiveClosureByEq  : forall 'a. ('a -> 'a -> bool) -> rel 'a 'a -> rel 'a 'a
val transitiveClosureByCmp : forall 'a. ('a * 'a -> 'a * 'a -> ordering) -> rel 'a 'a -> rel 'a 'a

declare ocaml    target_rep function transitiveClosureByCmp = `Pset.tc`
declare hol      target_rep function transitiveClosure = `tc`
declare isabelle target_rep function transitiveClosure = `trancl`
declare coq      target_rep function transitiveClosureByEq = `set_tc`

let inline {coq} transitiveClosure = transitiveClosureByEq (=)
let inline {ocaml} transitiveClosure = transitiveClosureByCmp compare


lemma transitiveClosure_spec1: (forall r. isSubrel r (transitiveClosure r))
lemma transitiveClosure_spec2: (forall r. isTransitive (transitiveClosure r))
lemma transitiveClosure_spec3: (forall r1 r2. ((isTransitive r2) && (isSubrel r1 r2)) --> isSubrel (transitiveClosure r1) r2)


(* ========================================================================== *)
(* reflexiv closures                                                          *)
(* ========================================================================== *)

val reflexivTransitiveClosureOn : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> set 'a -> rel 'a 'a
let reflexivTransitiveClosureOn r s = transitiveClosure (relUnion r (relIdOn s))

val reflexivTransitiveClosure : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> rel 'a 'a
let ~{ocaml;coq} reflexivTransitiveClosure r = transitiveClosure (relUnion r relId)

