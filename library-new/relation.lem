(******************************************************************************)
(* A library for binary relations                                             *)
(******************************************************************************)

open import Bool Basic_classes Set


(* ========================================================================== *)
(* Header                                                                     *)
(* ========================================================================== *)


(* rename module to clash with existing list modules of targets
   problem: renaming from inside the module itself! *)
(*
declare rename module = lem_relation
*)

(* ========================================================================== *)
(* The type of relations                                                      *)
(* ========================================================================== *)

type rel_pred 'a 'b = 'a -> 'b -> bool
type rel_set 'a 'b = set ('a * 'b)

(* Binary relations are usually represented as either
   sets of pairs (rel_set) or as curried functions (rel_pred). 
   
   The choice depends on taste and the backend. Lem does not take a 
   decision, but supports both representations. There is an abstract type
   pred, which can be converted to both representations. The representation
   of pred itself then depends on the backend. *)

type rel 'a 'b

declare hol      target_rep type rel 'a 'b = ('a -> 'b -> bool)
declare isabelle target_rep type rel 'a 'b = set ('a * 'b)

val relToSet : forall 'a 'b. Ord 'a, Ord 'b => rel 'a 'b -> rel_set 'a 'b
val relFromSet : forall 'a 'b. Ord 'a, Ord 'b => rel_set 'a 'b -> rel 'a 'b

let relToSet = `TODO`
let relFromSet = `TODO`

val relEq : forall 'a 'b. Ord 'a, Ord 'b => rel 'a 'b -> rel 'a 'b -> bool
let relEq r1 r2 = (relToSet r1 = relToSet r2)

instance forall 'a 'b. Ord 'a, Ord 'b => (Eq (rel 'a 'b))
  let (=) = relEq
end

lemma relToSet_inv: (forall r. relFromSet (relToSet r) = r)

val relToPred : forall 'a 'b. Ord 'a, Ord 'b => rel 'a 'b -> rel_pred 'a 'b
val relFromPred : forall 'a 'b. Ord 'a, Ord 'b => rel_pred 'a 'b -> rel 'a 'b

let relToPred = `TODO`
let relFromPred = `TODO`

lemma relToPred_inv: (forall r. relFromPred (relToPred r) = r)


(* ========================================================================== *)
(* Basic Operations                                                           *)
(* ========================================================================== *)

(* ----------------------- *)
(* Identity relation       *)
(* ----------------------- *)

val inRel : forall 'a 'b. Ord 'a, Ord 'b => 'a -> 'b -> rel 'a 'b -> bool

let inRel a b rel = relToPred rel a b

lemma inRel_set : (forall s a b. inRel a b (relFromSet s) = ((a, b) IN s))
lemma inRel_pred : (forall p a b. inRel a b (relFromPred p) = p a b)


(* ----------------------- *)
(* empty relation          *)
(* ----------------------- *)

val relEmpty : forall 'a 'b. Ord 'a, Ord 'b => rel 'a 'b
let relEmpty = relFromSet {}

(* ----------------------- *)
(* add relation            *)
(* ----------------------- *)

val relAdd : forall 'a 'b. Ord 'a, Ord 'b => 'a -> 'b -> rel 'a 'b -> rel 'a 'b
let relAdd a b r = relFromSet (insert (a,b) (relToSet r))


(* ----------------------- *)
(* Identity relation        *)
(* ----------------------- *)

val relIdOn : forall 'a. Ord 'a, Eq 'a => set 'a -> rel 'a 'a
let relIdOn s = relFromPred (fun e1 e2 -> (e1 IN s) && (e2 IN s) && (e1 = e2))

val relId : forall 'a. Ord 'a, Eq 'a => rel 'a 'a
let relId = relFromPred (=)

lemma relId_spec: (forall x y. (inRel x y relId <-> (x = y)))


(* ----------------------- *)
(* relation union          *)
(* ----------------------- *)

val relUnion : forall 'a 'b. Ord 'a, Ord 'b => rel 'a 'b -> rel 'a 'b -> rel 'a 'b
let relUnion r1 r2 = relFromPred (fun e1 e2 -> ((inRel e1 e2 r1) || (inRel e1 e2 r2)))

(* ----------------------- *)
(* relation intersection   *)
(* ----------------------- *)

val relIntersection : forall 'a 'b. Ord 'a, Ord 'b => rel 'a 'b -> rel 'a 'b -> rel 'a 'b
let relIntersection r1 r2 = relFromPred (fun e1 e2 -> ((inRel e1 e2 r1) && (inRel e1 e2 r2)))


(* ----------------------- *)
(* Relation Composition    *)
(* ----------------------- *)

val relComp : forall 'a 'b 'c. Ord 'a, Ord 'b, Ord 'c, Eq 'b => rel 'a 'b -> rel 'b 'c -> rel 'a 'c
 let relComp r1 r2 = relFromSet {(e1, e3) | forall ((e1,e2) IN (relToSet r1)) ((e2',e3) IN (relToSet r2)) | e2 = e2'}

lemma rel_comp_1 : (forall r1 r2 e1 e2 e3. (inRel e1 e2 r1 && inRel e2 e3 r2) --> inRel e1 e3 (relComp r1 r2))
lemma rel_comp_2 : (forall r. (relComp r relId = r) && (relComp relId r = r))
lemma rel_comp_3 : (forall r. (relComp r relEmpty = relEmpty) && (relComp relEmpty r = relEmpty))


(* ----------------------- *)
(* restrict                *)
(* ----------------------- *)

val relRestrict : forall 'a. Ord 'a => rel 'a 'a -> set 'a -> rel 'a 'a
let relRestrict r s = relFromSet ({ (a, b) | forall (a IN s) (b IN s) | inRel a b r })

(* ----------------------- *)
(* Converse                *)
(* ----------------------- *)

val converse : forall 'a 'b. Ord 'a, Ord 'b => rel 'a 'b -> rel 'b 'a
let converse r = relFromPred (fun e1 e2 -> inRel e2 e1 r)

(* ----------------------- *)
(* domain                  *)
(* ----------------------- *)

val domain : forall 'a 'b. Ord 'a, Ord 'b => rel 'a 'b -> set 'a
let domain r = { e1 | forall ((e1, _) IN (relToSet r)) | true}

(* ----------------------- *)
(* range                   *)
(* ----------------------- *)

val range : forall 'a 'b. Ord 'a, Ord 'b => rel 'a 'b -> set 'b
let range r = { e2 | forall ((_, e2) IN (relToSet r)) | true}

(* ----------------------- *)
(* field / definedOn       *)
(*                         *)
(* avoid the keyword field *)
(* ----------------------- *)

val definedOn : forall 'a. Ord 'a => rel 'a 'a -> set 'a
let definedOn r = (union (domain r) (range r))

(* ----------------------- *)
(* apply a relation        *)
(* ----------------------- *)

(* Given a relation r and a set s, relApply r s applies s to r, i.e.
   it returns the set of all value reachable via r form a value in s.
   This operation can be seen as a generalisation of function application. *)
   
val relApply : forall 'a 'b. Ord 'a, Ord 'b, Eq 'a => rel 'a 'b -> set 'a -> set 'b
let relApply r s = { y | forall ((x, y) IN (relToSet r)) | x IN s }



(* ========================================================================== *)
(* Properties                                                                 *)
(* ========================================================================== *)

(* ----------------------- *)
(* subrel                  *)
(* ----------------------- *)

val isSubrel : forall 'a 'b. Ord 'a, Ord 'b, Eq 'a, Eq 'b => rel 'a 'b -> rel 'a 'b -> bool
let isSubrel r1 r2 = isSubsetOf (relToSet r1) (relToSet r2)


(* ----------------------- *)
(* reflexivity             *)
(* ----------------------- *)

val isReflexiveOn : forall 'a. Ord 'a => rel 'a 'a -> set 'a -> bool
let isReflexiveOn r s = (forall (e IN s). inRel e e r)

val isReflexive : forall 'a. Ord 'a => rel 'a 'a -> bool
let ~{ocaml;coq} isReflexive r = (forall e. inRel e e r)

(* ----------------------- *)
(* irreflexivity           *)
(* ----------------------- *)

val isIrreflexiveOn : forall 'a. Ord 'a => rel 'a 'a -> set 'a -> bool
let isIrreflexiveOn r s = (forall (e IN s). not (inRel e e r))

val isIrreflexive : forall 'a. Ord 'a => rel 'a 'a -> bool
let ~{ocaml;coq} isIrreflexive r = (forall e. not (inRel e e r))


(* ----------------------- *)
(* symmetry                *)
(* ----------------------- *)

val isSymmetricOn : forall 'a. Ord 'a => rel 'a 'a -> set 'a -> bool
let isSymmetricOn r s = (forall (e1 IN s) (e2 IN s). (inRel e1 e2 r) --> (inRel e2 e1 r))

val isSymmetric : forall 'a. Ord 'a => rel 'a 'a -> bool
let isSymmetric r = (forall ((e1, e2) IN relToSet r). inRel e2 e1 r)

(* ----------------------- *)
(* antisymmetry            *)
(* ----------------------- *)

val isAntisymmetricOn : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> set 'a -> bool
let isAntisymmetricOn r s = (forall (e1 IN s) (e2 IN s). (inRel e1 e2 r) --> (inRel e2 e1 r) --> (e1 = e2))

val isAntisymmetric : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> bool
let isAntisymmetric r = (forall ((e1, e2) IN relToSet r). (inRel e2 e1 r) --> (e1 = e2))


(* ----------------------- *)
(* transitivity            *)
(* ----------------------- *)

val isTransitiveOn : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> set 'a -> bool
let isTransitiveOn r s = (forall (e1 IN s) (e2 IN s) (e3 IN s). (inRel e1 e2 r) --> (inRel e2 e3 r) --> (inRel e1 e3 r))

val isTransitive : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> bool
let isTransitive r = (forall ((e1, e2) IN relToSet r) (e3 IN relApply r {e2}). inRel e1 e3 r)

(* ----------------------- *)
(* total                   *)
(* ----------------------- *)

val isTotalOn : forall 'a. Ord 'a => rel 'a 'a -> set 'a -> bool
let isTotalOn r s = (forall (e1 IN s) (e2 IN s). (inRel e1 e2 r) || (inRel e2 e1 r))

val isTotal : forall 'a. Ord 'a => rel 'a 'a -> bool
let ~{ocaml;coq} isTotal r = (forall e1 e2. (inRel e1 e2 r) || (inRel e2 e1 r))

val isTrichotomousOn : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> set 'a -> bool
let isTrichotomousOn r s = (forall (e1 IN s) (e2 IN s). (inRel e1 e2 r) || (e1 = e2) || (inRel e2 e1 r))

val isTrichotomous : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> bool
let ~{ocaml;coq} isTrichotomous r = (forall e1 e2. (inRel e1 e2 r) || (e1 = e2) || (inRel e2 e1 r))


declare isabelle target_rep function isTrichotomousOn = `total_on`
declare isabelle target_rep function isTrichotomous   = `total`
declare hol      target_rep function isTrichotomous   = `trichotomous`


(* ----------------------- *)
(* is_single_valued        *)
(* ----------------------- *)

val isSingleValued : forall 'a 'b. Ord 'a, Ord 'b, Eq 'a, Eq 'b => rel 'a 'b -> bool
let isSingleValued r = (forall ((e1, e2a) IN relToSet r) (e2b IN relApply r {e1}). e2a = e2b) 


(* ----------------------- *)
(* equivalence relation    *)
(* ----------------------- *)

val isEquivalenceOn : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> set 'a -> bool
let isEquivalenceOn r s = isReflexiveOn r s && isSymmetricOn r s && isTransitiveOn r s

val isEquivalence : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> bool
let ~{ocaml;coq} isEquivalence r = isReflexive r && isSymmetric r && isTransitive r

(* ----------------------- *)
(* well founded            *)
(* ----------------------- *)

val isWellFounded : forall 'a. Ord 'a => rel 'a 'a -> bool
let ~{ocaml;coq} isWellFounded r = (forall P. (forall x. (forall y. inRel y x r --> P x) --> P x) --> (forall x. P x))

declare isabelle target_rep function isWellFounded = `wf`
declare hol      target_rep function isWellFounded = `WF`


(* ========================================================================== *)
(* Orders                                                                     *)
(* ========================================================================== *)


(* ----------------------- *)
(* pre- or quasiorders     *)
(* ----------------------- *)

val isPreorderOn : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> set 'a -> bool
let isPreorderOn r s = isReflexiveOn r s && isTransitiveOn r s

val isPreorder : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> bool
let ~{ocaml;coq} isPreorder r = isReflexive r && isTransitive r

(* ----------------------- *)
(* partial orders          *)
(* ----------------------- *)

val isPartialOrderOn : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> set 'a -> bool
let isPartialOrderOn r s = isReflexiveOn r s && isTransitiveOn r s && isAntisymmetricOn r s

val isStrictPartialOrderOn : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> set 'a -> bool
let isStrictPartialOrderOn r s = isIrreflexiveOn r s && isTransitiveOn r s && isAntisymmetricOn r s

val isStrictPartialOrder : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> bool
let ~{ocaml;coq} isStrictPartialOrder r = isIrreflexive r && isTransitive r && isAntisymmetric r

val isPartialOrder : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> bool
let ~{ocaml;coq} isPartialOrder r = isReflexive r && isTransitive r && isAntisymmetric r

(* ----------------------- *)
(* total / linear orders   *)
(* ----------------------- *)

val isTotalOrderOn : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> set 'a -> bool
let isTotalOrderOn r s = isPartialOrderOn r s && isTotalOn r s

val isStrictTotalOrderOn : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> set 'a -> bool
let isStrictTotalOrderOn r s = isStrictPartialOrderOn r s && isTrichotomousOn r s

val isTotalOrder : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> bool
let ~{ocaml;coq} isTotalOrder r = isPartialOrder r && isTotal r 

val isStrictTotalOrder : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> bool
let ~{ocaml;coq} isStrictTotalOrder r = isStrictPartialOrder r && isTrichotomous r 


(* ========================================================================== *)
(* closures                                                                   *)
(* ========================================================================== *)

(* ----------------------- *)
(* transitive closure      *)
(* ----------------------- *)

val transitiveClosure : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> rel 'a 'a
val transitiveClosureByEq  : forall 'a. ('a -> 'a -> bool) -> rel 'a 'a -> rel 'a 'a
val transitiveClosureByCmp : forall 'a. ('a -> 'a -> ordering) -> rel 'a 'a -> rel 'a 'a

declare ocaml    target_rep function transitiveClosureByCmp = `Pset.tc`
declare hol      target_rep function transitiveClosure = `tc`
declare isabelle target_rep function transitiveClosure = `trancl`
declare coq      target_rep function transitiveClosureByEq = `set_tc`

let inline {coq} transitiveClosure = transitiveClosureByEq (=)
let inline {ocaml} transitiveClosure = transitiveClosureByCmp compare


lemma transitiveClosure_spec1: (forall r. isSubrel r (transitiveClosure r))
lemma transitiveClosure_spec2: (forall r. isTransitive (transitiveClosure r))
lemma transitiveClosure_spec3: (forall r1 r2. ((isTransitive r2) && (isSubrel r1 r2)) --> isSubrel (transitiveClosure r1) r2)


(* ========================================================================== *)
(* reflexiv closures                                                          *)
(* ========================================================================== *)

val reflexivTransitiveClosureOn : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> set 'a -> rel 'a 'a
let reflexivTransitiveClosureOn r s = transitiveClosure (relUnion r (relIdOn s))

val reflexivTransitiveClosure : forall 'a. Ord 'a, Eq 'a => rel 'a 'a -> rel 'a 'a
let reflexivTransitiveClosure r = transitiveClosure (relUnion r relId)

