assert uneq_1: (3 <> 2)
assert uneq_2: ((2,1) <> (3,2))

assert less_1: (2 < 3)
assert less_2: (4 < 10)
assert less_3: (not (10 < 4))
assert less_4: (not (4 < 4))
assert less_5: (not (0 < 0))
assert less_6: (0 < 56)
lemma less_not_eq: (forall n. not ((n:num) < n))

assert greater_1: (3 > 2)
assert greater_2: (10 > 4)
assert greater_3: (not (4 > 10))
assert greater_4: (not (4 > 4))
assert greater_5: (not (0 > 0))
assert greater_6: (56 > 0)
lemma greater_eq: (forall n m. ((n:num) > m) = (m < n))

assert less_eq_1: (2 <= 3)
assert less_eq_2: (4 <= 10)
assert less_eq_3: (not (10 <= 4))
assert less_eq_4: (not (3 <= 2))
assert less_eq_5: (4 <= 4)
assert less_eq_6: (0 <= 0)
assert less_eq_7: (0 <= 56)
lemma less_eq_eq: (forall n. ((n:num) <= n))
lemma less_eq_def: (forall n m. ((n:num) <= m) = (n < m || (n = m)))

assert greater_eq_1: (3 >= 2)
assert greater_eq_2: (10 >= 4)
assert greater_eq_3: (not (4 >= 10))
assert greater_eq_4: (not (2 >= 3))
assert greater_eq_5: (4 >= 4)
assert greater_eq_6: (0 >= 0)
assert greater_eq_7: (56 >= 0)
lemma greater_eq_def: (forall n m. ((n:num) >= m) = (m <= n))

assert add_0 : ((2 + 3) = 5)
assert add_1 : ((3 + 2) = 5)
assert add_2 : ((10 + 1) = 11)

assert sub_0 : ((10 - 3) = 7)
assert sub_1 : ((3 - 3) = 0)
assert sub_2 : ((3 - 10) = 0)
assert sub_3 : ((10 - 0) = 10)
assert sub_4 : ((10 - 11) = 0)

assert mul_0 : ((3 * 3) = 9)
assert mul_1 : ((3 * 0) = 0)
assert mul_2 : ((3 * 1) = 3)
assert mul_3 : ((3 * 20) = 60)

assert pow_0 : ((3 ** 3) = 27)
assert pow_1 : ((3 ** 0) = 1)
assert pow_2 : ((3 ** 1) = 3)
assert pow_3 : ((3 ** 2) = 9)

assert div_0 : ((6 / 3) = 2)
assert div_1 : ((12 / 4) = 3)
assert div_2 : ((13 / 4) = 3)
assert div_3 : ((14 / 4) = 3)
assert div_4 : ((15 / 4) = 3)
assert div_5 : ((16 / 4) = 4)

assert mod_0 : ((6 mod 3) = 0)
assert mod_1 : ((12 mod 4) = 0)
assert mod_2 : ((13 mod 4) = 1)
assert mod_3 : ((14 mod 4) = 2)
assert mod_4 : ((15 mod 4) = 3)
assert mod_5 : ((16 mod 4) = 0)
lemma div_mod: (forall n m. (n:num) > 0 && (m > 0) --> ((n / m) * m + (n mod m) = n))

assert not_false: (not false = true)
assert not_true: (not true = false)

assert and_tt: ((true  && true ) = true)
assert and_tf: ((true  && false) = false)
assert and_ft: ((false && true ) = false)
assert and_ff: ((false && false) = false)

assert or_tt: ((true  || true ) = true)
assert or_tf: ((true  || false) = true)
assert or_ft: ((false || true ) = true)
assert or_ff: ((false || false) = false)

assert imp_tt: ((true  --> true ) = true)
assert imp_tf: ((true  --> false) = false)
assert imp_ft: ((false --> true ) = true)
assert imp_ff: ((false --> false) = true)


assert fst_0: (fst (0, 1) = 0)
assert fst_1: (fst (1, 0) = 1)
assert snd_0: (snd (0, 1) = 1)
assert snd_1: (snd (1, 0) = 0)
lemma fst_snd_eq: (forall x. (fst x, snd x) = x)

assert append_1: ([1;2;3] @ [4;5] = [1;2;3;4;5])
lemma append_thm: (forall l1 l2. l1 @ l2 = (List.append l1 l2))

assert in_1: (1 IN {2;3;1})
assert in_2: (not (1 IN {2;3;4}))
assert in_3: (not (1 IN {}))
assert in_4: (1 IN {1;2;1;3;1;4})

assert subset_1: (({}:set num) subset {})
assert subset_2: ({1;2;3} subset {1;2;3})
assert subset_3: ({1;2} subset {3;2;1})
lemma subset_refl: (forall s. s subset s)

assert union_1: (Set.equal ({} union {1;2;3}) {1;2;3})
assert union_2: (Set.equal ({4} union {1;2;3}) {1;2;3;4})
assert union_3: (Set.equal ({4;2} union {1;2;3}) {1;2;3;4})
assert union_4: (Set.equal ({1;2;3} union {5}) {1;2;3;5})

assert inter_1: (Set.equal ({} inter {1;2;3}) {})
assert inter_2: (Set.equal ({2} inter {1;2;3}) {2})
assert inter_3: (Set.equal ({4;2} inter {1;4;2;3}) {2;4})
assert inter_4: (Set.equal ({4;2} inter {1;4;2;3}) {2;4})
assert inter_5: (Set.equal ({1;2;3} inter {}) {})

assert empty_1: (Set.equal {} empty)

assert diff_1: (Set.equal ({1;2;3;4} \ {3;2}) {4;1})
assert diff_2: (Set.equal ({2;3;4} \ {}) {2;3;4})
assert diff_3: (Set.equal ({2;4;1} \ {1}) {2;4})

lemma diff_empty: (forall s. Set.equal (s \ {}) s)
lemma diff_thm: (forall s1 s2. (Set.equal (s1 \ s2) {}) = (s1 subset s2))

(*
val bigunion : forall 'a. set (set 'a) -> set 'a
let inline {hol} bigunion = Hol.BIGUNION
let inline {ocaml} bigunion = Ocaml.Pset.bigunion Ocaml.compare

val biginter : forall 'a. set (set 'a) -> set 'a
let inline {hol} biginter = Hol.BIGINTER
let inline {ocaml} biginter = Ocaml.Pset.biginter

val (^) : string -> string -> string
let inline {hol} (^) x y = Hol.STRCAT x y
let inline {ocaml} (^) = Ocaml.(^)

val (::) : forall 'a. 'a -> list 'a -> list 'a
let inline {hol} (::) = Hol.(::)
let inline {ocaml} (::) = Ocaml.(::)
let inline {isabelle} (::) = Isabelle.\\#
let inline {coq} (::) = Coq.(::)

type option 'a = 
  | None
  | Some of 'a

val string_of_num : num -> string
let inline {ocaml} string_of_num = Ocaml.Nat_num.string_of_num
*)


(*

val (land) : num -> num -> num
let inline {hol} (land) = Hol.bitwise_and
let inline {ocaml} (land) = Ocaml.Nat_num.(land)
let inline {isabelle} (land) = Isabelle.bitwise_and
let inline {coq} (land) = Coq.bitwise_and

val (lor) : num -> num -> num
let inline {hol} (lor) =  Hol.bitwise_or
let inline {ocaml} (lor) = Ocaml.Nat_num.(lor)
let inline {isabelle} (lor) = Isabelle.bitwise_or
let inline {coq} (lor) = Coq.bitwise_or

val (lxor) : num -> num -> num
let inline {hol} (lxor) = Hol.bitwise_xor
let inline {ocaml} (lxor) = Ocaml.Nat_num.(lxor)
let inline {isabelle} (lxor) = Isabelle.bitwise_xor
let inline {coq} (lxor) = Coq.bitwise_xor

val lnot : num -> num
let inline {ocaml} lnot = Ocaml.Nat_num.lnot
let inline {hol} lnot = Hol.bitwise_not
let inline {isabelle} lnot = Isabelle.bitwise_not
let inline {coq} lnot = Coq.bitwise_not

val (lsl) : num -> num -> num
let inline {ocaml} (lsl) = Ocaml.Nat_num.(lsl)
let inline {isabelle} (lsl) = Isabelle.num_lsl
let inline {hol} (lsl) = Hol.num_lsl
let inline {coq} (lsl) = Coq.bitwise_lsl

val (lsr) : num -> num -> num
let inline {ocaml} (lsr) = Ocaml.Nat_num.(lsr)
let inline {isabelle} (lsr) = Isabelle.num_lsr
let inline {hol} (lsr) = Hol.num_lsr
let inline {coq} (lsr) = Coq.bitwise_lsr

val (asr) : num -> num -> num
let inline {ocaml} (asr) = Ocaml.Nat_num.(asr)
let inline {isabelle} (asr) = Isabelle.num_asr
let inline {hol} (asr) = Hol.num_asr
let inline {coq} (asr) = Coq.bitwise_asr

val tc : forall 'a. set ('a * 'a) -> set ('a * 'a)
let inline {coq} tc = Coq.set_tc Coq.(==)


*)