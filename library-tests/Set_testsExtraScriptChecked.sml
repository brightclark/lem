(*Generated by Lem from set_tests.lem.*)
open bossLib Theory Parse res_quanTheory
open finite_mapTheory listTheory pairTheory pred_setTheory integerTheory
open set_relationTheory fixedPointTheory sortingTheory stringTheory wordsTheory

val _ = numLib.prefer_num();



open Set_testsTheory

val _ = new_theory "Set_testsExtra"


(****************************************************)
(*                                                  *)
(* Assertions                                       *)
(*                                                  *)
(****************************************************)

val singleton_1 = prove(
`` (=) ({ 1}) {1}``,
  EVAL_TAC
);

val singleton_2 = prove(
`` (=) ({ 2}) {2}``,
  EVAL_TAC
);

val add_1 = prove(
`` (=) ( (INSERT) 2 {3;4}) {2;3;4}``,
  EVAL_TAC
);

val add_2 = prove(
`` (=) ( (INSERT) 3 {3;4}) {3;4}``,
  EVAL_TAC
);

val add_3 = prove(
`` (=) ( (INSERT) 3 {}) {3}``,
  EVAL_TAC
);

val cardinal_1 = prove(
`` CARD ({}: num set) = 0 ``,
  EVAL_TAC
);

val cardinal_2 = prove(
`` CARD {2} = 1 ``,
  EVAL_TAC
);

val cardinal_3 = prove(
`` CARD {1;1} = 1 ``,
  EVAL_TAC
);

val cardinal_4 = prove(
`` CARD {2;1;3} = 3 ``,
  EVAL_TAC
);

val cardinal_5 = prove(
`` CARD {2;1;3;9} = 4 ``,
  EVAL_TAC
);

val finite_0 = prove(
`` FINITE {}``,
  EVAL_TAC
);

val finite_1 = prove(
`` FINITE {2;3;4;5;6;7;9}``,
  EVAL_TAC
);

val finite_2 = prove(
`` FINITE {1;3;4}``,
  EVAL_TAC
);

val is_empty_1 = prove(
``{} = EMPTY ``,
  EVAL_TAC
);

val is_empty_2 = prove(
`` ~  ( {1} = EMPTY)``,
  EVAL_TAC
);

val image_1 = prove(
`` (=) ( IMAGE (\ x . x + x) {2;3;4}) {4;6;8}``,
  EVAL_TAC
);

val image_2 = prove(
`` (=) ( IMAGE (\ x . x + x) {5}) {10}``,
  EVAL_TAC
);

val cross_1 = prove(
``(1,2) IN ( (CROSS) {2;3;1} {2;4})``,
  EVAL_TAC
);

val cross_2 = prove(
``(2,2) IN ( (CROSS) {2;3;1} {2;4})``,
  EVAL_TAC
);

val cross_3 = prove(
`` ~  (((2,1) IN (CROSS) {2;3;1} {2;4}))``,
  EVAL_TAC
);

val cross_4 = prove(
`` ~  (((5,3) IN (CROSS) {2;3;1} {2;4}))``,
  EVAL_TAC
);


(****************************************************)
(*                                                  *)
(* Lemmata                                          *)
(*                                                  *)
(****************************************************)

val singleton_thm = store_thm("singleton_thm",
`` ! x. (=) ({ x}) {x}``,
  REWRITE_TAC[]
);

val add_swap = store_thm("add_swap",
`` ! s e1 e2. (=) 
    ( (INSERT) e1 ( (INSERT) e2 s))
    ( (INSERT) e2 ( (INSERT) e1 s))``,
  PROVE_TAC [INSERT_COMM]
);

val add_idem = store_thm("add_idem",
`` ! s e. (=) 
    ( (INSERT) e ( (INSERT) e s))
    ( (INSERT) e s)``,
  PROVE_TAC [INSERT_INSERT]
);

val add_in = store_thm("add_in",
`` ! s e. e IN ( (INSERT) e s)``,
  SIMP_TAC (std_ss++pred_setSimps.PRED_SET_ss) []
);

(* Holds only for finite sets s *)
val for_all_thm = store_thm("for_all_thm",
`` ! P s. (( EVERY  P (SET_TO_LIST  s)) = (! (e :: s). P e))``,
  (* your proof *)
);

(* Holds only for finite sets s *)
val exists_thm = store_thm("exists_thm",
`` ! P s. ( EXISTS  P (SET_TO_LIST  s)) = (? (e :: s). P e)``,
  (* your proof *)
);

val finite_add = store_thm("finite_add",
`` ! e s. FINITE s ==> FINITE ( (INSERT) e s)``,
  SIMP_TAC (std_ss++pred_setSimps.PRED_SET_ss) []
);

val finite_counter = store_thm("finite_counter",
`` ~  ( FINITE  
  { x | x | x > 5})``,
  (* your proof *)
);

val to_list_from_list = store_thm("to_list_from_list",
`` ! s. FINITE s ==> (=) ( LIST_TO_SET ( SET_TO_LIST s)) s ``,
  PROVE_TAC [SET_TO_LIST_INV]
);

val to_list_mem = store_thm("to_list_mem",
`` ! s e. FINITE s ==> ( MEM e ( SET_TO_LIST s) = (e IN s))``,
  PROVE_TAC [SET_TO_LIST_IN_MEM]
);

val is_empty_lem = store_thm("is_empty_lem",
`` ! s. ( s = EMPTY) ==> ( CARD s = 0)``,
  SIMP_TAC (std_ss++pred_setSimps.PRED_SET_ss) []
);

val choose_in = store_thm("choose_in",
`` ! s d. ~  ( s = EMPTY) ==> ( CHOICE  s) IN s ``,
  PROVE_TAC [CHOICE_DEF]
);

val choose_seteq = store_thm("choose_seteq",
`` ! s1 s2 d. ( (=) s1 s2) ==> (( CHOICE  s1) = CHOICE  s2)``,
  SIMP_TAC std_ss []
);

val fold_seteq = store_thm("fold_seteq",
`` ! s1 s2 f x0. ( (=) s1 s2) ==> ( ITSET f s1 x0 = ITSET f s2 x0)``,
  SIMP_TAC std_ss []
);

val filter_emp = store_thm("filter_emp",
`` ! P. ( (=) ({e | e | 
  (e IN {}) /\ P e}) {})``,
  SIMP_TAC (std_ss++pred_setSimps.PRED_SET_ss) []
);

val filter_add = store_thm("filter_add",
`` ! e s P. ( (=) ({e0 | e0 | 
  (e0 IN ( (INSERT) e s)) /\ P e0})
  (if (P e) then (INSERT) e ({e | e | 
  (e IN s) /\ P e}) else ({e | e | (e IN s) /\ P e})))``,
  REPEAT GEN_TAC THEN 
  Cases_on `P e` THEN (
    ASM_SIMP_TAC (std_ss++pred_setSimps.PRED_SET_ss) [EXTENSION] THEN 
    PROVE_TAC[]
  )
);

val image_emp = store_thm("image_emp",
`` ! f. ( (=) ( IMAGE f {}) {})``,
  SIMP_TAC (std_ss++pred_setSimps.PRED_SET_ss) []
);

val image_add = store_thm("image_add",
`` ! e s f. ( (=) ( IMAGE f ( (INSERT) e s)) 
  ( (INSERT) (f e) ( IMAGE f s)))``,
  SIMP_TAC (std_ss++pred_setSimps.PRED_SET_ss) []
);

val cross_emp_1 = store_thm("cross_emp_1",
`` ! s. (=) ( (CROSS) (s: num set) {}) {}``,
  SIMP_TAC (std_ss++pred_setSimps.PRED_SET_ss) []
);

val lfp_thm = store_thm("lfp_thm",
`` ! s f. monotone f ==> ( lfp (\ s' .  f s' UNION  s) = (if (f s SUBSET s) then s else lfp (\ s' .  f s' UNION  (s UNION f s))))``,
  (* TODO: port isabelle proof *)
);



val _ = export_theory()

