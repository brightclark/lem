(* --------------------------- Ident syntax tests -------------------------- *)
(* ------------------------------------------------------------------------- *)
(* ------------------------------------------------------------------------- *)

module M = struct type t = <| f : num |> end
let _ = <| M .f = 1 |>

===============================================================================
module M = struct module N = struct type t = <| f : num |> end end
let _ = <| M .N.f = 1 |>

===============================================================================
module M = struct module N = struct type t = <| f : num |> end end
let _ = <| M. N.f = 1 |>

===============================================================================
module M = struct module N = struct type t = <| f : num |> end end
let _ = <| M.N .f = 1 |>

===============================================================================
module M = struct module N = struct type t = <| f : num |> end end
let _ = <| M.N. f = 1 |>

===============================================================================
module M = struct let x = 1 end
let _ = M .x

===============================================================================
module M = struct module N = struct let x = 1 end end
let _ = M .N.x

===============================================================================
module M = struct module N = struct let x = 1 end end
let _ = M. N.x

===============================================================================
module M = struct module N = struct let x = 1 end end
let _ = M.N .x

===============================================================================
module M = struct module N = struct let x = 1 end end
let _ = M.N. x


===============================================================================
(* --------------------------- Type tests ---------------------------------- *)
(* ------------------------------------------------------------------------- *)
(* ------------------------------------------------------------------------- *)

type t = u

===============================================================================
type t = num num

===============================================================================
type t 'a = c of 'a
type u = t

===============================================================================
class (c 'a) val f : 'a end
type t = c

===============================================================================
(* ------------------------ Pattern tests ---------------------------------- *)
(* ------------------------------------------------------------------------- *)
(* ------------------------------------------------------------------------- *)

type x = | X
let f (X a) = 1

===============================================================================
type x = | X of bool
let f (X a b) = 1

===============================================================================
type x = | X of bool
let f X = 1

===============================================================================
module M = struct type t = | Y end
let f (M.X y) = 1

===============================================================================
let f (M.X y) = 1

===============================================================================
type t = <| X : num |>
let f (X y) = 1

===============================================================================
let f (X y) = 1

===============================================================================
type t = | X of num
let f (_ as X) = match 1 with | (X 1) -> 1 end

===============================================================================
let f <| fld = 1 |> = 1

===============================================================================
type t = | fld
let f <| fld = 1 |> = 1

===============================================================================
let fld = 1
let f <| fld = 1 |> = 1

===============================================================================
class (c 'a) val fld : num end
let f <| fld = 1 |> = 1

===============================================================================
type t = <| fld : bool |>
let f <| fld = true; fld2 = false |> = 0

===============================================================================
type t = <| fld : bool |>
let f <| fld = true; fld = true |> = 0

===============================================================================
let f (x,x) = 1

===============================================================================
(* ------------------------ Expression tests ------------------------------- *)
(* ------------------------------------------------------------------------- *)
(* ------------------------------------------------------------------------- *)

let _ = x

===============================================================================
let f x = x +++ x

===============================================================================
let _ = M.x

===============================================================================
module M = struct let y = 10 end
let _ = M.x

===============================================================================
module M = struct let y = 10 end
let _ = M.N.x

===============================================================================
type t = <| x : bool |>
let _ = x

===============================================================================
let _ = fun x x -> x

===============================================================================
let _ = <| fld = 1 |>

===============================================================================
type t = | fld
let _ = <| fld = 1 |>

===============================================================================
let fld = 1
let _ = <| fld = 1 |>

===============================================================================
type t = <| fld : bool |>
let _ = <| fld = true; fld2 = false |>

===============================================================================
type t = <| fld : bool |>
let _ = <| fld = true; fld = true |>

===============================================================================
type t = <| fld1 : bool; fld2 : bool |>
let _ = <| fld1 = true |>

===============================================================================
let _ = 
  let x = x in
    x

===============================================================================
let _ = 
  let f x = f x in
    f

===============================================================================
let _ = 
  let f x = 1 in
    x

===============================================================================
let _ = { x | forall y | x }

===============================================================================
let _ = { x | forall (x IN x) | x }

===============================================================================
let _ = { x | forall (x IN {}) (x IN {}) | x }

===============================================================================
let _ = [ x | forall (x IN {}) | x ]

===============================================================================
let _ = [ x | forall x | x ]

===============================================================================
let _ = forall (x IN x). true

===============================================================================
let _ = forall (x IN {}) (x IN {}). true

===============================================================================

(* ------------------------ Type definition tests -------------------------- *)
(* ------------------------------------------------------------------------- *)
(* ------------------------------------------------------------------------- *)

type t = num and t = bool

===============================================================================
type t = num
type t = num

===============================================================================
class (c 'a) val f : 'a end
type c = num

===============================================================================
type t 'a 'a = num

===============================================================================
type t = <| f : bool; f : bool |>

===============================================================================
type t = <| f : bool |>
type u = <| f : bool |>

===============================================================================
type t = <| f : bool |> and u = <| f : bool |>

===============================================================================
type t = u and u = bool

===============================================================================
type t = | C | C

===============================================================================
type t = | C and u = | C

===============================================================================
type t = | C
type u = | C

===============================================================================
let C = 1
type u = | C

===============================================================================
class (c 'a) val C : num end
type u = | C

===============================================================================
type u 'a = 'a and t = list 'a

===============================================================================
type u 'a = 'a and t = C of 'a

===============================================================================
type u 'a = 'a and t = <| f : 'a |>

===============================================================================
type t 'a
type u 'b = t

===============================================================================
type t
type u 'b = t 'b

===============================================================================
type t 'a 'b 
type u 'b = t 'b

===============================================================================
type t = _

===============================================================================
type t = C of _

===============================================================================

(* ------------------------ Value definition tests ------------------------- *)
(* ------------------------------------------------------------------------- *)
(* ------------------------------------------------------------------------- *)

(* Has a type error, unless not using any backends (except for tex) *)
val x : num
let _ = x

===============================================================================
val x : 'a

===============================================================================
val x : forall 'a 'b 'a. num

===============================================================================
val x : _

===============================================================================
val x : forall 'a. c 'a => num

===============================================================================
class (c 'a) val f : num end
val x : forall 'a. c 'b => num

===============================================================================
val x : num
val x : num

===============================================================================
type t = |x
val x : num

===============================================================================
class (c 'a) val x : num end
val x : num

===============================================================================
let x = 10
val x : num

===============================================================================
let {hol} x = 10
val x : num

===============================================================================
let x = 1
let x = 2

===============================================================================
class (c 'a) val x : num end
let x = 1

===============================================================================
type t = |x
let x y = 1

===============================================================================
val x : num
let {hol} x = 1
let {isabelle;hol} x = 2

===============================================================================
let {hol} x = 1
let x = 2

===============================================================================
let x = 1
let rec y 1 = 1 and x 1 = 1

===============================================================================
let x = 1
indreln forall y. true ==> x y

===============================================================================
let x = 1
let inline {hol} x = 1

===============================================================================
val x : num
let inline {hol} x = 1
let inline {hol} x = 1

===============================================================================
val x : num
let {hol} x = 1
let inline {hol} x = 1

===============================================================================
val x : num
let inline {hol} x = 1
let {hol} x = 1

===============================================================================
val x : num
let {ocaml} x = 1
let _ = x

===============================================================================
val x : num
let {ocaml} x = 1
let {hol} _ = x

===============================================================================
(* TODO: should have type error
val x : num
let x = 1
let _ = x
let {hol} x = 1
*)

===============================================================================
(* ------------------------ Modules ---------------------------------------- *)
(* ------------------------------------------------------------------------- *)
(* ------------------------------------------------------------------------- *)

module X = struct let y = 1 end
module X = struct let z = 1 end

===============================================================================
module X = struct let Y = 1 end
module Y = X
module Y = X

===============================================================================
module X = struct let Y = 1 end
module Y = struct let Z = 1 end
module X = Y

===============================================================================
module X = Y

===============================================================================
open x

===============================================================================
module X = struct let X = 1 let X = 1 end

===============================================================================
module X = struct let C = 1 end
type t = | C of num
open X
let f (C 1) = 1

===============================================================================

(* --------------------------- Type classes -------------------------------- *)
(* ------------------------------------------------------------------------- *)
(* ------------------------------------------------------------------------- *)

class (c 'a) val x : 'b end

===============================================================================
class (c 'a) val x : 'a end
class (c 'a) val y : 'a end

===============================================================================
type c = num
class (c 'a) val x : 'a end

===============================================================================
class (c 'a) val x : 'a end
class (d 'a) val x : 'a end

===============================================================================
class (c 'a) val x : 'a val x : 'a end

===============================================================================
let x = 1
class (c 'a) val x : 'a end

===============================================================================
val x : num
class (c 'a) val x : 'a end

===============================================================================
type t = | x
class (c 'a) val x : 'a end

===============================================================================
class (c 'a) val x : _ end

===============================================================================

(* --------------------------- Class instances ----------------------------- *)
(* ------------------------------------------------------------------------- *)
(* ------------------------------------------------------------------------- *)

class (c 'a) val y : 'a end
instance (c num) let x = 1 end

===============================================================================
class (c 'a) val x : 'a end
module M = struct let x = 10 end
open M
instance (c num) let x = 10 end

===============================================================================
class (d 'a) val x : num end
instance (c num) let x = 1 end

===============================================================================
class (c 'a) val x : 'a val y : 'a end
instance (c num) let x = 1 end

===============================================================================
(* TODO: This should fail

class (c 'a) val x : 'a end
class (d 'a) val y : 'a end
instance (c num) let x = 1 let y = 2 end
*)

===============================================================================
class (c 'a) val x : 'a end
type t 'a = list 'a
instance (c t num) let x = [] end

===============================================================================
class (c 'a) val x : 'a end
instance (c list num) let x = [] end

===============================================================================
class (c 'a) val x : 'a end
instance (c (num*num)) let x = (1,1) end

===============================================================================
class (c 'a) val x : 'a end
instance forall 'a. c 'a => (c ('a*'a)) let x = (x,x) end

===============================================================================
class (c 'a) val x : num end
instance (c 'a) let x = 1 end

===============================================================================
class (c 'a) val x : num end
instance forall 'a. c 'b => (c 'a) let x = 1 end

===============================================================================
class (c 'a) val x : num end
instance forall 'a. d 'd => (c 'a) let x = 1 end

===============================================================================
class (c 'a) val x : num end
instance forall 'a 'b. (c 'a) let x = 1 end

===============================================================================
class (c 'a) val x : 'a end
instance (c num) let x = 1 let x = 1 end

===============================================================================
class (d 'a) val x : num end
type c = num
instance (c num) let x = 10 end

===============================================================================
class (c 'a) val x : num end
instance (c num) let {hol} x = 10 end

===============================================================================
class (c 'a) val x : num end
instance forall 'a 'a. (c 'a) let x = 10 end

===============================================================================
(* TODO : should have type error
class (c 'a) val x : 'a end
instance forall 'a. c 'a => (c 'a list) let x = x end
instance forall 'b. c 'b => (c 'b list) let x = x end
*)

===============================================================================

(* ------------------------ Class constraints ------------------------------ *)
(* ------------------------------------------------------------------------- *)
(* ------------------------------------------------------------------------- *)

class (c 'a) val x : 'a end
let _ = x::[4]

===============================================================================
(* TODO: error message should include (test.c 'a list) *)
class (c 'a) val x : 'a end
class (d 'a) val y : 'a val z : list 'a end
instance forall 'a. (d 'a) let y = x let z = x end

===============================================================================
class (c 'a) val x : 'a end
val f : num -> num
let inline {hol} f y = x

===============================================================================
class (c 'a) val x : 'a end
val f : forall 'b. 'b -> 'b
let inline {hol} f y = x

===============================================================================
class (c 'a) val x : 'a end
val f : forall 'b. c 'b => 'b -> 'b
let inline {hol} f y = x

===============================================================================
class (c 'a) val x : 'a end
class (d 'a) val y : 'a end
instance forall 'a 'b. c 'a , d 'b => (c ('a*'b)) let x = (x, y) end
val a : num
let a = match x with (a,b) -> 1 end

===============================================================================
class (c 'a) val x : 'a end
class (d 'a) val y : 'a end
instance forall 'a 'b. c 'a, d 'b => (c ('a*'b)) let x = (x, y) end
val a : forall 'a. 'a -> num
let inline {hol} a y = match x with (a,b) -> 1 end

===============================================================================

(* ------------------------ Type Mismatches -------------------------------- *)
(* ------------------------------------------------------------------------- *)
(* ------------------------------------------------------------------------- *)

let f (1 : bool) = 1

===============================================================================
type x = | X of bool
let f (X 1) = 1

===============================================================================
type t = <| fld : bool |>
let f <| fld = 1 |> = 1

===============================================================================
let f [1;true] = 1

===============================================================================
let f (1::[true]) = 1

===============================================================================
let x = true
let _ = x + 1

===============================================================================
let f (x : bool) = x + 1

===============================================================================
type t = | X
let _ = X 1 

===============================================================================
type t = | X of bool
let _ = X 1 

===============================================================================
type t = | X of bool
let _ = X true 1 

===============================================================================
let _ = fun (x : bool) -> x + 1

===============================================================================
type x = | X of bool
let _ = fun (X x) -> x + 1

===============================================================================
type x = <| fld : bool |>
let _ = fun <| fld = x |> -> x + 1

===============================================================================
let _ = function | true -> 1 | 1 -> 1 end

===============================================================================
let _ = function | _ -> 1 | _ -> true end

===============================================================================
let _ = 1 2

===============================================================================
let _ = (fun 1 -> 1) true

===============================================================================
let _ = (function | 1 -> 1 end) true

===============================================================================
let _ = (fun x -> x) 1 2

===============================================================================
let _ = true + 1


===============================================================================
type t5 [name = "nv*"] = NV of bool | NVC of int
let test17 = fun (x : t5) -> x

===============================================================================
type t5 [nme = "nv*"] = NV of bool | NVC of int

===============================================================================
type t5 = NV of bool | NVC of int
type t6 [name = "nv*"] = t5