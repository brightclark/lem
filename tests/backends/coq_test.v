(* Generated by Lem from coq_test.lem. *)

Set Implicit Args.
Require Import List.

Open Scope type_scope.

Definition num := nat.

Definition a := num.
Definition b a := a * a.
Definition c a b := a * b.

Definition d := (1 : a).
Definition e := ((1, 2) : b num).
Definition f := ((1, false) : c num bool).

Record g := { field_one : num; field_two : bool }.

Record h a := { field_three : a; field_four : bool }.
Implicit Arguments Build_h [a].
Record i a b := { field_five : a; field_six : b }.
Implicit Arguments Build_i [a b].
Record j := { field_seven : g }.


Definition k := (Build_g ( 1) ( true)  : g).
Definition l := (Build_h ( (1, true)) ( false)  : h (num * bool)).
Definition m := (Build_j ( Build_g ( 1) ( true) ) ).

Definition n(a:Type) := (Build_i ( (fun x => x)) (
           Build_h ( 1) ( true) )  :  i (a -> a) (h num)).

Inductive o := A : a -> o .

Inductive p
  := B : a -> p 
  | C : (b num) -> p 
  | D : g -> p .

Inductive q
  := E : num -> q 
  | F : i g (h a) -> q 
  | G : r -> q 
with r
  := H : q -> r .

Definition s := ((B 1) : p).
Definition t := ((G ((H ((E 1))))) : q).

Inductive bool :=
  True : bool 
| False : bool .

Inductive nat :=
  Zero : nat 
| Succ : nat -> nat .

Inductive heap a :=
  Nil : heap a
| Node : nat -> heap a -> a -> heap a -> heap a.

Inductive u a := I : a -> u a.

Inductive v a b c
  := J : a -> v a b c
  | K : b -> v a b c
  | L : (w c) -> v a b c
with w a :=
  | M : (a -> a) -> v num num num -> w a.

Inductive x a :=
  | N : y a -> x a
with y a :=
  | O : x a -> y a.
