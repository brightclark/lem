(*Generated by Lem from ../library-new/num.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_boolTheory basic_classesTheory integerTheory intReduce;

val _ = numLib.prefer_num();



val _ = new_theory "lem_num"



(*open import Bool Basic_classes*) 
(*open import {hol} `integerTheory` `intReduce`*)
(*open import {coq} `Coq.ZArith.BinInt` `Coq.ZArith.Zpower` `Coq.ZArith.Zdiv` `Coq.ZArith.Zmax`*) 

(*class inline ( Numeral 'a ) 
  val fromNumeral : numeral -> 'a 
end*)


(* ========================================================================== *)
(* Syntactic type-classes for common operations                               *)
(* ========================================================================== *)

(* Typeclasses can be used as a mean to overload constants like "+", "-", etc *)

val _ = Hol_datatype `
(*  'a *) NumNegate_class= <| 
  numNegate_method : 'a -> 'a 
|>`;


val _ = Hol_datatype `
(*  'a *) NumAdd_class= <| 
  numAdd_method : 'a -> 'a -> 'a
|>`;


val _ = Hol_datatype `
(*  'a *) NumMinus_class= <| 
  numMinus_method : 'a -> 'a -> 'a
|>`;


val _ = Hol_datatype `
(*  'a *) NumMult_class= <| 
  numMult_method : 'a -> 'a -> 'a
|>`;


val _ = Hol_datatype `
(*  'a *) NumPow_class= <| 
  numPow_method : 'a -> num -> 'a
|>`;


val _ = Hol_datatype `
(*  'a *) NumDivision_class= <| 
  numDivision_method : 'a -> 'a -> 'a
|>`;


val _ = Hol_datatype `
(*  'a *) NumIntegerDivision_class= <| 
  div_method : 'a -> 'a -> 'a
|>`;



val _ = Hol_datatype `
(*  'a *) NumRemainder_class= <| 
  mod_method : 'a -> 'a -> 'a
|>`;


val _ = Hol_datatype `
(*  'a *) NumSucc_class= <| 
  succ_method : 'a -> 'a
|>`;


val _ = Hol_datatype `
(*  'a *) NumPred_class= <| 
  pred_method : 'a -> 'a
|>`;
 


(* ----------------------- *)
(* natural                 *)
(* ----------------------- *)

(* unbounded size natural numbers *)
(*type natural*) 


(* ----------------------- *)
(* integer                 *)
(* ----------------------- *)

(* unbounded size integers *)

(*type integer*)

(* ----------------------- *)
(* bint                    *)
(* ----------------------- *)

(* 32 bit integers *)
(*type int32*) (* ???: better type for this in HOL? *)

(* 64 bit integers *)
(*type int64*) (* ???: better type for this in HOL? *)


(* ----------------------- *)
(* rational                *)
(* ----------------------- *)

(* unbounded size and precision rational numbers *)

(*type rational*) (* ???: better type for this in HOL? *)


(* ----------------------- *)
(* double                  *)
(* ----------------------- *)

(* double precision floating point (64 bits) *)

(*type float64*) (* ???: better type for this in HOL? *)

(*type float32*) (* ???: better type for this in HOL? *)

(* ========================================================================== *)
(* Translation between number types                                           *)
(* ========================================================================== *)

(*val naturalFromNat : nat -> natural*)

(*val natFromNatural : natural -> nat*)



(* ========================================================================== *)
(* Binding the standard operations for the number types                       *)
(* ========================================================================== *)


(* ----------------------- *)
(* nat                     *)
(* ----------------------- *)

val _ = Define `
 (genericCompare (less: 'a -> 'a -> bool) (equal: 'a -> 'a -> bool) (x : 'a) (y : 'a) =  
(if less x y then
    LT
  else if equal x y then
    EQ
  else
    GT))`;

;;

(*val natFromNumeral : numeral -> nat*)

(*val natEq : nat -> nat -> bool*)
val _ = Define `
(instance_Basic_classes_Eq_nat_dict =(<|

  isEqual_method := (=)|>))`;


(*val natLess : nat -> nat -> bool*)
(*val natLessEqual : nat -> nat -> bool*)
(*val natGreater : nat -> nat -> bool*)
(*val natGreaterEqual : nat -> nat -> bool*)

(*val natCompare : nat -> nat -> ordering*)

val _ = Define `
(instance_Basic_classes_Ord_nat_dict =(<|

  compare_method := (genericCompare (<) (=));

  isLess_method := (<);

  isLessEqual_method := (<=);

  isGreater_method := (>);

  isGreaterEqual_method := (>=)|>))`;



(*val natAdd : nat -> nat -> nat*)

val _ = Define `
(instance_Num_NumAdd_nat_dict =(<|

  numAdd_method := (+)|>))`;


(*val natMinus : nat -> nat -> nat*)

val _ = Define `
(instance_Num_NumMinus_nat_dict =(<|

  numMinus_method := (-)|>))`;


(*val natSucc : nat -> nat*)
(*let natSucc n = Instance_Num_NumAdd_nat.(+) n 1*)
val _ = Define `
(instance_Num_NumSucc_nat_dict =(<|

  succ_method := (SUC)|>))`;


(*val natPred : nat -> nat*)
val _ = Define `
(instance_Num_NumPred_nat_dict =(<|

  pred_method := (PRE)|>))`;


(*val natMult : nat -> nat -> nat*)

val _ = Define `
(instance_Num_NumMult_nat_dict =(<|

  numMult_method := ( * )|>))`;



(*val natPow : nat -> nat -> nat*)

val _ = Define `
(instance_Num_NumPow_nat_dict =(<|

  numPow_method := ( ** )|>))`;


(*val natDiv : nat -> nat -> nat*)

val _ = Define `
(instance_Num_NumIntegerDivision_nat_dict =(<|

  div_method := (DIV)|>))`;


val _ = Define `
(instance_Num_NumDivision_nat_dict =(<|

  numDivision_method := (DIV)|>))`;


(*val natMod : nat -> nat -> nat*)

val _ = Define `
(instance_Num_NumRemainder_nat_dict =(<|

  mod_method := (MOD)|>))`;


(*val natMin : nat -> nat -> nat*)

(*val natMax : nat -> nat -> nat*)

val _ = Define `
(instance_Basic_classes_OrdMaxMin_nat_dict =(<|

  max_method := (MAX);

  min_method := (MIN)|>))`;



(* ----------------------- *)
(* natural                 *)
(* ----------------------- *)

(*val naturalFromNumeral : numeral -> natural*)

(*val naturalEq : natural -> natural -> bool*)
val _ = Define `
(instance_Basic_classes_Eq_Num_natural_dict =(<|

  isEqual_method := (=)|>))`;


(*val naturalLess : natural -> natural -> bool*)
(*val naturalLessEqual : natural -> natural -> bool*)
(*val naturalGreater : natural -> natural -> bool*)
(*val naturalGreaterEqual : natural -> natural -> bool*)

(*val naturalCompare : natural -> natural -> ordering*)

val _ = Define `
(instance_Basic_classes_Ord_Num_natural_dict =(<|

  compare_method := (genericCompare (<) (=));

  isLess_method := (<);

  isLessEqual_method := (<=);

  isGreater_method := (>);

  isGreaterEqual_method := (>=)|>))`;



(*val naturalAdd : natural -> natural -> natural*)

val _ = Define `
(instance_Num_NumAdd_Num_natural_dict =(<|

  numAdd_method := (+)|>))`;


(*val naturalMinus : natural -> natural -> natural*)

val _ = Define `
(instance_Num_NumMinus_Num_natural_dict =(<|

  numMinus_method := (-)|>))`;


(*val naturalSucc : natural -> natural*)
(*let naturalSucc n = Instance_Num_NumAdd_Num_natural.(+) n 1*)
val _ = Define `
(instance_Num_NumSucc_Num_natural_dict =(<|

  succ_method := (SUC)|>))`;


(*val naturalPred : natural -> natural*)
val _ = Define `
(instance_Num_NumPred_Num_natural_dict =(<|

  pred_method := (PRE)|>))`;


(*val naturalMult : natural -> natural -> natural*)

val _ = Define `
(instance_Num_NumMult_Num_natural_dict =(<|

  numMult_method := ( * )|>))`;



(*val naturalPow : natural -> nat -> natural*)

val _ = Define `
(instance_Num_NumPow_Num_natural_dict =(<|

  numPow_method := ( ** )|>))`;


(*val naturalDiv : natural -> natural -> natural*)

val _ = Define `
(instance_Num_NumIntegerDivision_Num_natural_dict =(<|

  div_method := (DIV)|>))`;


val _ = Define `
(instance_Num_NumDivision_Num_natural_dict =(<|

  numDivision_method := (DIV)|>))`;


(*val naturalMod : natural -> natural -> natural*)

val _ = Define `
(instance_Num_NumRemainder_Num_natural_dict =(<|

  mod_method := (MOD)|>))`;


(*val naturalMin : natural -> natural -> natural*)

(*val naturalMax : natural -> natural -> natural*)

val _ = Define `
(instance_Basic_classes_OrdMaxMin_Num_natural_dict =(<|

  max_method := (MAX);

  min_method := (MIN)|>))`;





(* ----------------------- *)
(* integer                 *)
(* ----------------------- *)

(*val integerFromNumeral : numeral -> integer*)

(*val integerEq : integer -> integer -> bool*)
val _ = Define `
(instance_Basic_classes_Eq_Num_integer_dict =(<|

  isEqual_method := (=)|>))`;


(*val integerLess : integer -> integer -> bool*)
(*val integerLessEqual : integer -> integer -> bool*)
(*val integerGreater : integer -> integer -> bool*)
(*val integerGreaterEqual : integer -> integer -> bool*)

(*val integerCompare : integer -> integer -> ordering*)

val _ = Define `
(instance_Basic_classes_Ord_Num_integer_dict =(<|

  compare_method := (genericCompare (<) (=));

  isLess_method := (<);

  isLessEqual_method := (<=);

  isGreater_method := (>);

  isGreaterEqual_method := (>=)|>))`;




(*val integerNegate : integer -> integer*)

val _ = Define `
(instance_Num_NumNegate_Num_integer_dict =(<|

  numNegate_method :=(\ i. ~ i)|>))`;



(*val integerAdd : integer -> integer -> integer*)

val _ = Define `
(instance_Num_NumAdd_Num_integer_dict =(<|

  numAdd_method := (+)|>))`;


(*val integerMinus : integer -> integer -> integer*)

val _ = Define `
(instance_Num_NumMinus_Num_integer_dict =(<|

  numMinus_method := (-)|>))`;


(*val integerSucc : integer -> integer*)
val _ = Define `
(instance_Num_NumSucc_Num_integer_dict =(<|

  succ_method :=(\ n. n +((  1 : int)))|>))`;


(*val integerPred : integer -> integer*)
val _ = Define `
(instance_Num_NumPred_Num_integer_dict =(<|

  pred_method :=(\ n. n -((  1 : int)))|>))`;


(*val integerMult : integer -> integer -> integer*)

val _ = Define `
(instance_Num_NumMult_Num_integer_dict =(<|

  numMult_method := ( * )|>))`;



(*val integerPow : integer -> nat -> integer*)

val _ = Define `
(instance_Num_NumPow_Num_integer_dict =(<|

  numPow_method := ( ** )|>))`;


(*val integerDiv : integer -> integer -> integer*)

val _ = Define `
(instance_Num_NumIntegerDivision_Num_integer_dict =(<|

  div_method := (/)|>))`;


val _ = Define `
(instance_Num_NumDivision_Num_integer_dict =(<|

  numDivision_method := (/)|>))`;


(*val integerMod : integer -> integer -> integer*)

val _ = Define `
(instance_Num_NumRemainder_Num_integer_dict =(<|

  mod_method := (%)|>))`;


(*val integerMin : integer -> integer -> integer*)

(*val integerMax : integer -> integer -> integer*)

val _ = Define `
(instance_Basic_classes_OrdMaxMin_Num_integer_dict =(<|

  max_method := (int_max);

  min_method := (int_min)|>))`;

val _ = export_theory()

