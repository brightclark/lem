(*Generated by Lem from ../library-new/list_extra.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_boolTheory optionTheory basic_classesTheory integerTheory intReduce lem_numTheory listTheory rich_listTheory lem_listTheory sortingTheory;

val _ = numLib.prefer_num();



val _ = new_theory "lem_list_extra"



(*open import Bool Maybe Basic_classes Tuple Num*) 
(*include import List*)

(* ------------------------- *)
(* head of non-empty list    *)
(* ------------------------- *)
(*val head : forall 'a. list 'a -> 'a*)
(*let head l = match l with | x::xs -> x end*)


(* ------------------------- *)
(* tail of non-empty list    *)
(* ------------------------- *)
(*val tail : forall 'a. list 'a -> list 'a*)
(*let tail l = match l with | x::xs -> xs end*)


(* ------------------------- *)
(* last                      *)
(* ------------------------- *)
(*val last : forall 'a. list 'a -> 'a*)
(*let rec last l = match l with | [x] -> x | x1::x2::xs -> last (x2 :: xs) end*)


(* ------------------------- *)
(* init                      *)
(* ------------------------- *)

(* All elements of a non-empty list except the last one. *)
(*val init : forall 'a. list 'a -> list 'a*)
(*let rec init l = match l with | [x] -> [] | x1::x2::xs -> x1::(init (x2::xs)) end*)


(* ------------------------- *)
(* foldl1 / foldr1           *)
(* ------------------------- *)

(* folding functions for non-empty lists,
    which don`t take the base case *)
(*val foldl1 : forall 'a. ('a -> 'a -> 'a) -> list 'a -> 'a*)
val _ = Define `
 (foldl1 f (x :: xs) = ((FOLDL f x xs)))`;


(*val foldr1 : forall 'a. ('a -> 'a -> 'a) -> list 'a -> 'a*)
val _ = Define `
 (foldr1 f (x :: xs) = ((FOLDR f x xs)))`;


  
(* ------------------------- *)
(* nth element               *)
(* ------------------------- *)

(* get the nth element of a list *)
(*val nth : forall 'a. list 'a -> nat -> 'a*)
(*let nth l n = match index l n with Just e -> e end*)


(* ------------------------- *)
(* Find_non_pure             *)
(* ------------------------- *)
(*val find_non_pure : forall 'a. ('a -> bool) -> list 'a -> 'a*) 
val _ = Define `
 (find_non_pure P l = ((case (list_find_opt P l) of 
    (SOME e)      => e
)))`;


val _ = export_theory()

