(*Generated by Lem from ../library-new/set.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_boolTheory basic_classesTheory optionTheory lem_functionTheory integerTheory intReduce lem_numTheory;

val _ = numLib.prefer_num();



val _ = new_theory "lem_set"

(******************************************************************************)
(* A library for sets                                                         *)
(*                                                                            *)
(* It mainly follows the Haskell Set-library                                  *)
(******************************************************************************)

(* Sets in Lem are a bit tricky. On the one hand, we want efficiently executable sets.
   OCaml and Haskell both represent sets by some kind of balancing trees. This means
   that sets are finite and an order on the elemet type is required. 
   Such sets are constructed by simple, executable operations like inserting or
   deleting elements, union, intersection, filtering etc.

   On the other hand, we want to use sets for specifications. This leads often
   infinite sets, which are specificied in complicated, perhaps even undecidable
   ways.

   The set library in this file, chooses the first approach. It describes 
   *finite* sets with an underlying order. Infinite sets should in the medium
   run be represented by a separate type. Since this would require some significant
   changes to Lem, for the moment also infinite sets are represented using this
   class. However, a run-time exception might occour when using these sets. 
   This problem needs adressing in the future. *)
   

(* ========================================================================== *)
(* Header                                                                     *)
(* ========================================================================== *)

(*open import Bool Basic_classes Maybe Function Num Set_helpers*)

(* DPM: sets currently implemented as lists due to mismatch between Coq type
 * class hierarchy and the hierarchy implemented in Lem.
 *)
(*open import {coq} `Coq.Lists.TheoryList`*)

(* Type of sets and set comprehensions are hard-coded *)

(* ----------------------- *)
(* Equality check          *)
(* ----------------------- *)

(*val setEqual : forall 'a. Ord 'a => set 'a -> set 'a -> bool*)

val _ = Define `
(instance_Basic_classes_Eq_set_dict dict_Basic_classes_Ord_a =(<|

  isEqual_method := (=)|>))`;



(* ----------------------- *)
(* Empty set               *)
(* ----------------------- *)

(*val empty : forall 'a. Ord 'a => set 'a*) 
(*val emptyBy : forall 'a. ('a -> 'a -> ordering) -> set 'a*)

(* ----------------------- *)
(* any / all               *)
(* ----------------------- *)

(*val any : forall 'a. ('a -> bool) -> set 'a -> bool*)

(*val all : forall 'a. ('a -> bool) -> set 'a -> bool*)


(* ----------------------- *)
(* (IN)                    *)
(* ----------------------- *)

(*val IN [`member`] : forall 'a. Ord 'a, Eq 'a => 'a -> set 'a -> bool*) 
(*val memberBy : forall 'a. ('a -> 'a -> bool) -> 'a -> set 'a -> bool*) 
val _ = Define `
 (memberBy eq e s = ((EXISTS  (eq e) (SET_TO_LIST  s))))`;


(* ----------------------- *)
(* not (IN)                *)
(* ----------------------- *)

(*val NIN [`notMember`] : forall 'a. Ord 'a, Eq 'a => 'a -> set 'a -> bool*)


(* ----------------------- *)
(* insert                  *)
(* ----------------------- *)

(*val insert : forall 'a. Ord 'a => 'a -> set 'a -> set 'a*)


(* ----------------------- *)
(* Emptyness check         *)
(* ----------------------- *)

(*val null : forall 'a. Ord 'a => set 'a -> bool*)


(* ------------------------ *)
(* singleton                *)
(* ------------------------ *)

(*val singleton : forall 'a. Ord 'a => 'a -> set 'a*)


(* ----------------------- *)
(* size                    *)
(* ----------------------- *)

(*val size : forall 'a. Ord 'a => set 'a -> nat*)


(* ----------------------------*)
(* setting up pattern matching *)
(* --------------------------- *)

(*val set_case : forall 'a 'b. Ord 'a => set 'a -> 'b -> ('a -> 'b) -> 'b -> 'b*)


(* ----------------------- *)
(* filter                  *)
(* ----------------------- *)

(*val filter : forall 'a. ('a -> bool) -> set 'a -> set 'a*) 
val _ = Define `
 (filter P s = 
  ({e | e | (e IN s) /\ P e}))`;



(* ----------------------- *)
(* partition               *)
(* ----------------------- *)

(*val partition : forall 'a. ('a -> bool) -> set 'a -> set 'a * set 'a*)
val _ = Define `
 (partition0 P s = (filter P s, filter (\ e . (~ (P e))) s))`;



(* ----------------------- *)
(* split                   *)
(* ----------------------- *)

(*val split : forall 'a. Ord 'a => 'a -> set 'a -> set 'a * set 'a*)
val _ = Define `
 (split dict_Basic_classes_Ord_a p s = (filter (
  dict_Basic_classes_Ord_a.isLess_method p) s, filter (dict_Basic_classes_Ord_a.isGreater_method p) s))`;


(*val splitMember : forall 'a. Ord 'a, Eq 'a => 'a -> set 'a -> set 'a * bool * set 'a*)
val _ = Define `
 (splitMember dict_Basic_classes_Ord_a dict_Basic_classes_Eq_a p s = (filter (
  dict_Basic_classes_Ord_a.isLess_method p) s, (p IN s), filter (
  dict_Basic_classes_Ord_a.isGreater_method p) s))`;



(* ------------------------ *)
(* subset and proper subset *)
(* ------------------------ *)

(*val isSubsetOfBy : forall 'a. ('a -> 'a -> bool) -> set 'a -> set 'a -> bool*)
val _ = Define `
 (isSubsetOfBy eq s1 s2 = ((EVERY  (\ e1 . (EXISTS  (eq e1) (SET_TO_LIST  s2))) (SET_TO_LIST  s1))))`;


(*val isProperSubsetOfBy : forall 'a. ('a -> 'a -> bool) -> set 'a -> set 'a -> bool*)
val _ = Define `
 (isProperSubsetOfBy eq s1 s2 = (isSubsetOfBy eq s1 s2 /\ (~ (isSubsetOfBy eq s2 s1))))`;


(*val isSubsetOf : forall 'a. Ord 'a, Eq 'a => set 'a -> set 'a -> bool*)

(*val isProperSubsetOf : forall 'a. Ord 'a, Eq 'a => set 'a -> set 'a -> bool*)


(* ------------------------ *)
(* delete                   *)
(* ------------------------ *)

(*val delete : forall 'a. Ord 'a, Eq 'a => 'a -> set 'a -> set 'a*)
(*val deleteBy : forall 'a. ('a -> 'a -> bool) -> 'a -> set 'a -> set 'a*)

val _ = Define `
 (deleteBy eq e s = (filter (\ e2 . (~ (eq e e2))) s))`;



(* ------------------------ *)
(* union                    *)
(* ------------------------ *)

(*val union : forall 'a. Ord 'a => set 'a -> set 'a -> set 'a*)


(* ------------------------ *)
(* difference               *)
(* ------------------------ *)

(*val difference : forall 'a. Ord 'a => set 'a -> set 'a -> set 'a*)

(* ------------------------ *)
(* intersection             *)
(* ------------------------ *)

(*val intersection : forall 'a. Ord 'a, Eq 'a => set 'a -> set 'a -> set 'a*)
(*val intersectionBy : forall 'a. ('a -> 'a -> bool) -> set 'a -> set 'a -> set 'a*)


(* ------------------------ *)
(* map                      *)
(* ------------------------ *)

(*val map : forall 'a 'b. Ord 'a, Ord 'b => ('a -> 'b) -> set 'a -> set 'b*) (* before image *)
(*let map f s = { f e | forall (e IN s) | true }*)

(*val mapBy : forall 'a 'b. ('b -> 'b -> ordering) -> ('a -> 'b) -> set 'a -> set 'b*) 


(* ------------------------ *)
(* min and max              *)
(* ------------------------ *)

(*val findMin : forall 'a.  Ord 'a, Eq 'a => set 'a -> maybe 'a*) 
(*val findMax : forall 'a.  Ord 'a, Eq 'a => set 'a -> maybe 'a*) 



(* ------------------------ *)
(* fromList                 *)
(* ------------------------ *)

(*val fromList : forall 'a.  Ord 'a => list 'a -> set 'a*) (* before from_list *)
(*val fromListBy : forall 'a.  ('a -> 'a -> ordering) ->  list 'a -> set 'a*) 


(* ------------------------ *)
(* Sigma                    *)
(* ------------------------ *)

(*val sigma : forall 'a 'b. Ord 'a, Ord 'b, Eq 'a, Eq 'b => set 'a -> ('a -> set 'b) -> set ('a * 'b)*)
(*val sigmaBy : forall 'a 'b. (('a * 'b) -> ('a * 'b) -> ordering) -> set 'a -> ('a -> set 'b) -> set ('a * 'b)*)

val _ = Define `
 (sigma dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b dict_Basic_classes_Eq_a dict_Basic_classes_Eq_b sa sb = 
  ({ (a, b) | a,b | (a IN sa) /\ (b IN sb a) }))`;



(* ------------------------ *)
(* cross product            *)
(* ------------------------ *)

(*val cross : forall 'a 'b. Ord 'a, Ord 'b => set 'a -> set 'b -> set ('a * 'b)*)
(*val crossBy : forall 'a 'b. (('a * 'b) -> ('a * 'b) -> ordering) -> set 'a -> set 'b -> set ('a * 'b)*)

(*let cross s1 s2 = { (e1, e2) | forall (e1 IN s1) (e2 IN s2) | true }*)


(* ------------------------ *)
(* finite                   *)
(* ------------------------ *)

(*val finite : forall 'a. Ord 'a => set 'a -> bool*)


(* ------------------------ *)
(* finite                   *)
(* ------------------------ *)


(* NOT DONE AFTER THIS POINT, PLEASE IGNORE 

val to_list : forall 'a. set 'a -> list 'a
let inline {ocaml} to_list = Ocaml.Pset.elements
let inline {hol} to_list = Hol.SET_TO_LIST
let inline {coq} to_list = Coq.set_to_list
let inline {isabelle} to_list = Isabelle.list_of_set

val compare: forall 'a. set 'a -> set 'a -> nat
let inline {coq} compare = Coq.set_compare

(* least fix point. The operation 
   lfp s f applies to f and gets a set s`.
   If s` contains new elements they are added to s and
   the process repeats. Otherwise s is returned.
*)
val monotone : forall 'a. (set 'a -> set 'a) -> bool
let inline {coq} monotone f = (forall s1 s2. s1 subset s2 --> f s1 subset f s2)
let inline {isabelle} monotone = Isabelle.mono
let inline {hol} monotone = Hol.monotone

val lfp : forall 'a. set 'a -> (set 'a -> set 'a) -> set 'a
let inline {ocaml} lfp = Ocaml.Pset.lfp
let inline {isabelle} lfp = Isabelle.set_lfp
let inline {hol} lfp s f = Hol.lfp (fun s` -> f s` union s)





skipped

lookupLT :: Ord a => a -> Set a -> Maybe aSource
lookupGT :: Ord a => a -> Set a -> Maybe aSource
lookupLE :: Ord a => a -> Set a -> Maybe aSource
lookupGE :: Ord a => a -> Set a -> Maybe aSource

lookupIndex :: Ord a => a -> Set a -> Maybe IntSource
findIndex :: Ord a => a -> Set a -> IntSource
elemAt :: Int -> Set a -> aSource
deleteAt :: Int -> Set a -> Set a
mapMonotonic :: (a -> b) -> Set a -> Set b


*)
val _ = export_theory()

