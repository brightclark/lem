(*Generated by Lem from ../library-new/sorting.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_boolTheory basic_classesTheory optionTheory listTheory rich_listTheory lem_listTheory lem_numTheory sortingTheory integerTheory intReduce;

val _ = numLib.prefer_num();



val _ = new_theory "lem_sorting"



(*open import Bool Basic_classes Maybe List Num*)

(*open import {isabelle} `~~/src/HOL/Library/Permutation`*)
(*open import {coq} `Coq.Lists.TheoryList`*)

(* ------------------------- *)
(* permutations              *)
(* ------------------------- *)

(*val isPermutation : forall 'a. Eq 'a => list 'a -> list 'a -> bool*)
(*val isPermutationBy : forall 'a. ('a -> 'a -> bool) -> list 'a -> list 'a -> bool*)

 val _ = Define `
 (isPermutationBy eq l1 l2 = ((case l1 of
    [] => (NULL l2)
  | (x :: xs) => (
      (case list_delete_first (eq x) l2 of
          (NONE) => F
        | (SOME ys) => isPermutationBy eq xs ys
      )
    )
)))`;


val _ = Define `
 (isPermutation dict_Basic_classes_Eq_a = (isPermutationBy (=)))`;




(* ------------------------- *)
(* isSorted                  *)
(* ------------------------- *)

(* isSortedBy R l 
   checks, whether the list l is sorted by ordering R. 
   R should represent an order, i.e. it should be transitive.
   Different backends defined "isSorted" slightly differently. However,
   the definitions coincide for transitive R. Therefore there is the
   following restriction:

   WARNING: Use isSorted and isSortedBy only with transitive relations!
*)

(*val isSorted : forall 'a. Ord 'a => list 'a -> bool*)
(*val isSortedBy : forall 'a. ('a -> 'a -> bool) -> list 'a -> bool*)

(* DPM: rejigged the definition with a nested match to get past Coq's termination checker. *)
 val _ = Define `
 (isSortedBy cmp l = ((case l of
    [] => T
  | x1 :: xs =>
    (case xs of
        [] => T
      | x2 :: _ => (cmp x1 x2 /\ isSortedBy cmp xs)
    )
)))`;



(* ----------------------- *)
(* insertion sort          *)
(* ----------------------- *) 

(*val insert : forall 'a. Ord 'a => 'a -> list 'a -> list 'a*)
(*val insertBy : forall 'a. ('a -> 'a -> bool) -> 'a -> list 'a -> list 'a*)

(*val insertSort: forall 'a. Ord 'a => list 'a -> list 'a*)
(*val insertSortBy: forall 'a. ('a -> 'a -> bool) -> list 'a -> list 'a*)

 val _ = Define `
 (insertBy cmp e l = ((case l of
    [] => [e]
  | x :: xs => if cmp x e then x :: (insertBy cmp e xs) else (e :: (x :: xs))
)))`;


val _ = Define `
 (insert dict_Basic_classes_Ord_a = (insertBy  
  dict_Basic_classes_Ord_a.isLessEqual_method))`;


val _ = Define `
 (insertSortBy cmp l = ((FOLDL (\ l e . insertBy cmp e l) [] l)))`;

val _ = Define `
 (insertSort dict_Basic_classes_Ord_a = (insertSortBy  
  dict_Basic_classes_Ord_a.isLessEqual_method))`;



(* ----------------------- *)
(* general sorting         *)
(* ----------------------- *) 

(*val sort: forall 'a. Ord 'a => list 'a -> list 'a*)
(*val sortBy: forall 'a. ('a -> 'a -> bool) -> list 'a -> list 'a*)


val _ = export_theory()

