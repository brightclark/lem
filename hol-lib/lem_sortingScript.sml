(*Generated by Lem from ../library-new/sorting.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_boolTheory basic_classesTheory optionTheory listTheory rich_listTheory lem_listTheory lem_numTheory sortingTheory integerTheory intReduce permLib;

val _ = numLib.prefer_num();



val _ = new_theory "lem_sorting"



(*open import Bool Basic_classes Maybe List Num*)

(*open import {isabelle} `~~/src/HOL/Library/Permutation`*)
(*open import {coq} `Coq.Lists.TheoryList`*)
(*open import {hol} `sortingTheory` `permLib`*)

(* ------------------------- *)
(* permutations              *)
(* ------------------------- *)

(*val isPermutation : forall 'a. Eq 'a => list 'a -> list 'a -> bool*)
(*val isPermutationBy : forall 'a. ('a -> 'a -> bool) -> list 'a -> list 'a -> bool*)

 val _ = Define `
 (PERM_BY eq l1 l2 = ((case l1 of
    [] => (NULL l2)
  | (x :: xs) => (
      (case list_delete_first (eq x) l2 of
          (NONE) => F
        | (SOME ys) => PERM_BY eq xs ys
      )
    )
)))`;




(* ------------------------- *)
(* isSorted                  *)
(* ------------------------- *)

(* isSortedBy R l 
   checks, whether the list l is sorted by ordering R. 
   R should represent an order, i.e. it should be transitive.
   Different backends defined "isSorted" slightly differently. However,
   the definitions coincide for transitive R. Therefore there is the
   following restriction:

   WARNING: Use isSorted and isSortedBy only with transitive relations!
*)

(*val isSorted : forall 'a. Ord 'a => list 'a -> bool*)
(*val isSortedBy : forall 'a. ('a -> 'a -> bool) -> list 'a -> bool*)

(* DPM: rejigged the definition with a nested match to get past Coq's termination checker. *)
(*let rec isSortedBy cmp l = match l with
  | [] -> true
  | x1 :: xs ->
    match xs with
      | [] -> true
      | x2 :: _ -> (cmp x1 x2 && isSortedBy cmp xs)
    end
end*)


(* ----------------------- *)
(* insertion sort          *)
(* ----------------------- *) 

(*val insert : forall 'a. Ord 'a => 'a -> list 'a -> list 'a*)
(*val insertBy : forall 'a. ('a -> 'a -> bool) -> 'a -> list 'a -> list 'a*)

(*val insertSort: forall 'a. Ord 'a => list 'a -> list 'a*)
(*val insertSortBy: forall 'a. ('a -> 'a -> bool) -> list 'a -> list 'a*)

 val _ = Define `
 (INSERT_SORT_INSERT cmp e l = ((case l of
    [] => [e]
  | x :: xs => if cmp x e then x :: (INSERT_SORT_INSERT cmp e xs) else (e :: (x :: xs))
)))`;


val _ = Define `
 (INSERT_SORT cmp l = ((FOLDL (\ l e . INSERT_SORT_INSERT cmp e l) [] l)))`;



(* ----------------------- *)
(* general sorting         *)
(* ----------------------- *) 

(*val sort: forall 'a. Ord 'a => list 'a -> list 'a*)
(*val sortBy: forall 'a. ('a -> 'a -> bool) -> list 'a -> list 'a*)


val _ = export_theory()

