(*Generated by Lem from ../library-new/basic_classes.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_boolTheory;

val _ = numLib.prefer_num();



val _ = new_theory "basic_classes"

(******************************************************************************)
(* Basic Type Classes                                                         *)
(******************************************************************************)

(*open import Bool*)

(* ========================================================================== *)
(* Equality                                                                   *)
(* ========================================================================== *)

(* Lem`s default equality (=) is defined by the following type-class Eq.
   This typeclass should define equality on an abstract datatype 'a. It should
   always coincide with the default equality of Coq, HOL and Isabelle.
   For OCaml, it might be different, since abstract datatypes like sets
   might have fancy equalities. *)

val _ = Hol_datatype `
(*  'a *) Eq_class= <| 
  isEqual_method : 'a -> 'a -> bool
|>`;


val _ = Hol_datatype `
(*  'a *) Ineq_class= <| 
  isInequal_method : 'a -> 'a -> bool
|>`;



(* (=) should for all instances be an equivalence relation 
   The isEquivalence predicate of relations could be used here.
   However, this would lead to a cyclic dependency. *)

(* TODO: add later, once lemmata can be assigned to classes 
lemma eq_equiv: ((forall x. (x = x)) &&
                 (forall x y. (x = y) <-> (y = x)) &&
                 (forall x y z. ((x = y) && (y = z)) --> (x = z)))
*)

(* Structural equality *)

(* Sometimes, it is also handy to be able to use structural equality.
   This equality is mapped to the build-in equality of backends. This equality
   differs significantly for each backend. For example, OCaml can`t check equality
   of function types, whereas HOL can.  When using structural equality, one should 
   know what one is doing. The only guarentee is that is behaves like 
   the native backend equality.

   A lengthy name for structural equality is used to discourage its direct use.
   It also ensures that users realise it is unsafe (e.g. OCaml can`t check two functions
   for equality *)
(*val unsafe_structural_equality : forall 'a. 'a -> 'a -> bool*)

(*val unsafe_structural_inequality : forall 'a. 'a -> 'a -> bool*)
val _ = Define `
 (unsafe_structural_inequality x y = ((~ ( x= y))))`;



(* ========================================================================== *)
(* Orderings                                                                  *)
(* ========================================================================== *)

(* The type-class Ord represents total orders (also called linear orders) *)
val _ = Hol_datatype `
 ordering = LT | EQ | GT`;


val _ = Define `
 (orderingIsLess r    = ((case r of LT => T | _ => F )))`;

val _ = Define `
 (orderingIsGreater r = ((case r of GT => T | _ => F )))`;

val _ = Define `
 (orderingIsEqual r   = ((case r of EQ => T | _ => F )))`;


val _ = Define `
 (ordering_cases r lt eq gt =  
(if orderingIsLess r then lt else
  if orderingIsEqual r then eq else gt))`;



(*val orderingEqual : ordering -> ordering -> bool*)

val _ = Define `
(instance_Basic_classes_Eq_Basic_classes_ordering_dict =(<|

  isEqual_method := (=)|>))`;


val _ = Hol_datatype `
(*  'a *) Ord_class= <| 
  compare_method                 : 'a -> 'a -> ordering;
  isLess_method         : 'a -> 'a -> bool;
  isLessEqual_method    : 'a -> 'a -> bool;
  isGreater_method      : 'a -> 'a -> bool;
  isGreaterEqual_method : 'a -> 'a -> bool 
|>`;



(* Ocaml provides default, polymorphic compare functions. Let's use them
   as the default. However, because used in a typeclass they must be 
   defined for all targets. So, use a dummy instantiation for other tragets *)
(*val defaultCompare   : forall 'a. 'a -> 'a -> ordering*)
(*val defaultLess      : forall 'a. 'a -> 'a -> bool*)
(*val defaultLessEq    : forall 'a. 'a -> 'a -> bool*)
(*val defaultGreater   : forall 'a. 'a -> 'a -> bool*)
(*val defaultGreaterEq : forall 'a. 'a -> 'a -> bool*)


(* TODO: add later 
lemma isLess_alt_def        : (forall x y. (x < y) = (let r = compare x y in (r = LT || r = EQ)))
lemma isLessEqual_alt_def   : (forall x y. (x <= y) = (compare x y = LT))
lemma isGreater_alt_def     : (forall x y. (x > y) = (y < x))
lemma isGreaterEqual_alt_def: (forall x y. (x >= y) = (y <= x))

(* compare should really be a total order *)
lemma ord_OK_1: (
  (forall x y. (compare x y = EQ) <-> (compare y x = EQ)) &&
  (forall x y. (compare x y = LT) <-> (compare y x = GT)))

lemma ord_OK_2: (
  (forall x y z. (x <= y) && (y <= z) --> (x <= z)) &&
  (forall x y. (x <= y) || (y <= x))
)
*)

(* let's derive a compare function from the Ord type-class *)
(*val ordCompare : forall 'a. Eq 'a, Ord 'a => 'a -> 'a -> ordering*)
val _ = Define `
 (ordCompare dict_Basic_classes_Eq_a dict_Basic_classes_Ord_a x y =  
(if ( dict_Basic_classes_Ord_a.isLess_method x y) then LT else
  if (x = y) then EQ else GT))`;


val _ = Hol_datatype `
(*  'a *) OrdMaxMin_class= <| 
  max_method : 'a -> 'a -> 'a;
  min_method : 'a -> 'a -> 'a
|>`;


(*val defaultMin : forall 'a. Ord 'a => 'a -> 'a -> 'a*)
val _ = Define `
 (defaultMin dict_Basic_classes_Ord_a x y = (if ( 
  dict_Basic_classes_Ord_a.isLessEqual_method x y) then x else y))`;


(*val defaultMax : forall 'a. Ord 'a => 'a -> 'a -> 'a*)
val _ = Define `
 (defaultMax dict_Basic_classes_Ord_a x y = (if ( 
  dict_Basic_classes_Ord_a.isLessEqual_method y x) then x else y))`;



(* ========================================================================== *)
(* Instantiations                                                             *)
(* ========================================================================== *)

val _ = Define `
(instance_Basic_classes_Eq_bool_dict =(<|

  isEqual_method := (<=>)|>))`;


val _ = Define `
 (boolCompare b1 b2 = ((case (b1, b2) of
    (T, T) => EQ
  | (T, F) => GT
  | (F, T) => LT
  | (F, F) => EQ
)))`;


val _ = Define `
(instance_Basic_classes_Ord_bool_dict =(<|

  compare_method := boolCompare;

  isLess_method :=(\ x y. ((~ x) /\ y));

  isLessEqual_method :=(\ x y. (x ==> y));

  isGreater_method :=(\ x y. ((~ y) /\ x));

  isGreaterEqual_method :=(\ x y. (y ==> x))|>))`;


(*val pairEqual : forall 'a 'b. Eq 'a, Eq 'b => ('a * 'b) -> ('a * 'b) -> bool*)
(*let pairEqual (a1, b1) (a2, b2) = (a1 = a2) && (b1 = b2)*)

(*val pairEqualBy : forall 'a 'b. ('a -> 'a -> bool) -> ('b -> 'b -> bool) -> ('a * 'b) -> ('a * 'b) -> bool*)

val _ = Define `
(instance_Basic_classes_Eq_tup_dict dict_Basic_classes_Eq_a dict_Basic_classes_Eq_b =(<|

  isEqual_method := (=)|>))`;


val _ = Define `
 (pairCompare dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b (a1, b1) (a2, b2) =  
((case  dict_Basic_classes_Ord_b.compare_method a1 a2 of
      LT => LT
    | GT => GT
    | EQ => dict_Basic_classes_Ord_a.compare_method b1 b2
  )))`;


val _ = Define `
 (pairLess dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b (x1, x2) (y1, y2) = (( 
  dict_Basic_classes_Ord_b.isLess_method x1 y1) \/ (( dict_Basic_classes_Ord_b.isLessEqual_method x1 y1) /\ ( dict_Basic_classes_Ord_a.isLess_method x2 y2))))`;

val _ = Define `
 (pairLessEq dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b (x1, x2) (y1, y2) = (( 
  dict_Basic_classes_Ord_b.isLess_method x1 y1) \/ (( dict_Basic_classes_Ord_b.isLessEqual_method x1 y1) /\ ( dict_Basic_classes_Ord_a.isLess_method x2 y2))))`;


val _ = Define `
 (pairGreater dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b x12 y12 = (pairLess 
  dict_Basic_classes_Ord_b dict_Basic_classes_Ord_a y12 x12))`;

val _ = Define `
 (pairGreaterEq dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b x12 y12 = (pairLessEq 
  dict_Basic_classes_Ord_b dict_Basic_classes_Ord_a y12 x12))`;


val _ = Define `
(instance_Basic_classes_Ord_tup_dict dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b =(<|

  compare_method := 
  (pairCompare dict_Basic_classes_Ord_b dict_Basic_classes_Ord_a);

  isLess_method := 
  (pairLess dict_Basic_classes_Ord_b dict_Basic_classes_Ord_a);

  isLessEqual_method := 
  (pairLessEq dict_Basic_classes_Ord_b dict_Basic_classes_Ord_a);

  isGreater_method := 
  (pairGreater dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b);

  isGreaterEqual_method := 
  (pairGreaterEq dict_Basic_classes_Ord_a dict_Basic_classes_Ord_b)|>))`;

val _ = export_theory()

