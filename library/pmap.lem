(* TODO: This is not the right type *)
type map 'a 'b = Hol.Finite_map.fmap 'a 'b

val empty : forall 'a 'b. map 'a 'b
let inline {hol} empty = Hol.FEMPTY
let inline {isabelle} empty = (Isabelle.Map.empty)
let inline {ocaml} empty = (Ocaml.Pmap.empty Ocaml.Pervasives.compare)
let inline {coq} empty = Coq.map_empty

val add : forall 'key 'a. 'key -> 'a -> map 'key 'a -> map 'key 'a
let inline {hol} add k a m = Hol.FUPDATE m (k,a)
let inline {ocaml} add = Ocaml.Pmap.add
let inline {isabelle} add = Isabelle.map_update
let inline {coq} add = Coq.map_add

val mem : forall 'key 'a. 'key -> map 'key 'a -> bool
let inline {hol} mem k m = k IN Hol.FDOM m
let inline {ocaml} mem = Ocaml.Pmap.mem
let inline {isabelle} mem k m = k IN Isabelle.dom m
let inline {coq} mem = Coq.map_mem Coq.(==)

val find : forall 'key 'a. 'key -> map 'key 'a -> 'a
let inline {hol} find k m = Hol.FAPPLY m k
let inline {isabelle} find = Isabelle.map_find
let inline {ocaml} find = Ocaml.Pmap.find
let inline {coq} find = Coq.map_find Coq.(==)

val for_all : forall 'key 'a. ('key -> 'a -> bool) -> map 'key 'a -> bool
let inline {ocaml} for_all = Ocaml.Pmap.for_all

val exist : forall 'key 'a. ('key -> 'a -> bool) -> map 'key 'a -> bool
let inline {ocaml} exist = Ocaml.Pmap.exist

val map : forall 'key 'a 'b. ('a -> 'b) -> map 'key 'a -> map 'key 'b
let inline {ocaml} map = Ocaml.Pmap.map

val remove: forall 'key 'a. 'key -> map 'key 'a -> map 'key 'a
let inline {ocaml} remove = Ocaml.Pmap.remove
let inline {isabelle} remove = Isabelle.map_remove

val bindings: forall 'key 'a. map 'key 'a -> list ('key * 'a)
let inline {ocaml} bindings = Ocaml.Pmap.bindings

val domain: forall 'key 'a. map 'key 'a -> set 'key
let inline {ocaml} domain = Ocaml.Pmap.domain
let inline {isabelle} domain = Isabelle.Map.dom

val range: forall 'key 'a. map 'key 'a -> set 'a
let inline {ocaml} range = Ocaml.Pmap.range
let inline {isabelle} range = Isabelle.Map.ran
