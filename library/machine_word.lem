(*******************************************************************)
(* A new machine word library, suitable for targetting from Sail,  *)
(* and a thin wrapper around the HOL and Isabelle word libraries.  *)
(*******************************************************************)

declare {isabelle;coq;hol;ocaml} rename module = Lem_machine_word

open import Bool Num Basic_classes

open import {isabelle} `~~/src/HOL/Word/Word`
open import {hol} `wordsTheory` `wordsLib`

type mword 'a

type mword1
type mword2
type mword3
type mword4
type mword5
type mword6
type mword7
type mword8
type mword16
type mword32
type mword64
type mword128
type mword256

declare isabelle target_rep type mword 'a = `word` 'a
declare hol      target_rep type mword 'a = `word` 'a

declare isabelle target_rep type mword1   = `1` `word`
declare isabelle target_rep type mword2   = `2` `word`
declare isabelle target_rep type mword3   = `3` `word`
declare isabelle target_rep type mword4   = `4` `word`
declare isabelle target_rep type mword5   = `5` `word`
declare isabelle target_rep type mword6   = `6` `word`
declare isabelle target_rep type mword7   = `7` `word`
declare isabelle target_rep type mword8   = `8` `word`
declare isabelle target_rep type mword16  = `16` `word`
declare isabelle target_rep type mword32  = `32` `word`
declare isabelle target_rep type mword64  = `64` `word`
declare isabelle target_rep type mword128 = `128` `word`
declare isabelle target_rep type mword256 = `256` `word`

declare hol target_rep type mword1   = `1` `word`
declare hol target_rep type mword2   = `2` `word`
declare hol target_rep type mword3   = `3` `word`
declare hol target_rep type mword4   = `4` `word`
declare hol target_rep type mword5   = `5` `word`
declare hol target_rep type mword6   = `6` `word`
declare hol target_rep type mword7   = `7` `word`
declare hol target_rep type mword8   = `8` `word`
declare hol target_rep type mword16  = `16` `word`
declare hol target_rep type mword32  = `32` `word`
declare hol target_rep type mword64  = `64` `word`
declare hol target_rep type mword128 = `128` `word`
declare hol target_rep type mword256 = `256` `word`

(******************************************************************)
(* Comparisons                                                    *)
(******************************************************************)

val mwordEq : forall 'a. mword 'a -> mword 'a -> bool
let inline mwordEq = unsafe_structural_equality

instance forall 'a. (Eq (mword 'a))
  let (=)        = mwordEq
  let (<>) w1 w2 = not (mwordEq w1 w2)
end

val signedLess : forall 'a. mword 'a -> mword 'a -> bool

declare isabelle target_rep function signedLess = `word_sless`

val signedLessEq : forall 'a. mword 'a -> mword 'a -> bool

declare isabelle target_rep function signedLessEq = `word_sle`

val unsignedLess : forall 'a. mword 'a -> mword 'a -> bool

declare isabelle target_rep function unsignedLess = `ord_word_inst.less_word`

val unsignedLessEq : forall 'a. mword 'a -> mword 'a -> bool

declare isabelle target_rep function unsignedLessEq = `ord_word_inst.less_eq_word`

(******************************************************************)
(* Appending, splitting and probing words                         *)
(******************************************************************)

val wordCat : forall 'a 'b 'c. mword 'a -> mword 'b -> mword 'c

declare isabelle target_rep function wordCat = `word_cat`

val wordSplit : forall 'a 'b 'c. mword 'a -> mword 'b * mword 'c

declare isabelle target_rep function wordSplit = `word_split`

val setBit : forall 'a. mword 'a -> natural -> bool -> mword 'a

declare isabelle target_rep function setBit = `bits_word_inst.set_bit_word`

val getBit : forall 'a. mword 'a -> natural -> bool

declare isabelle target_rep function getBit = `bits_word_inst.test_bit_word`

val msb : forall 'a. mword 'a -> bool

declare isabelle target_rep function msb = `bitss_word_inst.msb_word`

val lsb : forall 'a. mword 'a -> bool

declare isabelle target_rep function lsb = `bits_word_inst.lsb_word`


(******************************************************************)
(* Conversions                                                    *)
(******************************************************************)

val signedIntegerFromWord : forall 'a. mword 'a -> integer

declare isabelle target_rep function signedIntegerFromWord = `sint`

val unsignedIntegerFromWord : forall 'a. mword 'a -> integer

declare isabelle target_rep function unsignedIntegerFromWord = `uint`

val wordFromInteger : forall 'a. integer -> mword 'a

declare isabelle target_rep function wordFromInteger = `word_of_int`

val naturalFromWord : forall 'a. mword 'a -> natural

declare isabelle target_rep function naturalFromWord = `unat`

val wordFromNatural : forall 'a. natural -> mword 'a
let {isabelle} wordFromNatural n =
  wordFromInteger (integerFromNatural n)

(******************************************************************)
(* Bitwise operations, shifts, etc.                               *)
(******************************************************************)

val shiftLeft  : forall 'a. mword 'a -> natural -> mword 'a

declare isabelle target_rep function shiftLeft = `sshiftl`

val shiftRight : forall 'a. mword 'a -> natural -> mword 'a

declare isabelle target_rep function shiftRight = `sshiftr`

val lAnd       : forall 'a. mword 'a -> mword 'a -> mword 'a

declare isabelle target_rep function lAnd = `bit_word_inst.bitAND_word`

val lOr        : forall 'a. mword 'a -> mword 'a -> mword 'a

declare isabelle target_rep function lOr = `bit_word_inst.bitOR_word`

val lXor       : forall 'a. mword 'a -> mword 'a -> mword 'a

declare isabelle target_rep function lXor = `bit_word_inst.bitXOR_word`

val lNot       : forall 'a. mword 'a -> mword 'a

declare isabelle target_rep function lNot = `bit_word_inst.bitNOT_word`

val rotateRight : forall 'a. natural -> mword 'a -> mword 'a

declare isabelle target_rep function rotateRight = `word_rotr`

val rotateLeft : forall 'a. natural -> mword 'a -> mword 'a

declare isabelle target_rep function rotateLeft = `word_rotl`

val zeroExtend : forall 'a 'b. mword 'a -> mword 'b

declare isabelle target_rep function zeroExtend = `ucast`

val signExtend : forall 'a 'b. mword 'a -> mword 'b

declare isabelle target_rep function signExtend = `scast`

(*****************************************************************)
(* Arithmetic                                                    *)
(*****************************************************************)

val plus   : forall 'a. mword 'a -> mword 'a -> mword 'a

declare isabelle target_rep function plus = `plus_word_inst.plus_word`

val minus  : forall 'a. mword 'a -> mword 'a -> mword 'a

declare isabelle target_rep function minus = `minus_word_inst.minus_word`

val uminus : forall 'a. mword 'a -> mword 'a

declare isabelle target_rep function uminus = `uminus_word_inst.uminus_word`

val times : forall 'a. mword 'a -> mword 'a -> mword 'a

declare isabelle target_rep function times = `times_word_inst.times_word`

val divide : forall 'a. mword 'a -> mword 'a -> mword 'a

declare isabelle target_rep function divide = `divide_word_inst.divide_word`

val modulo : forall 'a. mword 'a -> mword 'a -> mword 'a

declare isabelle target_rep function modulo = `modulo_word_inst.modulo_word`
