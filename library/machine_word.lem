(*******************************************************************)
(* A new machine word library, suitable for targetting from Sail,  *)
(* and a thin wrapper around the HOL and Isabelle word libraries.  *)
(*******************************************************************)

declare {isabelle;coq;hol;ocaml} rename module = Lem_machine_word

open import Bool Num Basic_classes Show

open import {isabelle} `~~/src/HOL/Word/Word`
open import {hol} `wordsTheory` `wordsLib`

type mword 'a

(*******************************************************************)
(* Generating arbitrary new bitwidths.                             *)
(*******************************************************************)

type tyone

type bit0 'a

type bit1 'a

declare isabelle target_rep type tyone = `1`
declare hol      target_rep type tyone = `one`

declare isabelle target_rep type bit0 'a = `bit0` 'a
declare hol      target_rep type bit0 'a = `bit0` 'a

declare isabelle target_rep type bit1 'a = `bit1` 'a
declare hol      target_rep type bit1 'a = `bit1` 'a

(*******************************************************************)
(* Fixed bitwidths extracted from Anthony's models.                *)
(*******************************************************************)

type mword1   = mword tyone
type mword2   = mword (bit0 tyone)
type mword3   = mword (bit1 tyone)
type mword4   = mword (bit0 (bit0 tyone))
type mword5   = mword (bit1 (bit0 tyone))
type mword6   = mword (bit0 (bit1 tyone))
type mword7   = mword (bit1 (bit1 tyone))
type mword8   = mword (bit0 (bit0 (bit0 tyone)))
type mword9   = mword (bit1 (bit0 (bit0 tyone)))
type mword10  = mword (bit0 (bit1 (bit0 tyone)))
type mword11  = mword (bit1 (bit1 (bit0 tyone)))
type mword12  = mword (bit0 (bit0 (bit1 tyone)))
type mword13  = mword (bit1 (bit0 (bit1 tyone)))
type mword14  = mword (bit0 (bit1 (bit1 tyone)))
type mword15  = mword (bit1 (bit1 (bit1 tyone)))
type mword16  = mword (bit0 (bit0 (bit0 (bit0 tyone))))
type mword17  = mword (bit1 (bit0 (bit0 (bit0 tyone))))
type mword19  = mword (bit1 (bit1 (bit0 (bit0 tyone))))
type mword20  = mword (bit0 (bit0 (bit1 (bit0 tyone))))
type mword21  = mword (bit1 (bit0 (bit1 (bit0 tyone))))
type mword22  = mword (bit0 (bit1 (bit1 (bit0 tyone))))
type mword23  = mword (bit1 (bit1 (bit1 (bit0 tyone))))
type mword24  = mword (bit0 (bit0 (bit0 (bit1 tyone))))
type mword25  = mword (bit1 (bit0 (bit0 (bit1 tyone))))
type mword26  = mword (bit0 (bit1 (bit0 (bit1 tyone))))
type mword27  = mword (bit1 (bit1 (bit0 (bit1 tyone))))
type mword28  = mword (bit0 (bit0 (bit1 (bit1 tyone))))
type mword30  = mword (bit0 (bit1 (bit1 (bit1 tyone))))
type mword31  = mword (bit1 (bit1 (bit1 (bit1 tyone))))
type mword32  = mword (bit0 (bit0 (bit0 (bit0 (bit0 tyone)))))
type mword33  = mword (bit1 (bit0 (bit0 (bit0 (bit0 tyone)))))
type mword34  = mword (bit0 (bit1 (bit0 (bit0 (bit0 tyone)))))
type mword35  = mword (bit1 (bit1 (bit0 (bit0 (bit0 tyone)))))
type mword36  = mword (bit0 (bit0 (bit1 (bit0 (bit0 tyone)))))
type mword37  = mword (bit1 (bit0 (bit1 (bit0 (bit0 tyone)))))
type mword38  = mword (bit0 (bit1 (bit1 (bit0 (bit0 tyone)))))
type mword40  = mword (bit0 (bit0 (bit0 (bit1 (bit0 tyone)))))
type mword41  = mword (bit1 (bit0 (bit0 (bit1 (bit0 tyone)))))
type mword45  = mword (bit1 (bit0 (bit1 (bit1 (bit0 tyone)))))
type mword46  = mword (bit0 (bit1 (bit1 (bit1 (bit0 tyone)))))
type mword48  = mword (bit0 (bit0 (bit0 (bit0 (bit1 tyone)))))
type mword50  = mword (bit0 (bit1 (bit0 (bit0 (bit1 tyone)))))
type mword51  = mword (bit1 (bit1 (bit0 (bit0 (bit1 tyone)))))
type mword52  = mword (bit0 (bit0 (bit1 (bit0 (bit1 tyone)))))
type mword55  = mword (bit1 (bit1 (bit1 (bit0 (bit1 tyone)))))
type mword56  = mword (bit1 (bit1 (bit1 (bit0 (bit1 tyone)))))
type mword58  = mword (bit0 (bit1 (bit0 (bit1 (bit1 tyone)))))
type mword59  = mword (bit1 (bit1 (bit0 (bit1 (bit1 tyone)))))
type mword60  = mword (bit0 (bit0 (bit1 (bit1 (bit1 tyone)))))
type mword61  = mword (bit1 (bit0 (bit1 (bit1 (bit1 tyone)))))
type mword62  = mword (bit0 (bit1 (bit1 (bit1 (bit1 tyone)))))
type mword63  = mword (bit1 (bit1 (bit1 (bit1 (bit1 tyone)))))
type mword64  = mword (bit0 (bit0 (bit0 (bit0 (bit0 (bit0 tyone))))))
type mword65  = mword (bit1 (bit0 (bit0 (bit0 (bit0 (bit0 tyone))))))
type mword128 = mword (bit0 (bit0 (bit0 (bit0 (bit0 (bit0 (bit0 tyone)))))))
type mword192 = mword (bit0 (bit0 (bit0 (bit0 (bit0 (bit0 (bit1 tyone)))))))
type mword256 = mword (bit0 (bit0 (bit0 (bit0 (bit0 (bit0 (bit0 (bit0 tyone))))))))
type mword257 = mword (bit1 (bit0 (bit0 (bit0 (bit0 (bit0 (bit0 (bit0 tyone))))))))

(* Pretty printing for both Isabelle and HOL so users don't suffer the encoding
 * above when using words...
 *)

declare isabelle target_rep type mword 'a = `word` 'a
declare hol      target_rep type mword 'a = `word` 'a

declare isabelle target_rep type mword3   = `word` `3`
declare isabelle target_rep type mword4   = `word` `4`
declare isabelle target_rep type mword5   = `word` `5`
declare isabelle target_rep type mword6   = `word` `6`
declare isabelle target_rep type mword7   = `word` `7`
declare isabelle target_rep type mword8   = `word` `8`
declare isabelle target_rep type mword9   = `word` `9`
declare isabelle target_rep type mword10  = `word` `10`
declare isabelle target_rep type mword11  = `word` `11`
declare isabelle target_rep type mword12  = `word` `12`
declare isabelle target_rep type mword13  = `word` `13`
declare isabelle target_rep type mword14  = `word` `14`
declare isabelle target_rep type mword15  = `word` `15`
declare isabelle target_rep type mword16  = `word` `16`
declare isabelle target_rep type mword17  = `word` `17`
declare isabelle target_rep type mword19  = `word` `19`
declare isabelle target_rep type mword20  = `word` `20`
declare isabelle target_rep type mword21  = `word` `21`
declare isabelle target_rep type mword22  = `word` `22`
declare isabelle target_rep type mword23  = `word` `23`
declare isabelle target_rep type mword24  = `word` `24`
declare isabelle target_rep type mword25  = `word` `25`
declare isabelle target_rep type mword26  = `word` `26`
declare isabelle target_rep type mword27  = `word` `27`
declare isabelle target_rep type mword28  = `word` `28`
declare isabelle target_rep type mword30  = `word` `30`
declare isabelle target_rep type mword31  = `word` `31`
declare isabelle target_rep type mword32  = `word` `32`
declare isabelle target_rep type mword33  = `word` `33`
declare isabelle target_rep type mword34  = `word` `34`
declare isabelle target_rep type mword35  = `word` `35`
declare isabelle target_rep type mword36  = `word` `36`
declare isabelle target_rep type mword37  = `word` `37`
declare isabelle target_rep type mword38  = `word` `38`
declare isabelle target_rep type mword40  = `word` `40`
declare isabelle target_rep type mword41  = `word` `41`
declare isabelle target_rep type mword45  = `word` `45`
declare isabelle target_rep type mword46  = `word` `46`
declare isabelle target_rep type mword48  = `word` `48`
declare isabelle target_rep type mword50  = `word` `50`
declare isabelle target_rep type mword51  = `word` `51`
declare isabelle target_rep type mword52  = `word` `52`
declare isabelle target_rep type mword55  = `word` `55`
declare isabelle target_rep type mword56  = `word` `56`
declare isabelle target_rep type mword58  = `word` `58`
declare isabelle target_rep type mword59  = `word` `59`
declare isabelle target_rep type mword60  = `word` `60`
declare isabelle target_rep type mword61  = `word` `61`
declare isabelle target_rep type mword62  = `word` `62`
declare isabelle target_rep type mword63  = `word` `63`
declare isabelle target_rep type mword64  = `word` `64`
declare isabelle target_rep type mword65  = `word` `65`
declare isabelle target_rep type mword128 = `word` `128`
declare isabelle target_rep type mword192 = `word` `192`
declare isabelle target_rep type mword256 = `word` `256`
declare isabelle target_rep type mword257 = `word` `257`

declare hol target_rep type mword1   = `word` `1`
declare hol target_rep type mword2   = `word` `2`
declare hol target_rep type mword3   = `word` `3`
declare hol target_rep type mword4   = `word` `4`
declare hol target_rep type mword5   = `word` `5`
declare hol target_rep type mword6   = `word` `6`
declare hol target_rep type mword7   = `word` `7`
declare hol target_rep type mword8   = `word` `8`
declare hol target_rep type mword9   = `word` `9`
declare hol target_rep type mword10  = `word` `10`
declare hol target_rep type mword11  = `word` `11`
declare hol target_rep type mword12  = `word` `12`
declare hol target_rep type mword13  = `word` `13`
declare hol target_rep type mword14  = `word` `14`
declare hol target_rep type mword15  = `word` `15`
declare hol target_rep type mword16  = `word` `16`
declare hol target_rep type mword17  = `word` `17`
declare hol target_rep type mword19  = `word` `19`
declare hol target_rep type mword20  = `word` `20`
declare hol target_rep type mword21  = `word` `21`
declare hol target_rep type mword22  = `word` `22`
declare hol target_rep type mword23  = `word` `23`
declare hol target_rep type mword24  = `word` `24`
declare hol target_rep type mword25  = `word` `25`
declare hol target_rep type mword26  = `word` `26`
declare hol target_rep type mword27  = `word` `27`
declare hol target_rep type mword28  = `word` `28`
declare hol target_rep type mword30  = `word` `30`
declare hol target_rep type mword31  = `word` `31`
declare hol target_rep type mword32  = `word` `32`
declare hol target_rep type mword33  = `word` `33`
declare hol target_rep type mword34  = `word` `34`
declare hol target_rep type mword35  = `word` `35`
declare hol target_rep type mword36  = `word` `36`
declare hol target_rep type mword37  = `word` `37`
declare hol target_rep type mword38  = `word` `38`
declare hol target_rep type mword40  = `word` `40`
declare hol target_rep type mword41  = `word` `41`
declare hol target_rep type mword45  = `word` `45`
declare hol target_rep type mword46  = `word` `46`
declare hol target_rep type mword48  = `word` `48`
declare hol target_rep type mword50  = `word` `50`
declare hol target_rep type mword51  = `word` `51`
declare hol target_rep type mword52  = `word` `52`
declare hol target_rep type mword55  = `word` `55`
declare hol target_rep type mword56  = `word` `56`
declare hol target_rep type mword58  = `word` `58`
declare hol target_rep type mword59  = `word` `59`
declare hol target_rep type mword60  = `word` `60`
declare hol target_rep type mword61  = `word` `61`
declare hol target_rep type mword62  = `word` `62`
declare hol target_rep type mword63  = `word` `63`
declare hol target_rep type mword64  = `word` `64`
declare hol target_rep type mword65  = `word` `65`
declare hol target_rep type mword128 = `word` `128`
declare hol target_rep type mword192 = `word` `192`
declare hol target_rep type mword256 = `word` `256`
declare hol target_rep type mword257 = `word` `257`

val word_length : forall 'a. mword 'a -> nat
declare hol target_rep function word_length = `word_len`

(******************************************************************)
(* Comparisons                                                    *)
(******************************************************************)

val mwordEq : forall 'a. mword 'a -> mword 'a -> bool
let inline mwordEq = unsafe_structural_equality

instance forall 'a. (Eq (mword 'a))
  let (=)        = mwordEq
  let (<>) w1 w2 = not (mwordEq w1 w2)
end

val signedLess : forall 'a. mword 'a -> mword 'a -> bool

declare isabelle target_rep function signedLess = `word_sless`
declare hol      target_rep function signedLess = `word_lt`

val signedLessEq : forall 'a. mword 'a -> mword 'a -> bool

declare isabelle target_rep function signedLessEq = `word_sle`
declare hol      target_rep function signedLessEq = `word_le`

val unsignedLess : forall 'a. mword 'a -> mword 'a -> bool

declare isabelle target_rep function unsignedLess = `ord_word_inst.less_word`
declare hol      target_rep function unsignedLess = `word_lo`

val unsignedLessEq : forall 'a. mword 'a -> mword 'a -> bool

declare isabelle target_rep function unsignedLessEq = `ord_word_inst.less_eq_word`
declare hol      target_rep function unsignedLessEq = `word_ls`

(******************************************************************)
(* Appending, splitting and probing words                         *)
(******************************************************************)

val word_concat : forall 'a 'b 'c. mword 'a -> mword 'b -> mword 'c
declare hol      target_rep function word_concat = `word_concat`
declare isabelle target_rep function word_concat = `word_cat`

(* Note that we assume the result type has the correct size, especially
   for Isabelle. *)
val word_extract : forall 'a 'b. nat -> nat -> mword 'a -> mword 'b
declare hol      target_rep function word_extract lo hi v = `word_extract` hi lo v
declare isabelle target_rep function word_extract lo hi v = `slice` lo v

(*  Needs to be in the prover because we'd end up with unknown sizes in the
   types in Lem.
*)
val word_update : forall 'a 'b. mword 'a -> nat -> nat -> mword 'b -> mword 'a
declare hol      target_rep function word_update v lo hi w = `bit_field_insert` hi lo w v
declare isabelle target_rep function word_update v lo hi w = `word_update` v lo hi w (* In Lem.thy *)

val setBit : forall 'a. mword 'a -> natural -> bool -> mword 'a

declare isabelle target_rep function setBit = `bits_word_inst.set_bit_word`
declare hol      target_rep function setBit w i b = `$:+` i b w

val getBit : forall 'a. mword 'a -> natural -> bool

declare isabelle target_rep function getBit     = `bits_word_inst.test_bit_word`
declare hol      target_rep function getBit w b = `word_bit` w b

val msb : forall 'a. mword 'a -> bool

declare isabelle target_rep function msb = `bitss_word_inst.msb_word`
declare hol      target_rep function msb = `word_msb`

val lsb : forall 'a. mword 'a -> bool

declare isabelle target_rep function lsb = `bits_word_inst.lsb_word`
declare hol      target_rep function lsb = `word_lsb`


(******************************************************************)
(* Conversions                                                    *)
(******************************************************************)

val signedIntegerFromWord : forall 'a. mword 'a -> integer

declare isabelle target_rep function signedIntegerFromWord = `sint`
declare hol      target_rep function signedIntegerFromWord = `w2i`

val unsignedIntegerFromWord : forall 'a. mword 'a -> integer

declare isabelle target_rep function unsignedIntegerFromWord = `uint`

val wordFromInteger : forall 'a. integer -> mword 'a

declare isabelle target_rep function wordFromInteger = `word_of_int`
declare hol      target_rep function wordFromInteger = `i2w`

val naturalFromWord : forall 'a. mword 'a -> natural

declare isabelle target_rep function naturalFromWord = `unat`
declare hol      target_rep function naturalFromWord = `w2n`

val wordFromNatural : forall 'a. natural -> mword 'a

declare hol      target_rep function wordFromNatural = `n2w`

let {isabelle} wordFromNatural n =
  wordFromInteger (integerFromNatural n)

val wordToHex : forall 'a. mword 'a -> string
declare hol target_rep function wordToHex = `word_to_hex_string`
(* Building libraries fails if we don't provide implementations for the
   type class. *)
let {ocaml;isabelle;coq} wordToHex w = "wordToHex not yet implemented"

instance forall 'a. (Show (mword 'a))
  let show = wordToHex
end

(******************************************************************)
(* Bitwise operations, shifts, etc.                               *)
(******************************************************************)

val shiftLeft  : forall 'a. mword 'a -> natural -> mword 'a

declare isabelle target_rep function shiftLeft = `sshiftl`
declare hol      target_rep function shiftLeft = `word_lsl`

val shiftRight : forall 'a. mword 'a -> natural -> mword 'a

declare isabelle target_rep function shiftRight = `sshiftr`
declare hol      target_rep function shiftRight = `word_lsr`

val lAnd       : forall 'a. mword 'a -> mword 'a -> mword 'a

declare isabelle target_rep function lAnd = `bit_word_inst.bitAND_word`
declare hol      target_rep function lAnd = `word_and`

val lOr        : forall 'a. mword 'a -> mword 'a -> mword 'a

declare isabelle target_rep function lOr = `bit_word_inst.bitOR_word`
declare hol      target_rep function lOr = `word_or`

val lXor       : forall 'a. mword 'a -> mword 'a -> mword 'a

declare isabelle target_rep function lXor = `bit_word_inst.bitXOR_word`
declare hol      target_rep function lXor = `word_xor`

val lNot       : forall 'a. mword 'a -> mword 'a

declare isabelle target_rep function lNot = `bit_word_inst.bitNOT_word`
declare hol      target_rep function lNot = `word_1comp`

val rotateRight : forall 'a. natural -> mword 'a -> mword 'a

declare isabelle target_rep function rotateRight = `word_rotr`
declare hol      target_rep function rotateRight = `word_ror`

val rotateLeft : forall 'a. natural -> mword 'a -> mword 'a

declare isabelle target_rep function rotateLeft = `word_rotl`
declare hol      target_rep function rotateLeft = `word_rol`

val zeroExtend : forall 'a 'b. mword 'a -> mword 'b

declare isabelle target_rep function zeroExtend = `ucast`
declare hol      target_rep function zeroExtend = `w2w`

val signExtend : forall 'a 'b. mword 'a -> mword 'b

declare isabelle target_rep function signExtend = `scast`
declare hol      target_rep function signExtend = `sw2sw`

(*****************************************************************)
(* Arithmetic                                                    *)
(*****************************************************************)

val plus   : forall 'a. mword 'a -> mword 'a -> mword 'a

declare isabelle target_rep function plus = `plus_word_inst.plus_word`
declare hol      target_rep function plus = `word_add`

val minus  : forall 'a. mword 'a -> mword 'a -> mword 'a

declare isabelle target_rep function minus = `minus_word_inst.minus_word`
declare hol      target_rep function minus = `word_sub`

val uminus : forall 'a. mword 'a -> mword 'a

declare isabelle target_rep function uminus = `uminus_word_inst.uminus_word`
let {hol} uminus m =
  (minus (wordFromNatural 0) m)

val times : forall 'a. mword 'a -> mword 'a -> mword 'a

declare isabelle target_rep function times = `times_word_inst.times_word`
declare hol      target_rep function times = `word_mul`

val unsignedDivide : forall 'a. mword 'a -> mword 'a -> mword 'a
val signedDivide : forall 'a. mword 'a -> mword 'a -> mword 'a

declare isabelle target_rep function unsignedDivide = `divide_word_inst.divide_word`
declare hol      target_rep function unsignedDivide = `word_div`
declare hol      target_rep function signedDivide   = `word_sdiv`

let {isabelle} signedDivide x y =
  wordFromInteger ((signedIntegerFromWord x) / (signedIntegerFromWord y))

val modulo : forall 'a. mword 'a -> mword 'a -> mword 'a

declare isabelle target_rep function modulo = `modulo_word_inst.modulo_word`
declare hol      target_rep function modulo = `word_mod`
