(*******************************************************************)
(* A new machine word library, suitable for targetting from Sail,  *)
(* and a thin wrapper around the HOL and Isabelle word libraries.  *)
(*******************************************************************)

declare {isabelle;coq;hol;ocaml} rename module = Lem_machine_word

open import Bool Num Basic_classes Show

open import {isabelle} `~~/src/HOL/Word/Word`
open import {hol} `wordsTheory` `wordsLib`

type mword 'a

class (Size 'a)
  val size : nat
end

declare isabelle target_rep type mword 'a = `word` 'a
declare hol      target_rep type mword 'a = `word` 'a
declare ocaml    target_rep type mword 'a = `Lem.mword`

val ocaml_inject : forall 'a. nat * natural -> mword 'a
declare ocaml target_rep function ocaml_inject = `Lem.machine_word_inject`

(*******************************************************************)
(* Fixed bitwidths extracted from Anthony's models.                *)
(*******************************************************************)

type ty1
type ty2
type ty3
type ty4
type ty5
type ty6
type ty7
type ty8
type ty9
type ty10
type ty11
type ty12
type ty13
type ty14
type ty15
type ty16
type ty17
type ty19
type ty20
type ty21
type ty22
type ty23
type ty24
type ty25
type ty26
type ty27
type ty28
type ty30
type ty31
type ty32
type ty33
type ty34
type ty35
type ty36
type ty37
type ty38
type ty40
type ty41
type ty45
type ty46
type ty48
type ty50
type ty51
type ty52
type ty55
type ty56
type ty58
type ty59
type ty60
type ty61
type ty62
type ty63
type ty64
type ty65
type ty128
type ty192
type ty256
type ty257

instance (Size ty1) let size = 1 end
instance (Size ty2) let size = 2 end
instance (Size ty3) let size = 3 end
instance (Size ty4) let size = 4 end
instance (Size ty5) let size = 5 end
instance (Size ty6) let size = 6 end
instance (Size ty7) let size = 7 end
instance (Size ty8) let size = 8 end
instance (Size ty9) let size = 9 end
instance (Size ty10) let size = 10 end
instance (Size ty11) let size = 11 end
instance (Size ty12) let size = 12 end
instance (Size ty13) let size = 13 end
instance (Size ty14) let size = 14 end
instance (Size ty15) let size = 15 end
instance (Size ty16) let size = 16 end
instance (Size ty17) let size = 17 end
instance (Size ty19) let size = 19 end
instance (Size ty20) let size = 20 end
instance (Size ty21) let size = 21 end
instance (Size ty22) let size = 22 end
instance (Size ty23) let size = 23 end
instance (Size ty24) let size = 24 end
instance (Size ty25) let size = 25 end
instance (Size ty26) let size = 26 end
instance (Size ty27) let size = 27 end
instance (Size ty28) let size = 28 end
instance (Size ty30) let size = 30 end
instance (Size ty31) let size = 31 end
instance (Size ty32) let size = 32 end
instance (Size ty33) let size = 33 end
instance (Size ty34) let size = 34 end
instance (Size ty35) let size = 35 end
instance (Size ty36) let size = 36 end
instance (Size ty37) let size = 37 end
instance (Size ty38) let size = 38 end
instance (Size ty40) let size = 40 end
instance (Size ty41) let size = 41 end
instance (Size ty45) let size = 45 end
instance (Size ty46) let size = 46 end
instance (Size ty48) let size = 48 end
instance (Size ty50) let size = 50 end
instance (Size ty51) let size = 51 end
instance (Size ty52) let size = 52 end
instance (Size ty55) let size = 55 end
instance (Size ty56) let size = 56 end
instance (Size ty58) let size = 58 end
instance (Size ty59) let size = 59 end
instance (Size ty60) let size = 60 end
instance (Size ty61) let size = 61 end
instance (Size ty62) let size = 62 end
instance (Size ty63) let size = 63 end
instance (Size ty64) let size = 64 end
instance (Size ty65) let size = 65 end
instance (Size ty128) let size = 128 end
instance (Size ty192) let size = 192 end
instance (Size ty256) let size = 256 end
instance (Size ty257) let size = 257 end

declare isabelle target_rep type ty1   = `1`
declare isabelle target_rep type ty2   = `2`
declare isabelle target_rep type ty3   = `3`
declare isabelle target_rep type ty4   = `4`
declare isabelle target_rep type ty5   = `5`
declare isabelle target_rep type ty6   = `6`
declare isabelle target_rep type ty7   = `7`
declare isabelle target_rep type ty8   = `8`
declare isabelle target_rep type ty9   = `9`
declare isabelle target_rep type ty10  = `10`
declare isabelle target_rep type ty11  = `11`
declare isabelle target_rep type ty12  = `12`
declare isabelle target_rep type ty13  = `13`
declare isabelle target_rep type ty14  = `14`
declare isabelle target_rep type ty15  = `15`
declare isabelle target_rep type ty16  = `16`
declare isabelle target_rep type ty17  = `17`
declare isabelle target_rep type ty19  = `19`
declare isabelle target_rep type ty20  = `20`
declare isabelle target_rep type ty21  = `21`
declare isabelle target_rep type ty22  = `22`
declare isabelle target_rep type ty23  = `23`
declare isabelle target_rep type ty24  = `24`
declare isabelle target_rep type ty25  = `25`
declare isabelle target_rep type ty26  = `26`
declare isabelle target_rep type ty27  = `27`
declare isabelle target_rep type ty28  = `28`
declare isabelle target_rep type ty30  = `30`
declare isabelle target_rep type ty31  = `31`
declare isabelle target_rep type ty32  = `32`
declare isabelle target_rep type ty33  = `33`
declare isabelle target_rep type ty34  = `34`
declare isabelle target_rep type ty35  = `35`
declare isabelle target_rep type ty36  = `36`
declare isabelle target_rep type ty37  = `37`
declare isabelle target_rep type ty38  = `38`
declare isabelle target_rep type ty40  = `40`
declare isabelle target_rep type ty41  = `41`
declare isabelle target_rep type ty45  = `45`
declare isabelle target_rep type ty46  = `46`
declare isabelle target_rep type ty48  = `48`
declare isabelle target_rep type ty50  = `50`
declare isabelle target_rep type ty51  = `51`
declare isabelle target_rep type ty52  = `52`
declare isabelle target_rep type ty55  = `55`
declare isabelle target_rep type ty56  = `56`
declare isabelle target_rep type ty58  = `58`
declare isabelle target_rep type ty59  = `59`
declare isabelle target_rep type ty60  = `60`
declare isabelle target_rep type ty61  = `61`
declare isabelle target_rep type ty62  = `62`
declare isabelle target_rep type ty63  = `63`
declare isabelle target_rep type ty64  = `64`
declare isabelle target_rep type ty65  = `65`
declare isabelle target_rep type ty128 = `128`
declare isabelle target_rep type ty192 = `192`
declare isabelle target_rep type ty256 = `256`
declare isabelle target_rep type ty257 = `257`

declare hol target_rep type ty1   = `1`
declare hol target_rep type ty2   = `2`
declare hol target_rep type ty3   = `3`
declare hol target_rep type ty4   = `4`
declare hol target_rep type ty5   = `5`
declare hol target_rep type ty6   = `6`
declare hol target_rep type ty7   = `7`
declare hol target_rep type ty8   = `8`
declare hol target_rep type ty9   = `9`
declare hol target_rep type ty10  = `10`
declare hol target_rep type ty11  = `11`
declare hol target_rep type ty12  = `12`
declare hol target_rep type ty13  = `13`
declare hol target_rep type ty14  = `14`
declare hol target_rep type ty15  = `15`
declare hol target_rep type ty16  = `16`
declare hol target_rep type ty17  = `17`
declare hol target_rep type ty19  = `19`
declare hol target_rep type ty20  = `20`
declare hol target_rep type ty21  = `21`
declare hol target_rep type ty22  = `22`
declare hol target_rep type ty23  = `23`
declare hol target_rep type ty24  = `24`
declare hol target_rep type ty25  = `25`
declare hol target_rep type ty26  = `26`
declare hol target_rep type ty27  = `27`
declare hol target_rep type ty28  = `28`
declare hol target_rep type ty30  = `30`
declare hol target_rep type ty31  = `31`
declare hol target_rep type ty32  = `32`
declare hol target_rep type ty33  = `33`
declare hol target_rep type ty34  = `34`
declare hol target_rep type ty35  = `35`
declare hol target_rep type ty36  = `36`
declare hol target_rep type ty37  = `37`
declare hol target_rep type ty38  = `38`
declare hol target_rep type ty40  = `40`
declare hol target_rep type ty41  = `41`
declare hol target_rep type ty45  = `45`
declare hol target_rep type ty46  = `46`
declare hol target_rep type ty48  = `48`
declare hol target_rep type ty50  = `50`
declare hol target_rep type ty51  = `51`
declare hol target_rep type ty52  = `52`
declare hol target_rep type ty55  = `55`
declare hol target_rep type ty56  = `56`
declare hol target_rep type ty58  = `58`
declare hol target_rep type ty59  = `59`
declare hol target_rep type ty60  = `60`
declare hol target_rep type ty61  = `61`
declare hol target_rep type ty62  = `62`
declare hol target_rep type ty63  = `63`
declare hol target_rep type ty64  = `64`
declare hol target_rep type ty65  = `65`
declare hol target_rep type ty128 = `128`
declare hol target_rep type ty192 = `192`
declare hol target_rep type ty256 = `256`
declare hol target_rep type ty257 = `257`

val word_length : forall 'a. mword 'a -> nat
declare ocaml    target_rep function word_length = `Lem.word_length`
declare isabelle target_rep function word_length = `size`
declare hol      target_rep function word_length = `word_len`

(******************************************************************)
(* Conversions                                                    *)
(******************************************************************)

val signedIntegerFromWord : forall 'a. mword 'a -> integer

declare isabelle target_rep function signedIntegerFromWord = `sint`
declare hol      target_rep function signedIntegerFromWord = `w2i`

val unsignedIntegerFromWord : forall 'a. mword 'a -> integer

declare isabelle target_rep function unsignedIntegerFromWord = `uint`

val wordFromInteger : forall 'a. integer -> mword 'a

declare isabelle target_rep function wordFromInteger = `word_of_int`
declare hol      target_rep function wordFromInteger = `i2w`

val naturalFromWord : forall 'a. mword 'a -> natural

declare isabelle target_rep function naturalFromWord = `unat`
declare hol      target_rep function naturalFromWord = `w2n`

val wordFromNatural : forall 'a. Size 'a => natural -> mword 'a

declare hol      target_rep function wordFromNatural = `n2w`

let inline {isabelle} wordFromNatural n =
  wordFromInteger (integerFromNatural n)

let {ocaml} wordFromNatural n = ocaml_inject (size, n)

val wordToHex : forall 'a. mword 'a -> string
declare hol target_rep function wordToHex = `word_to_hex_string`
(* Building libraries fails if we don't provide implementations for the
   type class. *)
let {ocaml;isabelle;coq} wordToHex w = "wordToHex not yet implemented"

instance forall 'a. (Show (mword 'a))
  let show = wordToHex
end


assert {ocaml;hol;isabelle} length_test : word_length ((wordFromNatural 0) : mword ty13) = 13

(******************************************************************)
(* Comparisons                                                    *)
(******************************************************************)

val mwordEq : forall 'a. mword 'a -> mword 'a -> bool
let inline mwordEq = unsafe_structural_equality

instance forall 'a. (Eq (mword 'a))
  let (=)        = mwordEq
  let (<>) w1 w2 = not (mwordEq w1 w2)
end

val signedLess : forall 'a. mword 'a -> mword 'a -> bool

declare isabelle target_rep function signedLess = `word_sless`
declare hol      target_rep function signedLess = `word_lt`

val signedLessEq : forall 'a. mword 'a -> mword 'a -> bool

declare isabelle target_rep function signedLessEq = `word_sle`
declare hol      target_rep function signedLessEq = `word_le`

val unsignedLess : forall 'a. mword 'a -> mword 'a -> bool

declare isabelle target_rep function unsignedLess = `ord_word_inst.less_word`
declare hol      target_rep function unsignedLess = `word_lo`

val unsignedLessEq : forall 'a. mword 'a -> mword 'a -> bool

declare isabelle target_rep function unsignedLessEq = `ord_word_inst.less_eq_word`
declare hol      target_rep function unsignedLessEq = `word_ls`

(******************************************************************)
(* Appending, splitting and probing words                         *)
(******************************************************************)

val word_concat : forall 'a 'b 'c. mword 'a -> mword 'b -> mword 'c
declare hol      target_rep function word_concat = `word_concat`
declare isabelle target_rep function word_concat = `word_cat`
declare ocaml    target_rep function word_concat = `Lem.word_concat`

(* Note that we assume the result type has the correct size, especially
   for Isabelle. *)
val word_extract : forall 'a 'b. nat -> nat -> mword 'a -> mword 'b
declare hol      target_rep function word_extract lo hi v = `word_extract` hi lo v
declare isabelle target_rep function word_extract lo hi v = `slice` lo v
declare ocaml    target_rep function word_extract = `Lem.word_extract`

(*  Needs to be in the prover because we'd end up with unknown sizes in the
   types in Lem.
*)
val word_update : forall 'a 'b. mword 'a -> nat -> nat -> mword 'b -> mword 'a
declare hol      target_rep function word_update v lo hi w = `bit_field_insert` hi lo w v
declare isabelle target_rep function word_update v lo hi w = `word_update` v lo hi w (* In Lem.thy *)
declare ocaml    target_rep function word_update = `Lem.word_update`

val setBit : forall 'a. mword 'a -> natural -> bool -> mword 'a

declare isabelle target_rep function setBit = `bits_word_inst.set_bit_word`
declare hol      target_rep function setBit w i b = `$:+` i b w

val getBit : forall 'a. mword 'a -> natural -> bool

declare isabelle target_rep function getBit     = `bits_word_inst.test_bit_word`
declare hol      target_rep function getBit w b = `word_bit` b w

val msb : forall 'a. mword 'a -> bool

declare isabelle target_rep function msb = `bitss_word_inst.msb_word`
declare hol      target_rep function msb = `word_msb`

val lsb : forall 'a. mword 'a -> bool

declare isabelle target_rep function lsb = `bits_word_inst.lsb_word`
declare hol      target_rep function lsb = `word_lsb`

assert {ocaml;hol;isabelle} extract_concat_test :
  let x : mword ty16 = wordFromNatural 1234 in
  word_concat ((word_extract 11 15 x) : mword ty5)
              ((word_concat ((word_extract 4 10 x) : mword ty7)
                            ((word_extract 0 3 x) : mword ty4)) : mword ty11)
               = x
assert {ocaml;hol;isabelle} update_test :
  let x : mword ty16 = wordFromNatural 1234 in
  let y : mword ty8 = wordFromNatural 41 in
  word_update x 1 8 y = wordFromNatural 1106
assert {hol;isabelle} setBit_test1 : setBit (wordFromNatural 12 : mword ty8) 1  true = wordFromNatural 14
assert {hol;isabelle} setBit_test2 : setBit (wordFromNatural 14 : mword ty8) 1 false = wordFromNatural 12
assert {hol;isabelle} setBit_test3 : setBit (wordFromNatural 2 : mword ty8) 1 false = wordFromNatural 0
assert {hol;isabelle} getBit_test  : getBit (wordFromNatural 3 : mword ty8) 1 = true

(******************************************************************)
(* Bitwise operations, shifts, etc.                               *)
(******************************************************************)

val shiftLeft  : forall 'a. mword 'a -> natural -> mword 'a

declare isabelle target_rep function shiftLeft = `sshiftl`
declare hol      target_rep function shiftLeft = `word_lsl`

val shiftRight : forall 'a. mword 'a -> natural -> mword 'a

declare isabelle target_rep function shiftRight = `sshiftr`
declare hol      target_rep function shiftRight = `word_lsr`

val lAnd       : forall 'a. mword 'a -> mword 'a -> mword 'a

declare isabelle target_rep function lAnd = `bit_word_inst.bitAND_word`
declare hol      target_rep function lAnd = `word_and`

val lOr        : forall 'a. mword 'a -> mword 'a -> mword 'a

declare isabelle target_rep function lOr = `bit_word_inst.bitOR_word`
declare hol      target_rep function lOr = `word_or`

val lXor       : forall 'a. mword 'a -> mword 'a -> mword 'a

declare isabelle target_rep function lXor = `bit_word_inst.bitXOR_word`
declare hol      target_rep function lXor = `word_xor`

val lNot       : forall 'a. mword 'a -> mword 'a

declare isabelle target_rep function lNot = `bit_word_inst.bitNOT_word`
declare hol      target_rep function lNot = `word_1comp`

val rotateRight : forall 'a. natural -> mword 'a -> mword 'a

declare isabelle target_rep function rotateRight = `word_rotr`
declare hol      target_rep function rotateRight = `word_ror`

val rotateLeft : forall 'a. natural -> mword 'a -> mword 'a

declare isabelle target_rep function rotateLeft = `word_rotl`
declare hol      target_rep function rotateLeft = `word_rol`

val zeroExtend : forall 'a 'b. mword 'a -> mword 'b

declare isabelle target_rep function zeroExtend = `ucast`
declare hol      target_rep function zeroExtend = `w2w`

val signExtend : forall 'a 'b. mword 'a -> mword 'b

declare isabelle target_rep function signExtend = `scast`
declare hol      target_rep function signExtend = `sw2sw`

(*****************************************************************)
(* Arithmetic                                                    *)
(*****************************************************************)

val plus   : forall 'a. mword 'a -> mword 'a -> mword 'a

declare isabelle target_rep function plus = `plus_word_inst.plus_word`
declare hol      target_rep function plus = `word_add`

val minus  : forall 'a. mword 'a -> mword 'a -> mword 'a

declare isabelle target_rep function minus = `minus_word_inst.minus_word`
declare hol      target_rep function minus = `word_sub`

val uminus : forall 'a. mword 'a -> mword 'a

declare isabelle target_rep function uminus = `uminus_word_inst.uminus_word`
declare hol      target_rep function uminus = `word_2comp`

val times : forall 'a. mword 'a -> mword 'a -> mword 'a

declare isabelle target_rep function times = `times_word_inst.times_word`
declare hol      target_rep function times = `word_mul`

val unsignedDivide : forall 'a. mword 'a -> mword 'a -> mword 'a
val signedDivide : forall 'a. mword 'a -> mword 'a -> mword 'a

declare isabelle target_rep function unsignedDivide = `divide_word_inst.divide_word`
declare hol      target_rep function unsignedDivide = `word_div`
declare hol      target_rep function signedDivide   = `word_sdiv`

let {isabelle} signedDivide x y =
  wordFromInteger ((signedIntegerFromWord x) / (signedIntegerFromWord y))

val modulo : forall 'a. mword 'a -> mword 'a -> mword 'a

declare isabelle target_rep function modulo = `modulo_word_inst.modulo_word`
declare hol      target_rep function modulo = `word_mod`
