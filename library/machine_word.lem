(*******************************************************************)
(* A new machine word library, suitable for targetting from Sail,  *)
(* and a thin wrapper around the HOL and Isabelle word libraries.  *)
(*******************************************************************)

declare {isabelle;coq;hol;ocaml} rename module = Lem_machine_word

open import Bool Num Basic_classes

open import {isabelle} `~~/src/HOL/Word/Word`
open import {hol} `wordsTheory` `wordsLib`

type mword 'a

(*******************************************************************)
(* Generating arbitrary new bitwidths.                             *)
(*******************************************************************)

type one

type bit0 'a

type bit1 'a

declare isabelle target_rep type one = `1`
declare hol      target_rep type one = `one`

declare isabelle target_rep type bit0 'a = `bit0` 'a
declare hol      target_rep type bit0 'a = `bit0` 'a

declare isabelle target_rep type bit1 'a = `bit1` 'a
declare hol      target_rep type bit1 'a = `bit1` 'a

(*******************************************************************)
(* Fixed bitwidths extracted from Anthony's models.                *)
(*******************************************************************)

type mword1   = mword one
type mword2   = mword (bit0 one)
type mword3   = mword (bit1 one)
type mword4   = mword (bit0 (bit0 one))
type mword5   = mword (bit1 (bit0 one))
type mword6   = mword (bit0 (bit1 one))
type mword7   = mword (bit1 (bit1 one))
type mword8   = mword (bit0 (bit0 (bit0 one)))
type mword9   = mword (bit1 (bit0 (bit0 one)))
type mword10  = mword (bit0 (bit1 (bit0 one)))
type mword11  = mword (bit1 (bit1 (bit0 one)))
type mword12  = mword (bit0 (bit0 (bit1 one)))
type mword13  = mword (bit1 (bit0 (bit1 one)))
type mword14  = mword (bit0 (bit1 (bit1 one)))
type mword15  = mword (bit1 (bit1 (bit1 one)))
type mword16  = mword (bit0 (bit0 (bit0 (bit0 one))))
type mword17  = mword (bit1 (bit0 (bit0 (bit0 one))))
type mword19  = mword (bit1 (bit1 (bit0 (bit0 one))))
type mword20  = mword (bit0 (bit0 (bit1 (bit0 one))))
type mword21  = mword (bit1 (bit0 (bit1 (bit0 one))))
type mword22  = mword (bit0 (bit1 (bit1 (bit0 one))))
type mword23  = mword (bit1 (bit1 (bit1 (bit0 one))))
type mword24  = mword (bit0 (bit0 (bit0 (bit1 one))))
type mword25  = mword (bit1 (bit0 (bit0 (bit1 one))))
type mword26  = mword (bit0 (bit1 (bit0 (bit1 one))))
type mword27  = mword (bit1 (bit1 (bit0 (bit1 one))))
type mword28  = mword (bit0 (bit0 (bit1 (bit1 one))))
type mword30  = mword (bit0 (bit1 (bit1 (bit1 one))))
type mword31  = mword (bit1 (bit1 (bit1 (bit1 one))))
type mword32  = mword (bit0 (bit0 (bit0 (bit0 (bit0 one)))))
type mword33  = mword (bit1 (bit0 (bit0 (bit0 (bit0 one)))))
type mword34  = mword (bit0 (bit1 (bit0 (bit0 (bit0 one)))))
type mword35  = mword (bit1 (bit1 (bit0 (bit0 (bit0 one)))))
type mword36  = mword (bit0 (bit0 (bit1 (bit0 (bit0 one)))))
type mword37  = mword (bit1 (bit0 (bit1 (bit0 (bit0 one)))))
type mword38  = mword (bit0 (bit1 (bit1 (bit0 (bit0 one)))))
type mword40  = mword (bit0 (bit0 (bit0 (bit1 (bit0 one)))))
type mword41  = mword (bit1 (bit0 (bit0 (bit1 (bit0 one)))))
type mword45  = mword (bit1 (bit0 (bit1 (bit1 (bit0 one)))))
type mword46  = mword (bit0 (bit1 (bit1 (bit1 (bit0 one)))))
type mword48  = mword (bit0 (bit0 (bit0 (bit0 (bit1 one)))))
type mword50  = mword (bit0 (bit1 (bit0 (bit0 (bit1 one)))))
type mword51  = mword (bit1 (bit1 (bit0 (bit0 (bit1 one)))))
type mword52  = mword (bit0 (bit0 (bit1 (bit0 (bit1 one)))))
type mword55  = mword (bit1 (bit1 (bit1 (bit0 (bit1 one)))))
type mword56  = mword (bit1 (bit1 (bit1 (bit0 (bit1 one)))))
type mword58  = mword (bit0 (bit1 (bit0 (bit1 (bit1 one)))))
type mword59  = mword (bit1 (bit1 (bit0 (bit1 (bit1 one)))))
type mword60  = mword (bit0 (bit0 (bit1 (bit1 (bit1 one)))))
type mword61  = mword (bit1 (bit0 (bit1 (bit1 (bit1 one)))))
type mword62  = mword (bit0 (bit1 (bit1 (bit1 (bit1 one)))))
type mword63  = mword (bit1 (bit1 (bit1 (bit1 (bit1 one)))))
type mword64  = mword (bit0 (bit0 (bit0 (bit0 (bit0 (bit0 one))))))
type mword65  = mword (bit1 (bit0 (bit0 (bit0 (bit0 (bit0 one))))))
type mword128 = mword (bit0 (bit0 (bit0 (bit0 (bit0 (bit0 (bit0 one)))))))
type mword192 = mword (bit0 (bit0 (bit0 (bit0 (bit0 (bit0 (bit1 one)))))))
type mword256 = mword (bit0 (bit0 (bit0 (bit0 (bit0 (bit0 (bit0 (bit0 one))))))))
type mword257 = mword (bit1 (bit0 (bit0 (bit0 (bit0 (bit0 (bit0 (bit0 one))))))))

(* Pretty printing for both Isabelle and HOL so users don't suffer the encoding
 * above when using words...
 *)

declare isabelle target_rep type mword 'a = `word` 'a
declare hol      target_rep type mword 'a = `word` 'a

declare isabelle target_rep type mword3   = `3` `word`
declare isabelle target_rep type mword4   = `4` `word`
declare isabelle target_rep type mword5   = `5` `word`
declare isabelle target_rep type mword6   = `6` `word`
declare isabelle target_rep type mword7   = `7` `word`
declare isabelle target_rep type mword8   = `8` `word`
declare isabelle target_rep type mword9   = `9` `word`
declare isabelle target_rep type mword10  = `10` `word`
declare isabelle target_rep type mword11  = `11` `word`
declare isabelle target_rep type mword12  = `12` `word`
declare isabelle target_rep type mword13  = `13` `word`
declare isabelle target_rep type mword14  = `14` `word`
declare isabelle target_rep type mword15  = `15` `word`
declare isabelle target_rep type mword16  = `16` `word`
declare isabelle target_rep type mword17  = `17` `word`
declare isabelle target_rep type mword19  = `19` `word`
declare isabelle target_rep type mword20  = `20` `word`
declare isabelle target_rep type mword21  = `21` `word`
declare isabelle target_rep type mword22  = `22` `word`
declare isabelle target_rep type mword23  = `23` `word`
declare isabelle target_rep type mword24  = `24` `word`
declare isabelle target_rep type mword25  = `25` `word`
declare isabelle target_rep type mword26  = `26` `word`
declare isabelle target_rep type mword27  = `27` `word`
declare isabelle target_rep type mword28  = `28` `word`
declare isabelle target_rep type mword30  = `30` `word`
declare isabelle target_rep type mword31  = `31` `word`
declare isabelle target_rep type mword32  = `32` `word`
declare isabelle target_rep type mword33  = `33` `word`
declare isabelle target_rep type mword34  = `34` `word`
declare isabelle target_rep type mword35  = `35` `word`
declare isabelle target_rep type mword36  = `36` `word`
declare isabelle target_rep type mword37  = `37` `word`
declare isabelle target_rep type mword38  = `38` `word`
declare isabelle target_rep type mword40  = `40` `word`
declare isabelle target_rep type mword41  = `41` `word`
declare isabelle target_rep type mword45  = `45` `word`
declare isabelle target_rep type mword46  = `46` `word`
declare isabelle target_rep type mword48  = `48` `word`
declare isabelle target_rep type mword50  = `50` `word`
declare isabelle target_rep type mword51  = `51` `word`
declare isabelle target_rep type mword52  = `52` `word`
declare isabelle target_rep type mword55  = `55` `word`
declare isabelle target_rep type mword56  = `56` `word`
declare isabelle target_rep type mword58  = `58` `word`
declare isabelle target_rep type mword59  = `59` `word`
declare isabelle target_rep type mword60  = `60` `word`
declare isabelle target_rep type mword61  = `61` `word`
declare isabelle target_rep type mword62  = `62` `word`
declare isabelle target_rep type mword63  = `63` `word`
declare isabelle target_rep type mword64  = `64` `word`
declare isabelle target_rep type mword65  = `65` `word`
declare isabelle target_rep type mword128 = `128` `word`
declare isabelle target_rep type mword192 = `192` `word`
declare isabelle target_rep type mword256 = `256` `word`
declare isabelle target_rep type mword257 = `257` `word`

declare hol target_rep type mword1   = `1` `word`
declare hol target_rep type mword2   = `2` `word`
declare hol target_rep type mword3   = `3` `word`
declare hol target_rep type mword4   = `4` `word`
declare hol target_rep type mword5   = `5` `word`
declare hol target_rep type mword6   = `6` `word`
declare hol target_rep type mword7   = `7` `word`
declare hol target_rep type mword8   = `8` `word`
declare hol target_rep type mword9   = `9` `word`
declare hol target_rep type mword10  = `10` `word`
declare hol target_rep type mword11  = `11` `word`
declare hol target_rep type mword12  = `12` `word`
declare hol target_rep type mword13  = `13` `word`
declare hol target_rep type mword14  = `14` `word`
declare hol target_rep type mword15  = `15` `word`
declare hol target_rep type mword16  = `16` `word`
declare hol target_rep type mword17  = `17` `word`
declare hol target_rep type mword19  = `19` `word`
declare hol target_rep type mword20  = `20` `word`
declare hol target_rep type mword21  = `21` `word`
declare hol target_rep type mword22  = `22` `word`
declare hol target_rep type mword23  = `23` `word`
declare hol target_rep type mword24  = `24` `word`
declare hol target_rep type mword25  = `25` `word`
declare hol target_rep type mword26  = `26` `word`
declare hol target_rep type mword27  = `27` `word`
declare hol target_rep type mword28  = `28` `word`
declare hol target_rep type mword30  = `30` `word`
declare hol target_rep type mword31  = `31` `word`
declare hol target_rep type mword32  = `32` `word`
declare hol target_rep type mword33  = `33` `word`
declare hol target_rep type mword34  = `34` `word`
declare hol target_rep type mword35  = `35` `word`
declare hol target_rep type mword36  = `36` `word`
declare hol target_rep type mword37  = `37` `word`
declare hol target_rep type mword38  = `38` `word`
declare hol target_rep type mword40  = `40` `word`
declare hol target_rep type mword41  = `41` `word`
declare hol target_rep type mword45  = `45` `word`
declare hol target_rep type mword46  = `46` `word`
declare hol target_rep type mword48  = `48` `word`
declare hol target_rep type mword50  = `50` `word`
declare hol target_rep type mword51  = `51` `word`
declare hol target_rep type mword52  = `52` `word`
declare hol target_rep type mword55  = `55` `word`
declare hol target_rep type mword56  = `56` `word`
declare hol target_rep type mword58  = `58` `word`
declare hol target_rep type mword59  = `59` `word`
declare hol target_rep type mword60  = `60` `word`
declare hol target_rep type mword61  = `61` `word`
declare hol target_rep type mword62  = `62` `word`
declare hol target_rep type mword63  = `63` `word`
declare hol target_rep type mword64  = `64` `word`
declare hol target_rep type mword65  = `65` `word`
declare hol target_rep type mword128 = `128` `word`
declare hol target_rep type mword192 = `192` `word`
declare hol target_rep type mword256 = `256` `word`
declare hol target_rep type mword257 = `257` `word`

(******************************************************************)
(* Comparisons                                                    *)
(******************************************************************)

val mwordEq : forall 'a. mword 'a -> mword 'a -> bool
let inline mwordEq = unsafe_structural_equality

instance forall 'a. (Eq (mword 'a))
  let (=)        = mwordEq
  let (<>) w1 w2 = not (mwordEq w1 w2)
end

val signedLess : forall 'a. mword 'a -> mword 'a -> bool

declare isabelle target_rep function signedLess = `word_sless`
declare hol      target_rep function signedLess = `word_lt`

val signedLessEq : forall 'a. mword 'a -> mword 'a -> bool

declare isabelle target_rep function signedLessEq = `word_sle`
declare hol      target_rep function signedLessEq = `word_le`

val unsignedLess : forall 'a. mword 'a -> mword 'a -> bool

declare isabelle target_rep function unsignedLess = `ord_word_inst.less_word`
declare hol      target_rep function unsignedLess = `word_lo`

val unsignedLessEq : forall 'a. mword 'a -> mword 'a -> bool

declare isabelle target_rep function unsignedLessEq = `ord_word_inst.less_eq_word`
declare hol      target_rep function unsignedLessEq = `word_ls`

(******************************************************************)
(* Appending, splitting and probing words                         *)
(******************************************************************)

(* Word cat, split, not needed? *)

val setBit : forall 'a. mword 'a -> natural -> bool -> mword 'a

declare isabelle target_rep function setBit = `bits_word_inst.set_bit_word`

val getBit : forall 'a. mword 'a -> natural -> bool

declare isabelle target_rep function getBit     = `bits_word_inst.test_bit_word`
declare hol      target_rep function getBit w b = `word_bit` w b

val msb : forall 'a. mword 'a -> bool

declare isabelle target_rep function msb = `bitss_word_inst.msb_word`
declare hol      target_rep function msb = `word_msb`

val lsb : forall 'a. mword 'a -> bool

declare isabelle target_rep function lsb = `bits_word_inst.lsb_word`
declare hol      target_rep function lsb = `word_lsb`


(******************************************************************)
(* Conversions                                                    *)
(******************************************************************)

val signedIntegerFromWord : forall 'a. mword 'a -> integer

declare isabelle target_rep function signedIntegerFromWord = `sint`

val unsignedIntegerFromWord : forall 'a. mword 'a -> integer

declare isabelle target_rep function unsignedIntegerFromWord = `uint`

val wordFromInteger : forall 'a. integer -> mword 'a

declare isabelle target_rep function wordFromInteger = `word_of_int`

val naturalFromWord : forall 'a. mword 'a -> natural

declare isabelle target_rep function naturalFromWord = `unat`
declare hol      target_rep function naturalFromWord = `w2n`

val wordFromNatural : forall 'a. natural -> mword 'a

declare hol      target_rep function wordFromNatural = `n2w`

let {isabelle} wordFromNatural n =
  wordFromInteger (integerFromNatural n)

(******************************************************************)
(* Bitwise operations, shifts, etc.                               *)
(******************************************************************)

val shiftLeft  : forall 'a. mword 'a -> natural -> mword 'a

declare isabelle target_rep function shiftLeft = `sshiftl`
declare hol      target_rep function shiftLeft = `word_lsl`

val shiftRight : forall 'a. mword 'a -> natural -> mword 'a

declare isabelle target_rep function shiftRight = `sshiftr`
declare hol      target_rep function shiftRight = `word_lsr`

val lAnd       : forall 'a. mword 'a -> mword 'a -> mword 'a

declare isabelle target_rep function lAnd = `bit_word_inst.bitAND_word`
declare hol      target_rep function lAnd = `word_and`

val lOr        : forall 'a. mword 'a -> mword 'a -> mword 'a

declare isabelle target_rep function lOr = `bit_word_inst.bitOR_word`
declare hol      target_rep function lOr = `word_or`

val lXor       : forall 'a. mword 'a -> mword 'a -> mword 'a

declare isabelle target_rep function lXor = `bit_word_inst.bitXOR_word`
declare hol      target_rep function lXor = `word_xor`

val lNot       : forall 'a. mword 'a -> mword 'a

declare isabelle target_rep function lNot = `bit_word_inst.bitNOT_word`
declare hol      target_rep function lNot = `word_1comp`

val rotateRight : forall 'a. natural -> mword 'a -> mword 'a

declare isabelle target_rep function rotateRight = `word_rotr`
declare hol      target_rep function rotateRight = `word_ror`

val rotateLeft : forall 'a. natural -> mword 'a -> mword 'a

declare isabelle target_rep function rotateLeft = `word_rotl`
declare hol      target_rep function rotateLeft = `word_rol`

val zeroExtend : forall 'a 'b. mword 'a -> mword 'b

declare isabelle target_rep function zeroExtend = `ucast`
declare hol      target_rep function zeroExtend = `w2w`

val signExtend : forall 'a 'b. mword 'a -> mword 'b

declare isabelle target_rep function signExtend = `scast`
declare hol      target_rep function signExtend = `sw2sw`

(*****************************************************************)
(* Arithmetic                                                    *)
(*****************************************************************)

val plus   : forall 'a. mword 'a -> mword 'a -> mword 'a

declare isabelle target_rep function plus = `plus_word_inst.plus_word`
declare hol      target_rep function plus = `word_add`

val minus  : forall 'a. mword 'a -> mword 'a -> mword 'a

declare isabelle target_rep function minus = `minus_word_inst.minus_word`
declare hol      target_rep function minus = `word_sub`

val uminus : forall 'a. mword 'a -> mword 'a

declare isabelle target_rep function uminus = `uminus_word_inst.uminus_word`
let {hol} uminus m =
  (minus (wordFromNatural 0) m)

val times : forall 'a. mword 'a -> mword 'a -> mword 'a

declare isabelle target_rep function times = `times_word_inst.times_word`
declare hol      target_rep function times = `word_mul`

val unsignedDivide : forall 'a. mword 'a -> mword 'a -> mword 'a
val signedDivide : forall 'a. mword 'a -> mword 'a -> mword 'a

declare isabelle target_rep function unsignedDivide = `divide_word_inst.divide_word`
declare hol      target_rep function unsignedDivide = `word_div`
declare hol      target_rep function signedDivide   = `word_sdiv`

let {isabelle} signedDivide x y =
  wordFromInteger ((signedIntegerFromWord x) / (signedIntegerFromWord y))

val modulo : forall 'a. mword 'a -> mword 'a -> mword 'a

declare isabelle target_rep function modulo = `modulo_word_inst.modulo_word`
declare hol      target_rep function modulo = `word_mod`
