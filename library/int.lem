(* TODO: This is not the right type *)
type int = Hol.Integer.int

(* Addition *)
val (+) : int -> int -> int
let inline {hol} (+) = Hol.int_add
let inline {ocaml} (+) = Ocaml.(+)
let inline {isabelle} (+) = Isabelle.int_add
let inline {coq} (+) = Coq.int_plus

(* Subtraction *)
val (-) : int -> int -> int
let inline {hol} (-) = Hol.int_sub
let inline {ocaml} (-) = Ocaml.Pervasives.(-)
let inline {isabelle} (-) = Isabelle.int_sub
let inline {coq} (-) = Coq.int_minus

(* Multiplication *)
val ( * ) : int -> int -> int
let inline {hol} ( * ) = Hol.int_mul
let inline {ocaml} ( * ) = Ocaml.( * )
let inline {isabelle} ( * ) = Isabelle.int_mul
let inline {coq} ( * ) = Coq.int_mult

(* Integer Exponentiation *)
val ( ** ) : int -> num -> int
let inline {ocaml} ( ** ) = Ocaml.Nat_num.int_exp
let inline {isabelle} ( ** ) = Isabelle.int_exp
let inline {coq} ( ** ) = Coq.int_exp

(* Integer division *)
val (/) : int -> int -> int
let inline {hol} (/) = Hol.int_div
let inline {ocaml} (/) = Ocaml.(/)
let inline {isabelle} (/) = Isabelle.int_div
let inline {coq} (/) = Coq.int_div

(* Modulo *)
val (%) : int -> int -> int
let inline {hol} (%) = Hol.int_mod
let inline {ocaml} (%) = Ocaml.(mod)
let inline {isabelle} (%) = Isabelle.int_mod
let inline {coq} (%) = Coq.int_mod

(* Less *)
val (<) : int -> int -> bool
let inline {hol} (<) = Hol.int_lt
let inline {ocaml} (<) = Ocaml.(<)
let inline {isabelle} (<) = Isabelle.int_lt
let inline {coq} (<) = Coq.int_lt_b

(* Less equal *)
val (<=) : int -> int -> bool
let inline {hol} (<=) = Hol.int_le
let inline {ocaml} (<=) = Ocaml.(<=)
let inline {isabelle} (<=) = Isabelle.int_le
let inline {coq} (<=) = Coq.int_lte_b

(* Greater *)
val (>) : int -> int -> bool
let inline {hol} (>) = Hol.int_gt
let inline {ocaml} (>) = Ocaml.(>)
let inline {isabelle} (>) = Isabelle.int_gt
let inline {coq} (>) = Coq.int_gt_b

(* Greater equal *)
val (>=) : int -> int -> bool
let inline {hol} (>=) = Hol.int_ge
let inline {ocaml} (>=) = Ocaml.(>=)
let inline {isabelle} (>=) = Isabelle.int_ge
let inline {coq} (>=) = Coq.int_gte_b

(* transformation of num to integer *)
val int : num -> int
let inline {ocaml} int = Ocaml.Nat_num.int
let inline {isabelle} int = Isabelle.int
let inline {coq} int = Coq.pos_int_of_num

(* negation, i.e. neg 5 = -5 *)
val neg : int -> int
let inline {ocaml} neg = Ocaml.Nat_num.neg
let inline {isabelle} neg = Isabelle.int_neg
let inline {coq} neg = Coq.int_negation
