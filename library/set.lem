val singleton : forall 'a. 'a -> set 'a
let inline {coq} singleton = Coq.set_singleton

val add : forall 'a. 'a -> set 'a -> set 'a
let inline {coq} add = Coq.set_add
let inline {hol} add = Hol.INSERT
let inline {ocaml} add = Ocaml.Pset.add
let inline {isabelle} add = Isabelle.Set.insert

val for_all : forall 'a. ('a -> bool) -> set 'a -> bool
let inline {ocaml} for_all = Ocaml.Pset.for_all
let inline {hol} for_all f xs = Hol.EVERY f (Hol.SET_TO_LIST xs)
let inline {isabelle} for_all P S = Isabelle.Set.Ball S P
let inline {coq} for_all = Coq.set_for_all

(*let inline {hol} exists f xs = exist (x IN xs). f x*)
val exist : forall 'a. ('a -> bool) -> set 'a -> bool
let inline {ocaml} exist = Ocaml.Pset.\\exists
let inline {hol} exist f xs = Hol.EXISTS f (Hol.SET_TO_LIST xs)
let inline {isabelle} exist P S = Isabelle.Set.Bex S P 
let inline {coq} exist = Coq.set_exists

val cardinal : forall 'a. set 'a -> num
let inline {ocaml} cardinal = Ocaml.Pset.cardinal
let inline {hol} cardinal = Hol.CARD
let inline {coq} cardinal = Coq.set_cardinal
let inline {isabelle} cardinal = Isabelle.card

val from_list : forall 'a.  list 'a -> set 'a
let inline {ocaml} from_list = Ocaml.Pset.from_list Ocaml.compare
let inline {hol} from_list = Hol.LIST_TO_SET
let inline {isabelle} from_list = Isabelle.List.set
let inline {coq} from_list = Coq.set_from_list

val to_list : forall 'a. set 'a -> list 'a
let inline {ocaml} to_list = Ocaml.Pset.elements
let inline {hol} to_list = Hol.SET_TO_LIST
let inline {coq} to_list = Coq.set_elements
let inline {isabelle} to_list = Isabelle.list_of_set

val is_empty : forall 'a. set 'a -> bool
let inline {ocaml} is_empty = Ocaml.Pset.is_empty
let inline {hol} is_empty xs = xs = Hol.EMPTY
let inline {isabelle} is_empty xs = (xs = Isabelle.Set.empty)
let inline {coq} is_empty = Coq.set_is_empty

(* DPM: remember to change this so that the default value is returned for the other backends *)
val choose : forall 'a. set 'a -> 'a -> 'a
let inline {ocaml} choose s d = Ocaml.Pset.choose s
let inline {hol} choose s d = Hol.CHOICE s
let inline {isabelle} choose s d = Isabelle.set_choose s
let inline {coq} choose = Coq.set_choose

val fold : forall 'a 'b. ('a -> 'b -> 'b) -> set 'a -> 'b -> 'b
let inline {coq} fold = Coq.set_fold
let inline {ocaml} fold = Ocaml.Pset.fold
let inline {hol} fold = Hol.ITSET
let inline {isabelle} fold f A q = Isabelle.Finite_Set.fold f q A

val filter : forall 'a. ('a -> bool) -> set 'a -> set 'a
let inline {ocaml} filter = Ocaml.Pset.filter
let inline {isabelle} filter = Isabelle.set_filter

val image : forall 'a 'b. ('a -> 'b) -> set 'a -> set 'b
let inline {isabelle} image = Isabelle.Set.image
let inline {hol} image = Hol.IMAGE

val cross : forall 'a 'b. set 'a -> set 'b -> set ('a * 'b)
let inline {isabelle} cross = Isabelle.set_cross
let inline {hol} cross = Hol.CROSS

(* set_sigma A (fun a -> B a) should result in the set
   { (a, b) | a IN A && b IN B a } *)
val set_sigma : forall 'a 'b. set 'a -> ('a -> set 'b) -> set ('a * 'b)
let inline {isabelle} set_sigma = Isabelle.Sigma

val compare: forall 'a. set 'a -> set 'a -> num
let inline {coq} compare = Coq.set_compare

(* TODO: Document and add HOL/Isa implementation *)
val lfp : forall 'a. set 'a -> (set 'a -> set 'a) -> set 'a
let inline {ocaml} lfp = Ocaml.Pset.lfp

val (=) : forall 'a. set 'a -> set 'a -> bool
let inline {ocaml} (=) = Ocaml.Pset.equal 

val map : forall 'a 'b. ('a -> 'b) -> set 'a -> set 'b
let inline {ocaml} map = Ocaml.Pset.map Ocaml.compare
